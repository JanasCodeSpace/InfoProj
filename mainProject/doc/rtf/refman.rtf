{\rtf1\ansi\ansicpg1252\uc1 \deff0\deflang1033\deflangfe1033
{\fonttbl {\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}
{\f1\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}Arial;}
{\f2\fmodern\fcharset0\fprq1{\*\panose 02070309020205020404}Courier New;}
{\f3\froman\fcharset2\fprq2{\*\panose 05050102010706020507}Symbol;}
}
{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;\red0\green128\blue0;\red96\green64\blue32;\rede0\green128\blue0;\red128\green0\blue0;\red128\green96\blue32;\red0\green32\blue128;\red0\green128\blue128;\red255\green0\blue255;\red0\green0\blue0;\red112\green0\blue112;\red255\green0\blue0;}
{\stylesheet
{\widctlpar\adjustright \fs20\cgrid \snext0 Normal;}
{\paperw11900\paperh16840\margl1800\margr1800\margt1440\margb1440\gutter0\ltrsect}
{\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid \sbasedon0 \snext0 heading 1;}
{\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid \sbasedon0 \snext0 heading 2;}
{\s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid \sbasedon0 \snext0 heading 3;}
{\s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 4;}{\*\cs10 \additive Default Paragraph Font;}
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 5;}{\*\cs10 \additive Default Paragraph Font;}
{\s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid \sbasedon0 \snext15 Title;}
{\s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid \sbasedon0 \snext16 Subtitle;}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid \sbasedon0 \snext17 BodyText;}
{\s18\widctlpar\fs22\cgrid \sbasedon0 \snext18 DenseText;}
{\s28\widctlpar\tqc\tx4320\tqr\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext28 header;}
{\s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid \sbasedon0 \snext29 footer;}
{\s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext30 GroupHeader;}
{\s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext41 Code Example 0;}
{\s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext42 Code Example 1;}
{\s42\li720\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext43 Code Example 2;}
{\s43\li1080\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext44 Code Example 3;}
{\s44\li1440\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext45 Code Example 4;}
{\s45\li1800\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext46 Code Example 5;}
{\s46\li2160\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext47 Code Example 6;}
{\s47\li2520\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext48 Code Example 7;}
{\s48\li2880\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext49 Code Example 8;}
{\s49\li3240\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext50 Code Example 9;}
{\s50\li3600\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext51 Code Example 10;}
{\s51\li3960\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext52 Code Example 11;}
{\s52\li4320\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext53 Code Example 12;}
{\s53\li4680\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext53 Code Example 13;}
{\s60\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext61 List Continue 0;}
{\s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext62 List Continue 1;}
{\s62\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext63 List Continue 2;}
{\s63\li1080\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext64 List Continue 3;}
{\s64\li1440\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext65 List Continue 4;}
{\s65\li1800\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext66 List Continue 5;}
{\s66\li2160\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext67 List Continue 6;}
{\s67\li2520\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext68 List Continue 7;}
{\s68\li2880\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext69 List Continue 8;}
{\s69\li3240\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext70 List Continue 9;}
{\s70\li3600\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext71 List Continue 10;}
{\s71\li3960\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext72 List Continue 11;}
{\s72\li4320\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext73 List Continue 12;}
{\s73\li4680\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext73 List Continue 13;}
{\s80\li0\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext81 DescContinue 0;}
{\s81\li360\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext82 DescContinue 1;}
{\s82\li720\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext83 DescContinue 2;}
{\s83\li1080\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext84 DescContinue 3;}
{\s84\li1440\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext85 DescContinue 4;}
{\s85\li1800\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext86 DescContinue 5;}
{\s86\li2160\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext87 DescContinue 6;}
{\s87\li2520\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext88 DescContinue 7;}
{\s88\li2880\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext89 DescContinue 8;}
{\s89\li3240\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext90 DescContinue 9;}
{\s90\li3600\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext91 DescContinue 10;}
{\s91\li3960\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext92 DescContinue 11;}
{\s92\li4320\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext93 DescContinue 12;}
{\s93\li4680\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext93 DescContinue 13;}
{\s100\li0\sa30\sb30\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext101 LatexTOC 0;}
{\s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext102 LatexTOC 1;}
{\s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext103 LatexTOC 2;}
{\s103\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext104 LatexTOC 3;}
{\s104\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext105 LatexTOC 4;}
{\s105\li1800\sa15\sb15\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext106 LatexTOC 5;}
{\s106\li2160\sa12\sb12\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext107 LatexTOC 6;}
{\s107\li2520\sa9\sb9\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext108 LatexTOC 7;}
{\s108\li2880\sa6\sb6\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext109 LatexTOC 8;}
{\s109\li3240\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext110 LatexTOC 9;}
{\s110\li3600\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext111 LatexTOC 10;}
{\s111\li3960\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext112 LatexTOC 11;}
{\s112\li4320\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext113 LatexTOC 12;}
{\s113\li4680\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext113 LatexTOC 13;}
{\s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext121 \sautoupd List Bullet 0;}
{\s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext122 \sautoupd List Bullet 1;}
{\s122\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext123 \sautoupd List Bullet 2;}
{\s123\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext124 \sautoupd List Bullet 3;}
{\s124\fi-360\li1800\widctlpar\jclisttab\tx1800{\*\pn \pnlvlbody\ilvl0\ls5\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext125 \sautoupd List Bullet 4;}
{\s125\fi-360\li2160\widctlpar\jclisttab\tx2160{\*\pn \pnlvlbody\ilvl0\ls6\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext126 \sautoupd List Bullet 5;}
{\s126\fi-360\li2520\widctlpar\jclisttab\tx2520{\*\pn \pnlvlbody\ilvl0\ls7\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext127 \sautoupd List Bullet 6;}
{\s127\fi-360\li2880\widctlpar\jclisttab\tx2880{\*\pn \pnlvlbody\ilvl0\ls8\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext128 \sautoupd List Bullet 7;}
{\s128\fi-360\li3240\widctlpar\jclisttab\tx3240{\*\pn \pnlvlbody\ilvl0\ls9\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext129 \sautoupd List Bullet 8;}
{\s129\fi-360\li3600\widctlpar\jclisttab\tx3600{\*\pn \pnlvlbody\ilvl0\ls10\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext130 \sautoupd List Bullet 9;}
{\s130\fi-360\li3960\widctlpar\jclisttab\tx3960{\*\pn \pnlvlbody\ilvl0\ls11\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext131 \sautoupd List Bullet 10;}
{\s131\fi-360\li4320\widctlpar\jclisttab\tx4320{\*\pn \pnlvlbody\ilvl0\ls12\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext132 \sautoupd List Bullet 11;}
{\s132\fi-360\li4680\widctlpar\jclisttab\tx4680{\*\pn \pnlvlbody\ilvl0\ls13\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext133 \sautoupd List Bullet 12;}
{\s133\fi-360\li5040\widctlpar\jclisttab\tx5040{\*\pn \pnlvlbody\ilvl0\ls14\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext133 \sautoupd List Bullet 13;}
{\s140\fi-360\li360\widctlpar\fs20\cgrid \sbasedon0 \snext141 \sautoupd List Enum 0;}
{\s141\fi-360\li720\widctlpar\fs20\cgrid \sbasedon0 \snext142 \sautoupd List Enum 1;}
{\s142\fi-360\li1080\widctlpar\fs20\cgrid \sbasedon0 \snext143 \sautoupd List Enum 2;}
{\s143\fi-360\li1440\widctlpar\fs20\cgrid \sbasedon0 \snext144 \sautoupd List Enum 3;}
{\s144\fi-360\li1800\widctlpar\fs20\cgrid \sbasedon0 \snext145 \sautoupd List Enum 4;}
{\s145\fi-360\li2160\widctlpar\fs20\cgrid \sbasedon0 \snext146 \sautoupd List Enum 5;}
{\s146\fi-360\li2520\widctlpar\fs20\cgrid \sbasedon0 \snext147 \sautoupd List Enum 6;}
{\s147\fi-360\li2880\widctlpar\fs20\cgrid \sbasedon0 \snext148 \sautoupd List Enum 7;}
{\s148\fi-360\li3240\widctlpar\fs20\cgrid \sbasedon0 \snext149 \sautoupd List Enum 8;}
{\s149\fi-360\li3600\widctlpar\fs20\cgrid \sbasedon0 \snext150 \sautoupd List Enum 9;}
{\s150\fi-360\li3960\widctlpar\fs20\cgrid \sbasedon0 \snext151 \sautoupd List Enum 10;}
{\s151\fi-360\li4320\widctlpar\fs20\cgrid \sbasedon0 \snext152 \sautoupd List Enum 11;}
{\s152\fi-360\li4680\widctlpar\fs20\cgrid \sbasedon0 \snext153 \sautoupd List Enum 12;}
{\s153\fi-360\li5040\widctlpar\fs20\cgrid \sbasedon0 \snext153 \sautoupd List Enum 13;}
}
{\info 
{\title {\comment RobCodeGenerator }RobCodeGenerator}
{\comment Erzeugt von doxygen 1.9.7.}
}\pard\plain 
\sectd\pgnlcrm
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\vertalc\qc\par\par\par\par\par\par\par
\pard\plain \s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid 
{\field\fldedit {\*\fldinst TITLE \\*MERGEFORMAT}{\fldrslt RobCodeGenerator}}\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\par
\par\par\par\par\par\par\par\par\par\par\par\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
{\field\fldedit {\*\fldinst AUTHOR \\*MERGEFORMAT}{\fldrslt AUTHOR}}\par
Version \par\page\page\vertalt
\pard\plain 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid Inhaltsverzeichnis\par
\pard\plain \par
{\field\fldedit {\*\fldinst TOC \\f \\*MERGEFORMAT}{\fldrslt Table of contents}}\par
\pard\plain 
\sect \sbkpage \pgndec \pgnrestart
\sect \sectd \sbknone
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
\par \pard\plain 
\pard\plain \s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Beschreibung Roboter Path Editor\par \pard\plain 
{\tc\tcl1 \v Beschreibung Roboter Path Editor}
{\xe \v Beschreibung Roboter Path Editor}
{\bkmkstart AAAAAAAAGZ}
{\bkmkend AAAAAAAAGZ}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{\bkmkstart AAAAAAAAHA}
{\bkmkend AAAAAAAAHA}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Nutzen
\par}
{\tc\tcl2 \v Nutzen}
Mit diesem Programm sollen h\'E4ndisch aufgenommene Pfad Daten einer Roboterbewegung zu einem f\'FCr Kuka Roboter lesbaren File gemacht werden. Zus\'E4tzlich soll einstellbar sein ob die Orientierung berechnet werden soll, oder eingegeben werden soll. Das selbe gilt f\'FCr Geschwindigkeitsdaten.\par}
{\bkmkstart AAAAAAAAHB}
{\bkmkend AAAAAAAAHB}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Aufbau
\par}
{\tc\tcl2 \v Aufbau}
In der Grundidee werden die eingelesenen Daten immer aus der vorhergegangenen Klasse ausgelesen und nach der Verarbeitung in der aktuellen Klasse gespeichert.\par
{\bkmkstart AAAAAAAAHC}
{\bkmkend AAAAAAAAHC}
{{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Logging
\par}
{\tc\tcl3 \v Logging}
Zuerst wird die Loggingklasse {\b CLogging} initialisiert. In ihr wird gespeichert in welchem Schritt das Programm gerade ist. Dieser Klasse wird ein Pfad \'FCbergeben an welchem die Daten gespeichert werden sollen.\par}
{\bkmkstart AAAAAAAAHD}
{\bkmkend AAAAAAAAHD}
{{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Daten einlesen
\par}
{\tc\tcl3 \v Daten einlesen}
Als n\'E4chstes werden die Nutzerdaten eingelesen und anschliessend die aufgenommenen Daten eingelesen. Dabei wird \'DCberpr\'FCft ob es sich um einen zusammenh\'E4ngenden Pfad handelt. Das passiert in der Klasse {\b CInputParameter}.\par}
{\bkmkstart AAAAAAAAHE}
{\bkmkend AAAAAAAAHE}
{{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Daten verarbeiten
\par}
{\tc\tcl3 \v Daten verarbeiten}
In mehreren Schritten folgt eine Nachbearbeitung der Daten. Zuerst werden die Daten mit einem gleitendem Mittelwertfilter in der Klasse {\b CMeanFilter} gegl\'E4ttet. Anschliessend werden Punkte mit Hilfe des Douglas-Peuker Algorithmuses in der Klasse {\b CSegmentApproximator} gel\'F6scht. Sollten es mehrere nicht zusammenh\'E4ngende Pfade sein m\'FCssen diese jetzt noch zusammengesetzt werden.\par}
{\bkmkstart AAAAAAAAHF}
{\bkmkend AAAAAAAAHF}
{{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Roboter Code erstellen
\par}
{\tc\tcl3 \v Roboter Code erstellen}
Als letzter Schritt werden die Nutzereinstellungen in die Daten \'FCbernommen und der Robotercode erstellt. \par}
\par}
}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Hierarchie-Verzeichnis\par \pard\plain 
{\tc \v Hierarchie-Verzeichnis}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Klassenhierarchie\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Die Liste der Ableitungen ist -mit Einschr\'E4nkungen- alphabetisch sortiert:}
{
\par
\pard\plain \s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
CEulerMatrix\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
CGUI\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
CInputParameter\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
CLine3D\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
CLogging\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
CMeanFilter\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
CPathBuilder\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
CPoint3D\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFI \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
CInputPoint3D\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
COutputPoint3D\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
CRobCodeGenerator\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
CSegmentApproximator\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Klassen-Verzeichnis\par \pard\plain 
{\tc \v Klassen-Verzeichnis}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Auflistung der Klassen\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Hier folgt die Aufz\'E4hlung aller Klassen, Strukturen, Varianten und Schnittstellen mit einer Kurzbeschreibung:}
{
\par
\pard\plain \s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b {\b CEulerMatrix} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Handling und Berechnung Euler Matrix })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CGUI} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CInputParameter} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Handling Eingabedaten })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CInputPoint3D} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Input Punkt })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CLine3D} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Berechnung Geraden })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CLogging} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gleitender Mittelwertfilter })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CMeanFilter} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gleitender Mittelwertfilter })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b COutputPoint3D} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Output Punkt })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CPathBuilder} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Zusammensetzten des Pfades })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CPoint3D} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Grundklasse Punkt })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CRobCodeGenerator} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Klasse zum erstellen des Roboter Codes })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CSegmentApproximator} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Ausd\'FCnnen des Pfades })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Datei-Verzeichnis\par \pard\plain 
{\tc \v Datei-Verzeichnis}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Auflistung der Dateien\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Hier folgt die Aufz\'E4hlung aller Dateien mit einer Kurzbeschreibung:}
{
\par
\pard\plain \s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b header/{\b EulerMatrix.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Header File handling Euler Matrix })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b header/{\b GUI.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b header/{\b InputParameter.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Header File Daten Einlesen })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b header/{\b Line3D.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Header File Daten Einlesen })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b header/{\b Logging.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Logging der Daten })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b header/{\b MeanFilter.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Berechnung des gleitenden Mittelwertfilters })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b header/{\b PathBuilder.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Setzt die einzelnen Segmente zu einem Vector zusammen })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b header/{\b Point3D.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Verarbeitung der Punkte })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b header/{\b RobCodeGenerator.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Erstellung des Roboter Codes })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b header/{\b SegmentApproximator.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Berechnung des Douglas Peuker Algorithmusses })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b EulerMatrix.cpp} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Source Code der Euler Matrix })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b GUI.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b InputParameter.cpp} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Source File Daten Einlesen })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b Line3D.cpp} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Source File Line3D })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b Logging.cpp} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Source File Logging })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b MeanFilter.cpp} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Source File gleitender Mittelwertfilter })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b PathBuilder.cpp} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Source File Segmente zu Pfad })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b Point3D.cpp} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Source File Punkte })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b RobCodeGenerator.cpp} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Source File Roboter Code Erstellung })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b RobPathEditor.cpp} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Hier wird die main Funktion aufgerufen })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b SegmentApproximator.cpp} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Source File Douglas-Peuker })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Klassen-Dokumentation{\tc \v Klassen-Dokumentation}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CEulerMatrix Klassenreferenz\par \pard\plain 
{\tc\tcl2 \v CEulerMatrix}
{\xe \v CEulerMatrix}
{\bkmkstart AAAAAAAABT}
{\bkmkend AAAAAAAABT}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Handling und Berechnung Euler Matrix. }}\par
{
{\f2 #include <EulerMatrix.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'D6ffentliche Methoden\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CEulerMatrix} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Default Konstruktor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CEulerMatrix} (float inputMatrix[3][3])\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Default Konstruktor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~CEulerMatrix} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dekonstruktor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setMatrix} (float inputMatrix[3][3])\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Setzt eine Matrix. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CEulerMatrix} {\b getEulerMatrix} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Auslesen eine Matrix. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b getMatrix} (float Matrix[][3])\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Auslesen eine Matrix. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CEulerMatrix} {\b angels2mat} (double A, double B, double C)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Berechnet die neue Umdrehungsmatrix. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
tuple< double, double, double > {\b calculateAngels} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Berechnet die Kuka Wunkel A,B,C. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Attribute\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b eulerMatrix} [3][3]\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Ausf\'FChrliche Beschreibung\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Handling und Berechnung Euler Matrix. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Diese Klasse speichert die Euler Matrix und hat Funktionen f\'EF\'BF\'BDr Berechnungen mit eben jener. \par
}{
Definiert in Zeile {\b 20} der Datei {\b EulerMatrix.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Beschreibung der Konstruktoren und Destruktoren\par
\pard\plain 
{\xe \v CEulerMatrix\:CEulerMatrix}
{\xe \v CEulerMatrix\:CEulerMatrix}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CEulerMatrix::CEulerMatrix (void )}}
\par
{\bkmkstart AAAAAAAABU}
{\bkmkend AAAAAAAABU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Default Konstruktor. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialisiert die Input Daten mit Null \par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Siehe auch\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\b CEulerMatrix(float inputMatrix[3][3])} \par
}}}{
Definiert in Zeile {\b 10} der Datei {\b EulerMatrix.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00011 \{\par
00012     {\cf19 for} ({\cf18 int} i = 0; i < 3; i++)\par
00013     \{\par
00014         {\cf19 for} ({\cf18 int} m = 0; m < 3; m++)\par
00015         \{\par
00016             eulerMatrix[i][m] = 0;                  {\cf20 // eulerMatrix mit 0 initialisieren}\par
00017         \}\par
00018     \}\par
00019 \}\par
}
{
\ql
Benutzt {\b eulerMatrix}.}\par
}
{\xe \v CEulerMatrix\:CEulerMatrix}
{\xe \v CEulerMatrix\:CEulerMatrix}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CEulerMatrix::CEulerMatrix (float  {\i inputMatrix}[3][3])}}
\par
{\bkmkstart AAAAAAAABV}
{\bkmkend AAAAAAAABV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Default Konstruktor. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialisiert die Input Daten mit Null {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameter\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i float} \cell }{inputMatrix[3][3] initialisiert die Klasse mit einer Euler Matrix \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Siehe auch\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\b CEulerMatrix(void)} \par
}}}{
Definiert in Zeile {\b 21} der Datei {\b EulerMatrix.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00022 \{\par
00023     {\cf19 for} ({\cf18 int} i = 0; i < 3; i++)\par
00024     \{\par
00025         {\cf19 for} ({\cf18 int} m = 0; m < 3; m++)\par
00026         \{\par
00027             eulerMatrix[i][m] = inputMatrix[i][m];  {\cf20 // eulerMatrix mit Startwerten initialisieren}\par
00028         \}\par
00029     \}\par
00030 \}\par
}
{
\ql
Benutzt {\b eulerMatrix}.}\par
}
{\xe \v ~CEulerMatrix\:CEulerMatrix}
{\xe \v CEulerMatrix\:~CEulerMatrix}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CEulerMatrix::~CEulerMatrix ()}}
\par
{\bkmkstart AAAAAAAABW}
{\bkmkend AAAAAAAABW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dekonstruktor. }}\par
{
Definiert in Zeile {\b 32} der Datei {\b EulerMatrix.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00033 \{\par
00034 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Dokumentation der Elementfunktionen\par
\pard\plain 
{\xe \v angels2mat\:CEulerMatrix}
{\xe \v CEulerMatrix\:angels2mat}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CEulerMatrix} CEulerMatrix::angels2mat (double  {\i A}, double  {\i B}, double  {\i C})}}
\par
{\bkmkstart AAAAAAAABX}
{\bkmkend AAAAAAAABX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Berechnet die neue Umdrehungsmatrix. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameter\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i A} \cell }{double Winkel a \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i B} \cell }{double Winkel b \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i C} \cell }{double Winkel c \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
R\'FCckgabe\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
: float inputMatrix[3][3] gibt die neu berechnete Matrix zur\'EF\'BF\'BDck \par
}}}{
Definiert in Zeile {\b 65} der Datei {\b EulerMatrix.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00066 \{\par
00067     {\cf18 float} Matrix[3][3];     {\cf20 // DummyMatrix erstellen}\par
00068 \par
00069     {\cf20 /* Berechnung der Matrix */}\par
00070 \par
00071     Matrix[0][0] = cos(A) * cos(C) - sin(A) * cos(B) * sin(C);\par
00072     Matrix[0][1] = -cos(A) * sin(C) - sin(A) * cos(B) * cos(C);\par
00073     Matrix[0][2] = sin(A) * sin(B);\par
00074 \par
00075     Matrix[1][0] = sin(A) * cos(C) + cos(A) * cos(B) * sin(C);\par
00076     Matrix[1][1] = -sin(A) * sin(C) + cos(A) * cos(B) * cos(C);\par
00077     Matrix[1][2] = -cos(A) * sin(B);\par
00078 \par
00079     Matrix[2][0] = sin(B) * sin(C);\par
00080     Matrix[2][1] = sin(B) * cos(C);\par
00081     Matrix[2][2] = cos(B);\par
00082 \par
00083     CEulerMatrix buffer(Matrix);        {\cf20 // DummyMatrix in DummyEulerMatrix schreiben}\par
00084     {\cf19 return} buffer;                      {\cf20 // Matrix zur\'C3\'BCck geben}\par
00085 \}\par
}
}
{\xe \v calculateAngels\:CEulerMatrix}
{\xe \v CEulerMatrix\:calculateAngels}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
tuple< double, double, double > CEulerMatrix::calculateAngels (void )}}
\par
{\bkmkstart AAAAAAAABY}
{\bkmkend AAAAAAAABY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Berechnet die Kuka Wunkel A,B,C. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
R\'FCckgabe\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
: tuple<double , double , double> gibt die berechneten Winkel A, B, C zur\'C3\'BCck \par
}}}{
Definiert in Zeile {\b 88} der Datei {\b EulerMatrix.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00089 \{\par
00090     {\cf18 double} a, b, c, sin_a, cos_a, sin_b, abs_cos_b, sin_c, cos_c;\par
00091 \par
00092     {\cf20 /*}\par
00093 {\cf20     a == Winkel Alpha}\par
00094 {\cf20     b == Winkel Beta}\par
00095 {\cf20     c == Winkel Gamma}\par
00096 {\cf20 }\par
00097 {\cf20     sin_a == sinus alpha}\par
00098 {\cf20     cos_a == cosinus alpha}\par
00099 {\cf20     sin_b == Matrix[2][0] * -1}\par
00100 {\cf20     abs_cos_b == ??}\par
00101 {\cf20     sin_c == sinus gamma}\par
00102 {\cf20     cos_c == cosinus gamma}\par
00103 {\cf20     */}\par
00104 \par
00105 \par
00106     {\cf20 /* Berechnung von alpha*/}\par
00107     a = atan2(eulerMatrix[1][0], eulerMatrix[0][0]);\par
00108 \par
00109     {\cf20 /* Berechung von beta */}\par
00110     sin_a = sin(a);\par
00111     cos_a = cos(a);\par
00112     sin_b = eulerMatrix[2][0] * -1;\par
00113     abs_cos_b = cos(a) * eulerMatrix[0][0] + sin(a) * eulerMatrix[1][0];\par
00114 \par
00115     b = atan2 (sin_b, abs_cos_b);\par
00116 \par
00117     {\cf20 /* Berechung von gamma */}\par
00118     sin_c =  sin_a * eulerMatrix[0][2] - cos_a * eulerMatrix[1][2];\par
00119     cos_c = -sin_a * eulerMatrix[0][1] + cos_a * eulerMatrix[1][1];\par
00120 \par
00121     c = atan2(sin_c, cos_c);\par
00122 \par
00123     {\cf20 /* Bogenmass in Gradmass umrechnen */}\par
00124     a = a * 180 / M_PI;\par
00125     b = b * 180 / M_PI;\par
00126     c = c * 180 / M_PI;\par
00127 \par
00128 \par
00129     {\cf19 return} make_tuple(a, b, c);     {\cf20 // R\'C3\'BCckgabe der Winkel}\par
00130 \}\par
}
{
\ql
Benutzt {\b eulerMatrix}.}\par
{
\ql
Wird benutzt von {\b CRobCodeGenerator::calculateAngles()}.}\par
}
{\xe \v getEulerMatrix\:CEulerMatrix}
{\xe \v CEulerMatrix\:getEulerMatrix}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CEulerMatrix} CEulerMatrix::getEulerMatrix (void )}}
\par
{\bkmkstart AAAAAAAABZ}
{\bkmkend AAAAAAAABZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Auslesen eine Matrix. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
R\'FCckgabe\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
: float inputMatrix[3][3] gibt gespeicherte Matrix zur\'EF\'BF\'BDck \par
}}}{
Definiert in Zeile {\b 48} der Datei {\b EulerMatrix.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00049 \{\par
00050     {\cf19 return} eulerMatrix;         {\cf20 // EulerMatrix zur\'C3\'BCck geben}\par
00051 \}\par
}
{
\ql
Benutzt {\b eulerMatrix}.}\par
{
\ql
Wird benutzt von {\b CLogging::logData()} und {\b CInputParameter::openFile()}.}\par
}
{\xe \v getMatrix\:CEulerMatrix}
{\xe \v CEulerMatrix\:getMatrix}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CEulerMatrix::getMatrix (float  {\i Matrix}[][3])}}
\par
{\bkmkstart AAAAAAAACA}
{\bkmkend AAAAAAAACA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Auslesen eine Matrix. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameter\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i float*} \cell }{inputMatrix[3][3] Pointer zu einer Matrix \cell }
{\row }
}
}{
Definiert in Zeile {\b 53} der Datei {\b EulerMatrix.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00054 \{\par
00055     {\cf19 for} ({\cf18 int} i = 0; i < 3; i++)\par
00056     \{\par
00057         {\cf19 for} ({\cf18 int} m = 0; m < 3; m++)\par
00058         \{\par
00059             Matrix[i][m] = eulerMatrix[i][m];  {\cf20 // eulerMatrix mit \'EF\'BF\'BDbergabewerten \'EF\'BF\'BDberschreiben}\par
00060         \}\par
00061     \}\par
00062 \}\par
}
{
\ql
Benutzt {\b eulerMatrix}.}\par
{
\ql
Wird benutzt von {\b CLogging::logData()} und {\b CLogging::logData()}.}\par
}
{\xe \v setMatrix\:CEulerMatrix}
{\xe \v CEulerMatrix\:setMatrix}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CEulerMatrix::setMatrix (float  {\i inputMatrix}[3][3])}}
\par
{\bkmkstart AAAAAAAACB}
{\bkmkend AAAAAAAACB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Setzt eine Matrix. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameter\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i float} \cell }{inputMatrix[3][3] zum setzten einer Matrix \cell }
{\row }
}
}{
Definiert in Zeile {\b 37} der Datei {\b EulerMatrix.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00038 \{\par
00039     {\cf19 for}({\cf18 int} i = 0; i < 3; i++)\par
00040     \{ \par
00041         {\cf19 for} ({\cf18 int} m = 0; m < 3; m++)\par
00042         \{\par
00043             eulerMatrix[i][m] = inputMatrix[i][m];  {\cf20 // eulerMatrix mit \'C3\'83\'C2\'9Cbergabewerten \'C3\'83\'C2\'BCberschreiben}\par
00044         \}\par
00045     \}\par
00046 \}\par
}
{
\ql
Benutzt {\b eulerMatrix}.}\par
{
\ql
Wird benutzt von {\b CInputParameter::openFile()}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Dokumentation der Datenelemente\par
\pard\plain 
{\xe \v eulerMatrix\:CEulerMatrix}
{\xe \v CEulerMatrix\:eulerMatrix}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float CEulerMatrix::eulerMatrix[3][3]{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAACC}
{\bkmkend AAAAAAAACC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gespeicherte Euler Matrix \par
}{
Definiert in Zeile {\b 76} der Datei {\b EulerMatrix.h}.}\par
{
\ql
Wird benutzt von {\b calculateAngels()}, {\b CEulerMatrix()}, {\b CEulerMatrix()}, {\b getEulerMatrix()}, {\b getMatrix()} und {\b setMatrix()}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
Die Dokumentation f\'FCr diese Klasse wurde erzeugt aufgrund der Dateien:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
header/{\b EulerMatrix.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
src/{\b EulerMatrix.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CGUI Klassenreferenz\par \pard\plain 
{\tc\tcl2 \v CGUI}
{\xe \v CGUI}
{\bkmkstart AAAAAAAACD}
{\bkmkend AAAAAAAACD}
\par
{
{\f2 #include <GUI.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'D6ffentliche Methoden\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CGUI} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~CGUI} ()\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Ausf\'FChrliche Beschreibung\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definiert in Zeile {\b 3} der Datei {\b GUI.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Beschreibung der Konstruktoren und Destruktoren\par
\pard\plain 
{\xe \v CGUI\:CGUI}
{\xe \v CGUI\:CGUI}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CGUI::CGUI ()}}
\par
{\bkmkstart AAAAAAAACE}
{\bkmkend AAAAAAAACE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definiert in Zeile {\b 3} der Datei {\b GUI.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00004 \{\}\par
}
}
{\xe \v ~CGUI\:CGUI}
{\xe \v CGUI\:~CGUI}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CGUI::~CGUI ()}}
\par
{\bkmkstart AAAAAAAACF}
{\bkmkend AAAAAAAACF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definiert in Zeile {\b 6} der Datei {\b GUI.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00007 \{\}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
Die Dokumentation f\'FCr diese Klasse wurde erzeugt aufgrund der Dateien:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
header/{\b GUI.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
src/{\b GUI.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CInputParameter Klassenreferenz\par \pard\plain 
{\tc\tcl2 \v CInputParameter}
{\xe \v CInputParameter}
{\bkmkstart AAAAAAAACG}
{\bkmkend AAAAAAAACG}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Handling Eingabedaten. }}\par
{
{\f2 #include <InputParameter.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'D6ffentliche Methoden\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CInputParameter} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Default Konstruktor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CInputParameter} (double initSpeed, bool initSeepManual, bool initOrientationManual, double initA, double initB, double initC)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Konstruktor mit Werten. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~CInputParameter} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dekonstruktor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setOrientation} (bool initOrientationManual, double initA, double initB, double initC)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Setzt Orientierungs Daten. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setSpeed} (double initSpeed, bool initSpeedManual)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Setzt Geschwindigkeits Daten. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b getSpeed} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gibt Geschwindigkeit zur\'FCck. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b getSpeedManual} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gibt zur\'FCck ob h\'E4ndische Geschwindigkeit verwendet werden soll. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b getOrientationManual} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gibt zur\'FCck ob h\'E4ndische Orientierung verwendet werden soll. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
tuple< double, double, double > {\b getAngles} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gibt Winkel zur\'FCck. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b openFile} (std::string path)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Liest die Daten aus dem Input File ein. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b detectJump} ({\b CInputPoint3D} p, double x_prev, double y_prev, double z_prev)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Erkennt Spr\'FCnge in den Daten. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
vector< list< {\b CInputPoint3D} > > & {\b getPath} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gibt Pfad zur\'FCck. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Attribute\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
vector< list< {\b CInputPoint3D} > > {\b initialPath}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b speed}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b speedManual}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b orientationManual}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b A}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b B}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b C}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b difference} = 20\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Ausf\'FChrliche Beschreibung\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Handling Eingabedaten. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
In dieser Klasse werden die eingelesenen einstellbaren Daten und das einlesen der Daten aus der Eingabedatei gehandelt. \par
}{
Definiert in Zeile {\b 25} der Datei {\b InputParameter.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Beschreibung der Konstruktoren und Destruktoren\par
\pard\plain 
{\xe \v CInputParameter\:CInputParameter}
{\xe \v CInputParameter\:CInputParameter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CInputParameter::CInputParameter (void )}}
\par
{\bkmkstart AAAAAAAACH}
{\bkmkend AAAAAAAACH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Default Konstruktor. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialisiert die Input Daten mit Null \par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Siehe auch\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\b CInputParameter(double initSpeed, bool initSeepManual, bool initOrientationManual, double initA, double initB, double initC)} \par
}}}{
Definiert in Zeile {\b 24} der Datei {\b InputParameter.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00025 \{\par
00026     speed = 0.1;\par
00027     A = 0;\par
00028     B = 75;\par
00029     C = 0;\par
00030     speedManual = {\cf17 true},\par
00031     orientationManual = {\cf17 true};\par
00032 \par
00033 \}\par
}
{
\ql
Benutzt {\b A}, {\b B}, {\b C}, {\b orientationManual}, {\b speed} und {\b speedManual}.}\par
}
{\xe \v CInputParameter\:CInputParameter}
{\xe \v CInputParameter\:CInputParameter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CInputParameter::CInputParameter (double  {\i initSpeed}, bool  {\i initSeepManual}, bool  {\i initOrientationManual}, double  {\i initA}, double  {\i initB}, double  {\i initC})}}
\par
{\bkmkstart AAAAAAAACI}
{\bkmkend AAAAAAAACI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Konstruktor mit Werten. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialisiert die Input Daten {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameter\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i double} \cell }{initSpeed \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i bool} \cell }{initSeepManual \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i bool} \cell }{initOrientationManual \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i double} \cell }{initA \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i double} \cell }{initB \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i double} \cell }{initC \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Siehe auch\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\b CInputParameter()} \par
{\b ~CInputParameter()} \par
{\b CInputParameter(void)}; \par
}}}{
Definiert in Zeile {\b 12} der Datei {\b InputParameter.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00013 \{\par
00014     speed = initSpeed;\par
00015     speedManual = initSpeedManual;\par
00016     orientationManual = initOrientationManual;\par
00017     A = initA;\par
00018     B = initB;\par
00019     C = initC;\par
00020 \par
00021 \}\par
}
{
\ql
Benutzt {\b A}, {\b B}, {\b C}, {\b orientationManual}, {\b speed} und {\b speedManual}.}\par
}
{\xe \v ~CInputParameter\:CInputParameter}
{\xe \v CInputParameter\:~CInputParameter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CInputParameter::~CInputParameter (void )}}
\par
{\bkmkstart AAAAAAAACJ}
{\bkmkend AAAAAAAACJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dekonstruktor. }}\par
{
Definiert in Zeile {\b 35} der Datei {\b InputParameter.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00036 \{\par
00037 \par
00038 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Dokumentation der Elementfunktionen\par
\pard\plain 
{\xe \v detectJump\:CInputParameter}
{\xe \v CInputParameter\:detectJump}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool CInputParameter::detectJump ({\b CInputPoint3D}  {\i p}, double  {\i x_prev}, double  {\i y_prev}, double  {\i z_prev})}}
\par
{\bkmkstart AAAAAAAACK}
{\bkmkend AAAAAAAACK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Erkennt Spr\'FCnge in den Daten. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Um zu erkennen ob es mehrere Pfade sind wird nach Spr\'FCngen gesucht, bei einem Sprung wird eine neue Liste angefangen. {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameter\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i {\b CInputPoint3D}} \cell }{p den aktuellen Punkt \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i double} \cell }{x_prev die vorherige x Position \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i double} \cell }{y_prev die vorherige y Position \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i double} \cell }{z_prev die vorherige z Position \cell }
{\row }
}
}{
Definiert in Zeile {\b 126} der Datei {\b InputParameter.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00127 \{\par
00128     {\cf19 if}(abs(p.getX() - x_prev) > difference)             {\cf20 // Abstand zwischen Punkten gr\'F6\'DFer max Differenz??}\par
00129         {\cf19 return} {\cf17 true};\par
00130     {\cf19 else} {\cf19 if}(abs(p.getY() - y_prev) > difference)        {\cf20 // Abstand zwischen Punkten gr\'F6\'DFer max Differenz??}\par
00131         {\cf19 return} {\cf17 true};\par
00132     {\cf19 else} {\cf19 if}(abs(p.getZ() - z_prev) > difference)            {\cf20 // Abstand zwischen Punkten gr\'F6\'DFer max Differenz??}\par
00133         {\cf19 return} {\cf17 true};\par
00134     {\cf19 else}\par
00135         {\cf19 return} {\cf17 false};\par
00136 \}\par
}
{
\ql
Benutzt {\b difference}, {\b CPoint3D::getX()}, {\b CPoint3D::getY()} und {\b CPoint3D::getZ()}.}\par
{
\ql
Wird benutzt von {\b openFile()}.}\par
}
{\xe \v getAngles\:CInputParameter}
{\xe \v CInputParameter\:getAngles}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
tuple< double, double, double > CInputParameter::getAngles (void )}}
\par
{\bkmkstart AAAAAAAACL}
{\bkmkend AAAAAAAACL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gibt Winkel zur\'FCck. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gibt die eingegebenen Winkel als tuple zur\'FCck \par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
R\'FCckgabe\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
: tuple <double double double> angles \par
}}}{
Definiert in Zeile {\b 77} der Datei {\b InputParameter.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00078 \{\par
00079     {\cf19 return} make_tuple(A, B, C);     {\cf20 // Winkel zur\'FCck geben}\par
00080 \}\par
}
{
\ql
Benutzt {\b A}, {\b B} und {\b C}.}\par
{
\ql
Wird benutzt von {\b main()}.}\par
}
{\xe \v getOrientationManual\:CInputParameter}
{\xe \v CInputParameter\:getOrientationManual}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool CInputParameter::getOrientationManual (void )}}
\par
{\bkmkstart AAAAAAAACM}
{\bkmkend AAAAAAAACM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gibt zur\'FCck ob h\'E4ndische Orientierung verwendet werden soll. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gibt zur\'FCck ob h\'E4ndische Orientierung verwendet werden soll, sonst wird sie sp\'E4ter berechnet. \par
}{
Definiert in Zeile {\b 72} der Datei {\b InputParameter.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00073 \{\par
00074     {\cf19 return} orientationManual;       {\cf20 // Vorgew\'E4hlte Einstellung f\'FCr Orientierung zur\'FCck geben}\par
00075 \}\par
}
{
\ql
Benutzt {\b orientationManual}.}\par
{
\ql
Wird benutzt von {\b main()}.}\par
}
{\xe \v getPath\:CInputParameter}
{\xe \v CInputParameter\:getPath}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
vector< list< {\b CInputPoint3D} > > & CInputParameter::getPath ()}}
\par
{\bkmkstart AAAAAAAACN}
{\bkmkend AAAAAAAACN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gibt Pfad zur\'FCck. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
R\'FCckgabe\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
: vector<list<CInputPoint3D>> den eingelesen Pfad \par
}}}{
Definiert in Zeile {\b 57} der Datei {\b InputParameter.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00058 \{\par
00059     {\cf19 return} initialPath;     {\cf20 // Path zur\'FCck geben}\par
00060 \}\par
}
{
\ql
Benutzt {\b initialPath}.}\par
{
\ql
Wird benutzt von {\b main()}.}\par
}
{\xe \v getSpeed\:CInputParameter}
{\xe \v CInputParameter\:getSpeed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double CInputParameter::getSpeed (void )}}
\par
{\bkmkstart AAAAAAAACO}
{\bkmkend AAAAAAAACO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gibt Geschwindigkeit zur\'FCck. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gibt die eingegebene Geschwindigkeit zur\'FCck \par
}{
Definiert in Zeile {\b 62} der Datei {\b InputParameter.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00063 \{\par
00064     {\cf19 return} speed;           {\cf20 // Geschwindigkeit zur\'FCck geben}\par
00065 \}\par
}
{
\ql
Benutzt {\b speed}.}\par
{
\ql
Wird benutzt von {\b main()}.}\par
}
{\xe \v getSpeedManual\:CInputParameter}
{\xe \v CInputParameter\:getSpeedManual}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool CInputParameter::getSpeedManual (void )}}
\par
{\bkmkstart AAAAAAAACP}
{\bkmkend AAAAAAAACP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gibt zur\'FCck ob h\'E4ndische Geschwindigkeit verwendet werden soll. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gibt zur\'FCck ob h\'E4ndische Geschwindigekit verwendet werden soll, sonst wird sie sp\'E4ter berechnet. \par
}{
Definiert in Zeile {\b 67} der Datei {\b InputParameter.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00068 \{\par
00069     {\cf19 return} speedManual;             {\cf20 // Vorgew\'E4hlte Einstellung f\'FCr Geschwindigkeit zur\'FCck geben}\par
00070 \}\par
}
{
\ql
Benutzt {\b speedManual}.}\par
{
\ql
Wird benutzt von {\b main()}.}\par
}
{\xe \v openFile\:CInputParameter}
{\xe \v CInputParameter\:openFile}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CInputParameter::openFile (std::string  {\i path})}}
\par
{\bkmkstart AAAAAAAACQ}
{\bkmkend AAAAAAAACQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Liest die Daten aus dem Input File ein. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Liest die Daten aus einen beliebigen File ein und ruft @detectJump auf um zu erkennen ob es mehrere Aufnahmen sind. {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameter\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i File} \cell }{Pfad \cell }
{\row }
}
}{
Definiert in Zeile {\b 84} der Datei {\b InputParameter.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00085 \{\par
00086     ifstream fin(path);\par
00087     CInputPoint3D tmpPoint;     {\cf20 // Zwischenspeicher zum konvertieren von tmpEuler in Point3D}\par
00088     CEulerMatrix tmpEuler;      {\cf20 // Zwischenspeicher zum konverteiren von DummyMatrix in EulerMatrix}\par
00089     {\cf18 double} x, y, z;             {\cf20 // Punktkoordinaten}\par
00090     {\cf18 double} x_prev = 0, y_prev = 0, z_prev = 0;      {\cf20 // Zwischenspeicher f\'FCr Punktkoordinaten}\par
00091     {\cf18 double} timestamp;           {\cf20 // Zeitstempel}\par
00092     {\cf18 int} segmentCount = -1;      {\cf20 // Segmentz\'E4hler}\par
00093     {\cf18 float} dummyMatrix[3][3];    {\cf20 // DummyMatrix zum speichern}\par
00094 \par
00095 \par
00096     {\cf19 if} (!fin.is_open())\par
00097     \{\par
00098         cerr << {\cf22 "Datei konnte nicht ge\'F6ffnet werden"} << endl;       {\cf20 // Fehler Datei konnte nicht ge\'F6ffnet werden.}\par
00099     \}\par
00100     {\cf18 string} line;\par
00101 \par
00102     {\cf19 while}(getline(fin, line))\par
00103     \{\par
00104         std::istringstream sStream (line);\par
00105         sStream >> timestamp >> x >> y >> z >> dummyMatrix[0][0] >> dummyMatrix[0][1] >> dummyMatrix[0][2]                                      {\cf20 // Zeile in die einzelnen Parameter zerlegen }\par
00106             >> dummyMatrix[1][0] >> dummyMatrix[1][1] >> dummyMatrix[1][2] >> dummyMatrix[2][0] >> dummyMatrix[2][1] >> dummyMatrix[2][2];      {\cf20 // und in DummyMatrix bzw. Variablen abspeichern}\par
00107 \par
00108         tmpEuler.setMatrix(dummyMatrix);                                    {\cf20 // DummyMatrix[3][3] in EulerMatrix speichern                           }\par
00109         tmpPoint.setPoint(timestamp, x, y, z, tmpEuler.getEulerMatrix());   {\cf20 // Variablen und EulerWinkel in CPoint3D speichern}\par
00110 \par
00111         {\cf19 if} (detectJump(tmpPoint, x_prev, y_prev, z_prev)) {\cf20 // if there is a jump in the data, start da new segment }\par
00112         \{\par
00113             segmentCount++;                                 {\cf20 // neues Segement anlegen}\par
00114             initialPath.push_back(list<CInputPoint3D>());   {\cf20 // Punkt in Segent speichern}\par
00115         \}\par
00116 \par
00117         initialPath[segmentCount].push_back(tmpPoint);      {\cf20 // Punkt in bestehendes Segment abspeichern}\par
00118 \par
00119         x_prev = x;     {\cf20 // X-Wert zwischenspeichern}\par
00120         y_prev = y;     {\cf20 // Y-Wert zwischenspeichern}\par
00121         z_prev = z;     {\cf20 // Z-Wert zwischenspeichern}\par
00122     \}\par
00123     fin.close();        {\cf20 // Datei schlie\'DFen}\par
00124 \}\par
}
{
\ql
Benutzt {\b detectJump()}, {\b CEulerMatrix::getEulerMatrix()}, {\b initialPath}, {\b CEulerMatrix::setMatrix()} und {\b CInputPoint3D::setPoint()}.}\par
{
\ql
Wird benutzt von {\b main()}.}\par
}
{\xe \v setOrientation\:CInputParameter}
{\xe \v CInputParameter\:setOrientation}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CInputParameter::setOrientation (bool  {\i initOrientationManual}, double  {\i initA}, double  {\i initB}, double  {\i initC})}}
\par
{\bkmkstart AAAAAAAACR}
{\bkmkend AAAAAAAACR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Setzt Orientierungs Daten. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Setzt ob die Orientierung H\'E4ndisch eingegeben werden soll und die drei Winkel {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameter\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i bool} \cell }{initOrientationManual \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i double} \cell }{initA \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i double} \cell }{initB \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i double} \cell }{initC \cell }
{\row }
}
}{
Definiert in Zeile {\b 42} der Datei {\b InputParameter.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00043 \{\par
00044     orientationManual = initOrientationManual;\par
00045     A = initA;\par
00046     B = initB;\par
00047     C = initC;\par
00048 \}\par
}
{
\ql
Benutzt {\b A}, {\b B}, {\b C} und {\b orientationManual}.}\par
}
{\xe \v setSpeed\:CInputParameter}
{\xe \v CInputParameter\:setSpeed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CInputParameter::setSpeed (double  {\i initSpeed}, bool  {\i initSpeedManual})}}
\par
{\bkmkstart AAAAAAAACS}
{\bkmkend AAAAAAAACS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Setzt Geschwindigkeits Daten. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Setzt ob die Geschwindigkeit H\'E4ndisch eingegeben werden soll und die Geschwindigkeit in m/s {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameter\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i double} \cell }{initSpeed \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i bool} \cell }{initSeepManual \cell }
{\row }
}
}{
Definiert in Zeile {\b 51} der Datei {\b InputParameter.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00052 \{\par
00053     speed = initSpeed;\par
00054     speedManual = initSpeedManual;\par
00055 \}\par
}
{
\ql
Benutzt {\b speed} und {\b speedManual}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Dokumentation der Datenelemente\par
\pard\plain 
{\xe \v A\:CInputParameter}
{\xe \v CInputParameter\:A}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double CInputParameter::A{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAACT}
{\bkmkend AAAAAAAACT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
User eingegebener Winkel A \par
}{
Definiert in Zeile {\b 133} der Datei {\b InputParameter.h}.}\par
{
\ql
Wird benutzt von {\b CInputParameter()}, {\b CInputParameter()}, {\b getAngles()} und {\b setOrientation()}.}\par
}
{\xe \v B\:CInputParameter}
{\xe \v CInputParameter\:B}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double CInputParameter::B{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAACU}
{\bkmkend AAAAAAAACU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
User eingegebener Winkel B \par
}{
Definiert in Zeile {\b 137} der Datei {\b InputParameter.h}.}\par
{
\ql
Wird benutzt von {\b CInputParameter()}, {\b CInputParameter()}, {\b getAngles()} und {\b setOrientation()}.}\par
}
{\xe \v C\:CInputParameter}
{\xe \v CInputParameter\:C}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double CInputParameter::C{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAACV}
{\bkmkend AAAAAAAACV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
User eingegebener Winkel C \par
}{
Definiert in Zeile {\b 141} der Datei {\b InputParameter.h}.}\par
{
\ql
Wird benutzt von {\b CInputParameter()}, {\b CInputParameter()}, {\b getAngles()} und {\b setOrientation()}.}\par
}
{\xe \v difference\:CInputParameter}
{\xe \v CInputParameter\:difference}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double CInputParameter::difference = 20{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAACW}
{\bkmkend AAAAAAAACW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sprung ab dem eine neue Liste angefangen wird \par
}{
Definiert in Zeile {\b 145} der Datei {\b InputParameter.h}.}\par
{
\ql
Wird benutzt von {\b detectJump()}.}\par
}
{\xe \v initialPath\:CInputParameter}
{\xe \v CInputParameter\:initialPath}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
vector<list<{\b CInputPoint3D}> > CInputParameter::initialPath{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAACX}
{\bkmkend AAAAAAAACX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Vector mit Listen an Input Daten \par
}{
Definiert in Zeile {\b 117} der Datei {\b InputParameter.h}.}\par
{
\ql
Wird benutzt von {\b getPath()} und {\b openFile()}.}\par
}
{\xe \v orientationManual\:CInputParameter}
{\xe \v CInputParameter\:orientationManual}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool CInputParameter::orientationManual{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAACY}
{\bkmkend AAAAAAAACY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Auswahl ob berechnete oder eingegebene Winkel verwendet werden soll \par
}{
Definiert in Zeile {\b 129} der Datei {\b InputParameter.h}.}\par
{
\ql
Wird benutzt von {\b CInputParameter()}, {\b CInputParameter()}, {\b getOrientationManual()} und {\b setOrientation()}.}\par
}
{\xe \v speed\:CInputParameter}
{\xe \v CInputParameter\:speed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double CInputParameter::speed{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAACZ}
{\bkmkend AAAAAAAACZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
User eingegebene Geschwindigkeit \par
}{
Definiert in Zeile {\b 121} der Datei {\b InputParameter.h}.}\par
{
\ql
Wird benutzt von {\b CInputParameter()}, {\b CInputParameter()}, {\b getSpeed()} und {\b setSpeed()}.}\par
}
{\xe \v speedManual\:CInputParameter}
{\xe \v CInputParameter\:speedManual}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool CInputParameter::speedManual{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAADA}
{\bkmkend AAAAAAAADA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Auswahl ob berechnete oder eingegebene Geschwindigkeit verwendet werden soll \par
}{
Definiert in Zeile {\b 125} der Datei {\b InputParameter.h}.}\par
{
\ql
Wird benutzt von {\b CInputParameter()}, {\b CInputParameter()}, {\b getSpeedManual()} und {\b setSpeed()}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
Die Dokumentation f\'FCr diese Klasse wurde erzeugt aufgrund der Dateien:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
header/{\b InputParameter.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
src/{\b InputParameter.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CInputPoint3D Klassenreferenz\par \pard\plain 
{\tc\tcl2 \v CInputPoint3D}
{\xe \v CInputPoint3D}
{\bkmkstart AAAAAAAADB}
{\bkmkend AAAAAAAADB}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Input Punkt. }}\par
{
{\f2 #include <Point3D.h>}}\par
Klassendiagramm f\'FCr CInputPoint3D:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c_input_point3_d.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'D6ffentliche Methoden\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CInputPoint3D} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Default Konstruktor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CInputPoint3D} (double X, double Y, double Z, double Timestamp, {\b CEulerMatrix} Matrix)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Default Konstruktor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~CInputPoint3D} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dekonstruktor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b getTime} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gibt den Zeitstempel zur\'FCck. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CEulerMatrix} {\b getEulerMatrix} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gibt die gespeicherte Eulermatrix zur\'FCck. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setTime} (double time)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Setzt den Zeitstempel. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setEulerMatrix} ({\b CEulerMatrix} orientation)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Setzt die Eulermatrix. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setPoint} (double time, double X, double Y, double Z, {\b CEulerMatrix} orientation)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Setzt einen Input Punkt. }{
}\par
}\par}
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
\'D6ffentliche Methoden geerbt von {\b CPoint3D}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CPoint3D} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Default Konstruktor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CPoint3D} (double X, double Y, double Z)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Default Konstruktor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~CPoint3D} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dekonstruktor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b getX} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gibt X zur\'FCck. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b getY} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gibt Y zur\'FCck. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b getZ} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gibt Z zur\'FCck. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setX} (double X)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Setzt X. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setY} (double Y)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Setzt Y. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setZ} (double Z)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Setzt Z. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b set} (double X, double Y, double Z)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Setzt X, Y und Z. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b distanceTo} ({\b CPoint3D} point)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Berechnet die Distanz zu einem anderen Punkt. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b distanceTo} ({\b CLine3D} line)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Berechnet die Distanz zu einer Linie. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Attribute\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b timestamp}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CEulerMatrix} {\b orientationMatrix}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Weitere Geerbte Elemente\par
\pard\plain 
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Gesch\'FCtzte Attribute geerbt von {\b CPoint3D}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b x}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b y}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b z}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Ausf\'FChrliche Beschreibung\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Input Punkt. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Kind der Punkt Grundklasse, erweitert um den Timestamp und die Eulermatrix \par
}{
Definiert in Zeile {\b 106} der Datei {\b Point3D.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Beschreibung der Konstruktoren und Destruktoren\par
\pard\plain 
{\xe \v CInputPoint3D\:CInputPoint3D}
{\xe \v CInputPoint3D\:CInputPoint3D}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CInputPoint3D::CInputPoint3D (void )}}
\par
{\bkmkstart AAAAAAAADC}
{\bkmkend AAAAAAAADC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Default Konstruktor. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialisiert des eingelesenen Punktes mit Null \par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Siehe auch\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\b CInputPoint3D(double X, double Y, double Z, double Timestamp, CEulerMatrix Matrix)} \par
}}}{
Definiert in Zeile {\b 110} der Datei {\b Point3D.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00110                                  : CPoint3D()\par
00111 \{\par
00112     timestamp = 0;      {\cf20 // Zeitstempel mit 0 initialisieren}\par
00113 \}\par
}
{
\ql
Benutzt {\b timestamp}.}\par
}
{\xe \v CInputPoint3D\:CInputPoint3D}
{\xe \v CInputPoint3D\:CInputPoint3D}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CInputPoint3D::CInputPoint3D (double  {\i X}, double  {\i Y}, double  {\i Z}, double  {\i Timestamp}, {\b CEulerMatrix}  {\i Matrix})}}
\par
{\bkmkstart AAAAAAAADD}
{\bkmkend AAAAAAAADD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Default Konstruktor. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialisiert des eingelesenen Punktes mit Null {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameter\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i double} \cell }{X \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i double} \cell }{Y \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i double} \cell }{Z \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i double} \cell }{Timestamp \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i {\b CEulerMatrix}} \cell }{Matrix \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Siehe auch\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\b CInputPoint3D(double X, double Y, double Z, double Timestamp, CEulerMatrix Matrix)} \par
}}}{
Definiert in Zeile {\b 116} der Datei {\b Point3D.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00117 \{\par
00118     x = X;\par
00119     y = Y;\par
00120     z = Z;\par
00121     timestamp = Timestamp;\par
00122     orientationMatrix = Matrix;\par
00123 \}\par
}
{
\ql
Benutzt {\b orientationMatrix}, {\b timestamp}, {\b CPoint3D::x}, {\b CPoint3D::y} und {\b CPoint3D::z}.}\par
}
{\xe \v ~CInputPoint3D\:CInputPoint3D}
{\xe \v CInputPoint3D\:~CInputPoint3D}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CInputPoint3D::~CInputPoint3D (void )}}
\par
{\bkmkstart AAAAAAAADE}
{\bkmkend AAAAAAAADE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dekonstruktor. }}\par
{
Definiert in Zeile {\b 125} der Datei {\b Point3D.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00126 \{\par
00127 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Dokumentation der Elementfunktionen\par
\pard\plain 
{\xe \v getEulerMatrix\:CInputPoint3D}
{\xe \v CInputPoint3D\:getEulerMatrix}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CEulerMatrix} CInputPoint3D::getEulerMatrix ()}}
\par
{\bkmkstart AAAAAAAADF}
{\bkmkend AAAAAAAADF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gibt die gespeicherte Eulermatrix zur\'FCck. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
R\'FCckgabe\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\b CEulerMatrix} \par
}}}{
Definiert in Zeile {\b 147} der Datei {\b Point3D.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00148 \{\par
00149     {\cf19 return} orientationMatrix;   {\cf20 // R\'FCckgabe der EulerMatrix}\par
00150 \}\par
}
{
\ql
Benutzt {\b orientationMatrix}.}\par
{
\ql
Wird benutzt von {\b CRobCodeGenerator::calculateAngles()}.}\par
}
{\xe \v getTime\:CInputPoint3D}
{\xe \v CInputPoint3D\:getTime}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double CInputPoint3D::getTime ()}}
\par
{\bkmkstart AAAAAAAADG}
{\bkmkend AAAAAAAADG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gibt den Zeitstempel zur\'FCck. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
R\'FCckgabe\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
double Zeitstempel \par
}}}{
Definiert in Zeile {\b 152} der Datei {\b Point3D.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00153 \{\par
00154     {\cf19 return} timestamp;       {\cf20 // R\'FCckgabe des Zeitstempel}\par
00155 \}\par
}
{
\ql
Benutzt {\b timestamp}.}\par
{
\ql
Wird benutzt von {\b CRobCodeGenerator::calculateSpeed()}.}\par
}
{\xe \v setEulerMatrix\:CInputPoint3D}
{\xe \v CInputPoint3D\:setEulerMatrix}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CInputPoint3D::setEulerMatrix ({\b CEulerMatrix}  {\i orientation})}}
\par
{\bkmkstart AAAAAAAADH}
{\bkmkend AAAAAAAADH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Setzt die Eulermatrix. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameter\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i {\b CEulerMatrix}} \cell }{orientation \cell }
{\row }
}
}{
Definiert in Zeile {\b 129} der Datei {\b Point3D.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00130 \{\par
00131     orientationMatrix = orientation;    {\cf20 // EulerMatrix setzen}\par
00132 \}\par
}
{
\ql
Benutzt {\b orientationMatrix}.}\par
{
\ql
Wird benutzt von {\b CMeanFilter::calculateMean()}, {\b CPathBuilder::createPath()}, {\b CSegmentApproximator::douglasPeuckerRecursive()} und {\b setPoint()}.}\par
}
{\xe \v setPoint\:CInputPoint3D}
{\xe \v CInputPoint3D\:setPoint}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CInputPoint3D::setPoint (double  {\i time}, double  {\i X}, double  {\i Y}, double  {\i Z}, {\b CEulerMatrix}  {\i orientation})}}
\par
{\bkmkstart AAAAAAAADI}
{\bkmkend AAAAAAAADI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Setzt einen Input Punkt. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameter\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i double} \cell }{time \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i double} \cell }{X \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i double} \cell }{Y \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i double} \cell }{Z \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i {\b CEulerMatrix}} \cell }{orientation \cell }
{\row }
}
}{
Definiert in Zeile {\b 135} der Datei {\b Point3D.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00136 \{\par
00137     setTime(time);  {\cf20 // Zeitstempel setzen}\par
00138     set(X, Y, Z);   {\cf20 // setze Punkt-Koordinaten}\par
00139     setEulerMatrix(orientation); {\cf20 // EulerMatrix setzen}\par
00140 \}\par
}
{
\ql
Benutzt {\b CPoint3D::set()}, {\b setEulerMatrix()} und {\b setTime()}.}\par
{
\ql
Wird benutzt von {\b CInputParameter::openFile()}.}\par
}
{\xe \v setTime\:CInputPoint3D}
{\xe \v CInputPoint3D\:setTime}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CInputPoint3D::setTime (double  {\i time})}}
\par
{\bkmkstart AAAAAAAADJ}
{\bkmkend AAAAAAAADJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Setzt den Zeitstempel. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameter\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i double} \cell }{time \cell }
{\row }
}
}{
Definiert in Zeile {\b 142} der Datei {\b Point3D.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00143 \{\par
00144     timestamp = time;   {\cf20 // Zeitstempel setzen}\par
00145 \}\par
}
{
\ql
Benutzt {\b timestamp}.}\par
{
\ql
Wird benutzt von {\b CMeanFilter::calculateMean()}, {\b CPathBuilder::createPath()}, {\b CSegmentApproximator::douglasPeuckerRecursive()} und {\b setPoint()}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Dokumentation der Datenelemente\par
\pard\plain 
{\xe \v orientationMatrix\:CInputPoint3D}
{\xe \v CInputPoint3D\:orientationMatrix}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CEulerMatrix} CInputPoint3D::orientationMatrix{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAADK}
{\bkmkend AAAAAAAADK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Eulermatrix des Punktes \par
}{
Definiert in Zeile {\b 170} der Datei {\b Point3D.h}.}\par
{
\ql
Wird benutzt von {\b CInputPoint3D()}, {\b getEulerMatrix()} und {\b setEulerMatrix()}.}\par
}
{\xe \v timestamp\:CInputPoint3D}
{\xe \v CInputPoint3D\:timestamp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double CInputPoint3D::timestamp{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAADL}
{\bkmkend AAAAAAAADL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Zeitstempel \par
}{
Definiert in Zeile {\b 166} der Datei {\b Point3D.h}.}\par
{
\ql
Wird benutzt von {\b CInputPoint3D()}, {\b CInputPoint3D()}, {\b getTime()} und {\b setTime()}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
Die Dokumentation f\'FCr diese Klasse wurde erzeugt aufgrund der Dateien:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
header/{\b Point3D.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
src/{\b Point3D.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CLine3D Klassenreferenz\par \pard\plain 
{\tc\tcl2 \v CLine3D}
{\xe \v CLine3D}
{\bkmkstart AAAAAAAADM}
{\bkmkend AAAAAAAADM}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Berechnung Geraden. }}\par
{
{\f2 #include <Line3D.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'D6ffentliche Methoden\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CLine3D} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Default Konstruktor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CLine3D} ({\b CPoint3D} P1, {\b CPoint3D} P2)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Konstruktor mit zwei Punkten. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~CLine3D} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dekonstruktor. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'D6ffentliche Attribute\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CPoint3D} {\b p1}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CPoint3D} {\b p2}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Ausf\'FChrliche Beschreibung\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Berechnung Geraden. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
In dieser Klasse werden alle Berechnungen die zwischen zwei Punken passieren gehandhabt. \par
}{
Definiert in Zeile {\b 18} der Datei {\b Line3D.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Beschreibung der Konstruktoren und Destruktoren\par
\pard\plain 
{\xe \v CLine3D\:CLine3D}
{\xe \v CLine3D\:CLine3D}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CLine3D::CLine3D (void )}}
\par
{\bkmkstart AAAAAAAADN}
{\bkmkend AAAAAAAADN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Default Konstruktor. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialisiert die Klasse \par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Siehe auch\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\b CLine3D(CPoint3D P1, CPoint3D P2)} \par
}}}{
Definiert in Zeile {\b 10} der Datei {\b Line3D.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00011 \{\par
00012 \}\par
}
}
{\xe \v CLine3D\:CLine3D}
{\xe \v CLine3D\:CLine3D}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CLine3D::CLine3D ({\b CPoint3D}  {\i P1}, {\b CPoint3D}  {\i P2})}}
\par
{\bkmkstart AAAAAAAADO}
{\bkmkend AAAAAAAADO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Konstruktor mit zwei Punkten. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialisiert die Klasse \par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Siehe auch\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\b CLine3D(void)}; \par
}}}{
Definiert in Zeile {\b 15} der Datei {\b Line3D.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00016 \{\par
00017     p1 = P1;\par
00018     p2 = P2;\par
00019 \}\par
}
{
\ql
Benutzt {\b p1} und {\b p2}.}\par
}
{\xe \v ~CLine3D\:CLine3D}
{\xe \v CLine3D\:~CLine3D}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CLine3D::~CLine3D (void )}}
\par
{\bkmkstart AAAAAAAADP}
{\bkmkend AAAAAAAADP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dekonstruktor. }}\par
{
Definiert in Zeile {\b 21} der Datei {\b Line3D.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00022 \{\par
00023 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Dokumentation der Datenelemente\par
\pard\plain 
{\xe \v p1\:CLine3D}
{\xe \v CLine3D\:p1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CPoint3D} CLine3D::p1}}
\par
{\bkmkstart AAAAAAAADQ}
{\bkmkend AAAAAAAADQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Punkt 1 \par
}{
Definiert in Zeile {\b 41} der Datei {\b Line3D.h}.}\par
{
\ql
Wird benutzt von {\b CLine3D()} und {\b CPoint3D::distanceTo()}.}\par
}
{\xe \v p2\:CLine3D}
{\xe \v CLine3D\:p2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CPoint3D} CLine3D::p2}}
\par
{\bkmkstart AAAAAAAADR}
{\bkmkend AAAAAAAADR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Punkt 2 \par
}{
Definiert in Zeile {\b 45} der Datei {\b Line3D.h}.}\par
{
\ql
Wird benutzt von {\b CLine3D()} und {\b CPoint3D::distanceTo()}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
Die Dokumentation f\'FCr diese Klasse wurde erzeugt aufgrund der Dateien:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
header/{\b Line3D.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
src/{\b Line3D.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CLogging Klassenreferenz\par \pard\plain 
{\tc\tcl2 \v CLogging}
{\xe \v CLogging}
{\bkmkstart AAAAAAAADS}
{\bkmkend AAAAAAAADS}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gleitender Mittelwertfilter. }}\par
{
{\f2 #include <Logging.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'D6ffentliche Methoden\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CLogging} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Default Konstruktor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CLogging} (string {\b path})\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Default Konstruktor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~CLogging} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dekonstruktor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setStep} (int Step)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Setzt in welchem Schritt wir uns befinden. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b logData} (vector< list< {\b CInputPoint3D} > > &sourcePath)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Ruft calculateMean f\'FCr die einzelnen Segmente auf. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b logData} (vector< {\b CInputPoint3D} > &sourcePath)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Ruft calculateMean f\'FCr die einzelnen Segmente auf. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Attribute\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b step}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
string {\b path}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Ausf\'FChrliche Beschreibung\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gleitender Mittelwertfilter. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
In dieser Klasse werden die eingelesenen Daten mit einem gleitenden Mittelwertfilter mit einstellbarem Fenster gegl\'E4ttet. \par
}{
Definiert in Zeile {\b 22} der Datei {\b Logging.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Beschreibung der Konstruktoren und Destruktoren\par
\pard\plain 
{\xe \v CLogging\:CLogging}
{\xe \v CLogging\:CLogging}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CLogging::CLogging (void )}}
\par
{\bkmkstart AAAAAAAADT}
{\bkmkend AAAAAAAADT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Default Konstruktor. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialisiert Logging Klasse \par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Siehe auch\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\b CMeanFilter(int Window)}; \par
}}}{
Definiert in Zeile {\b 10} der Datei {\b Logging.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00011 \{\par
00012     step = 0;\par
00013 \}\par
}
{
\ql
Benutzt {\b step}.}\par
}
{\xe \v CLogging\:CLogging}
{\xe \v CLogging\:CLogging}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CLogging::CLogging (string  {\i path})}}
\par
{\bkmkstart AAAAAAAADU}
{\bkmkend AAAAAAAADU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Default Konstruktor. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialisiert Logging Klasse \par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Siehe auch\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\b CMeanFilter(int Window)}; \par
}}}{
Definiert in Zeile {\b 16} der Datei {\b Logging.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00017 \{\par
00018     path = Path;\par
00019 \}\par
}
{
\ql
Benutzt {\b path}.}\par
}
{\xe \v ~CLogging\:CLogging}
{\xe \v CLogging\:~CLogging}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CLogging::~CLogging (void )}}
\par
{\bkmkstart AAAAAAAADV}
{\bkmkend AAAAAAAADV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dekonstruktor. }}\par
{
Definiert in Zeile {\b 21} der Datei {\b Logging.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00022 \{\par
00023 \par
00024 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Dokumentation der Elementfunktionen\par
\pard\plain 
{\xe \v logData\:CLogging}
{\xe \v CLogging\:logData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CLogging::logData (vector< {\b CInputPoint3D} > &  {\i sourcePath})}}
\par
{\bkmkstart AAAAAAAADW}
{\bkmkend AAAAAAAADW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Ruft calculateMean f\'FCr die einzelnen Segmente auf. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Loggingdaten werden weggespeichert {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameter\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i vector<CInputPoint3D>&} \cell }{sourcePath \cell }
{\row }
}
}{
Definiert in Zeile {\b 67} der Datei {\b Logging.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00068 \{\par
00069     {\cf18 string} filepath;            {\cf20 // file Pfad}\par
00070     {\cf18 float} dummyMatrix[3][3];    {\cf20 // dummyMatrix zum Zwischenspeichern}\par
00071     CEulerMatrix tmpEuler;      {\cf20 // CEulerMatrix zum Zwischenspeichern}\par
00072 \par
00073     filepath = path + {\cf22 "/"} + {\cf22 "0"} + std::to_string(step) + {\cf22 "_path.csv"};\par
00074 \par
00075     FILE* fid = fopen(filepath.c_str(), {\cf22 "w"});   {\cf20 // file \'F6ffnen}\par
00076 \par
00077     {\cf19 if} (fid == NULL)\par
00078     \{\par
00079         cerr << {\cf22 "ERROR - Can NOT write to output file!\\n"};  {\cf20 // Fehler beim file \'F6ffnen}\par
00080         {\cf19 return};\par
00081     \}\par
00082 \par
00083     {\cf20 /* Ausgeben der Punkte mit dummyMatrix */}\par
00084     {\cf19 for} ({\cf18 size_t} s = 0; s < sourcePath.size(); s++) {\cf20 //for all points in the vector}\par
00085     \{\par
00086         tmpEuler.getMatrix(dummyMatrix);\par
00087 \par
00088         fprintf(fid, {\cf22 "%f %f %f %f %f %f %f %f %f %f %f %f %f\\n"}, ({\cf18 double})sourcePath[s].getTime(), \par
00089             ({\cf18 double})sourcePath[s].getX(), ({\cf18 double})sourcePath[s].getY(), ({\cf18 double})sourcePath[s].getZ(),\par
00090             dummyMatrix[0][0], dummyMatrix[0][1], dummyMatrix[0][2],\par
00091             dummyMatrix[1][0], dummyMatrix[1][1], dummyMatrix[1][2],\par
00092             dummyMatrix[2][0], dummyMatrix[2][1], dummyMatrix[2][2]);\par
00093     \}\par
00094 \}\par
}
{
\ql
Benutzt {\b CEulerMatrix::getMatrix()}, {\b path} und {\b step}.}\par
}
{\xe \v logData\:CLogging}
{\xe \v CLogging\:logData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CLogging::logData (vector< list< {\b CInputPoint3D} > > &  {\i sourcePath})}}
\par
{\bkmkstart AAAAAAAADX}
{\bkmkend AAAAAAAADX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Ruft calculateMean f\'FCr die einzelnen Segmente auf. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Loggingdaten werden weggespeichert {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameter\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i vector<list<CInputPoint3D>>&} \cell }{sourcePath \cell }
{\row }
}
}{
Definiert in Zeile {\b 31} der Datei {\b Logging.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00032 \{\par
00033     {\cf18 string} filepath;            {\cf20 // file Pfad}\par
00034     {\cf18 float} dummyMatrix[3][3];    {\cf20 // dummyMatrix zum Zwischenspeichern}\par
00035     CEulerMatrix tmpEuler;      {\cf20 // CEulerMatrix zum Zwischenspeichern}\par
00036 \par
00037     filepath = path + {\cf22 "/"} + {\cf22 "0"} + std::to_string(step) + {\cf22 "_path.csv"};\par
00038 \par
00039     FILE* fid = fopen(filepath.c_str(), {\cf22 "w"});       {\cf20 // file \'F6ffnen}\par
00040 \par
00041     {\cf19 if} (fid == NULL)\par
00042     \{\par
00043         cerr << {\cf22 "ERROR - Can NOT write to output file!\\n"};      {\cf20 // Fehler beim file \'F6ffnen}\par
00044         {\cf19 return};\par
00045     \}\par
00046 \par
00047     {\cf19 for} ({\cf18 size_t} s = 0; s < sourcePath.size(); s++) {\cf20 //for all segments}\par
00048     \{\par
00049         list<CInputPoint3D>::iterator itr = sourcePath[s].begin();\par
00050 \par
00051         tmpEuler = itr->getEulerMatrix();\par
00052         tmpEuler.getMatrix(dummyMatrix);\par
00053 \par
00054         {\cf20 /* Ausgeben der Punkte mit dummyMatrix */}\par
00055         {\cf19 for} (; itr != sourcePath[s].end(); itr++) {\cf20 //for all points in the segment}\par
00056         \{\par
00057             fprintf(fid, {\cf22 "%f %f %f %f %f %f %f %f %f %f %f %f %f\\n"}, ({\cf18 double})itr->getTime(), ({\cf18 double})itr->getX(), ({\cf18 double})itr->getY(), ({\cf18 double})itr->getZ(),\par
00058                 dummyMatrix[0][0], dummyMatrix[0][1], dummyMatrix[0][2],\par
00059                 dummyMatrix[1][0], dummyMatrix[1][1], dummyMatrix[1][2],\par
00060                 dummyMatrix[2][0], dummyMatrix[2][1], dummyMatrix[2][2]);\par
00061         \}\par
00062 \par
00063         itr--;\par
00064     \}\par
00065 \}\par
}
{
\ql
Benutzt {\b CEulerMatrix::getEulerMatrix()}, {\b CEulerMatrix::getMatrix()}, {\b path} und {\b step}.}\par
{
\ql
Wird benutzt von {\b CSegmentApproximator::approx()}, {\b CPathBuilder::createPath()} und {\b CMeanFilter::mean()}.}\par
}
{\xe \v setStep\:CLogging}
{\xe \v CLogging\:setStep}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CLogging::setStep (int  {\i Step})}}
\par
{\bkmkstart AAAAAAAADY}
{\bkmkend AAAAAAAADY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Setzt in welchem Schritt wir uns befinden. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameter\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i int} \cell }{Step \cell }
{\row }
}
}{
Definiert in Zeile {\b 26} der Datei {\b Logging.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00027 \{\par
00028     step = Step;    {\cf20 // Step setzen}\par
00029 \}\par
}
{
\ql
Benutzt {\b step}.}\par
{
\ql
Wird benutzt von {\b CSegmentApproximator::approx()}, {\b CPathBuilder::createPath()} und {\b CMeanFilter::mean()}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Dokumentation der Datenelemente\par
\pard\plain 
{\xe \v path\:CLogging}
{\xe \v CLogging\:path}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
string CLogging::path{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAADZ}
{\bkmkend AAAAAAAADZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Speicherpfad \par
}{
Definiert in Zeile {\b 66} der Datei {\b Logging.h}.}\par
{
\ql
Wird benutzt von {\b CLogging()}, {\b logData()} und {\b logData()}.}\par
}
{\xe \v step\:CLogging}
{\xe \v CLogging\:step}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CLogging::step{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAEA}
{\bkmkend AAAAAAAAEA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
In welchem Schritt sind wir gerade \par
}{
Definiert in Zeile {\b 62} der Datei {\b Logging.h}.}\par
{
\ql
Wird benutzt von {\b CLogging()}, {\b logData()}, {\b logData()} und {\b setStep()}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
Die Dokumentation f\'FCr diese Klasse wurde erzeugt aufgrund der Dateien:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
header/{\b Logging.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
src/{\b Logging.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CMeanFilter Klassenreferenz\par \pard\plain 
{\tc\tcl2 \v CMeanFilter}
{\xe \v CMeanFilter}
{\bkmkstart AAAAAAAAEB}
{\bkmkend AAAAAAAAEB}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gleitender Mittelwertfilter. }}\par
{
{\f2 #include <MeanFilter.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'D6ffentliche Methoden\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CMeanFilter} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Default Konstruktor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CMeanFilter} (int Window)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Konstruktor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~CMeanFilter} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dekonstruktor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setWindowSize} (int Window)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Setzt das Fenster. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b getWindowSize} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gibt das gesetzte Fenster zur\'FCck. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
vector< list< {\b CInputPoint3D} > > & {\b getPath} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gibt den gegl\'E4tteten Pfad zur\'FCck. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
list< {\b CInputPoint3D} > {\b calculateMean} (list< {\b CInputPoint3D} > &segment)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Berechnet gleitenden Mittelwert. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b mean} (vector< list< {\b CInputPoint3D} > > &sourcePath, {\b CLogging} log)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Ruft calculateMean f\'FCr die einzelnen Segmente auf. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Attribute\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b windowSize}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
vector< list< {\b CInputPoint3D} > > {\b meanPath}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Ausf\'FChrliche Beschreibung\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gleitender Mittelwertfilter. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
In dieser Klasse werden die eingelesenen Daten mit einem gleitenden Mittelwertfilter mit einstellbarem Fenster gegl\'E4ttet. \par
}{
Definiert in Zeile {\b 21} der Datei {\b MeanFilter.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Beschreibung der Konstruktoren und Destruktoren\par
\pard\plain 
{\xe \v CMeanFilter\:CMeanFilter}
{\xe \v CMeanFilter\:CMeanFilter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CMeanFilter::CMeanFilter ()}}
\par
{\bkmkstart AAAAAAAAEC}
{\bkmkend AAAAAAAAEC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Default Konstruktor. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialisiert des Fensters mit 3 als default Wert \par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Siehe auch\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\b CMeanFilter(int Window)}; \par
}}}{
Definiert in Zeile {\b 11} der Datei {\b MeanFilter.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00012 \{\par
00013     windowSize = 3;         {\cf20 // initialisieren mit Standardfenstergr\'F6\'DFe 3}\par
00014 \}\par
}
{
\ql
Benutzt {\b windowSize}.}\par
}
{\xe \v CMeanFilter\:CMeanFilter}
{\xe \v CMeanFilter\:CMeanFilter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CMeanFilter::CMeanFilter (int  {\i Window})}}
\par
{\bkmkstart AAAAAAAAED}
{\bkmkend AAAAAAAAED}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Konstruktor. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialisiert die Input Daten mit Null {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameter\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i int} \cell }{Window Konstruktor der Klasse mit Fenster @seeCMeanFilter(); \cell }
{\row }
}
}{
Definiert in Zeile {\b 16} der Datei {\b MeanFilter.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00017 \{\par
00018     windowSize = Window;    {\cf20 // initialisieren der Fenstergr\'F6\'DFe mit \'DCbergabewert}\par
00019 \}\par
}
{
\ql
Benutzt {\b windowSize}.}\par
}
{\xe \v ~CMeanFilter\:CMeanFilter}
{\xe \v CMeanFilter\:~CMeanFilter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CMeanFilter::~CMeanFilter ()}}
\par
{\bkmkstart AAAAAAAAEE}
{\bkmkend AAAAAAAAEE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dekonstruktor. }}\par
{
Definiert in Zeile {\b 21} der Datei {\b MeanFilter.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00022 \{\par
00023 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Dokumentation der Elementfunktionen\par
\pard\plain 
{\xe \v calculateMean\:CMeanFilter}
{\xe \v CMeanFilter\:calculateMean}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
list< {\b CInputPoint3D} > CMeanFilter::calculateMean (list< {\b CInputPoint3D} > &  {\i segment})}}
\par
{\bkmkstart AAAAAAAAEF}
{\bkmkend AAAAAAAAEF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Berechnet gleitenden Mittelwert. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Hier wird der Mittelwert der einzelnen Segmente berechnet {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameter\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i list<CInputPoint3D>&} \cell }{segment bekommt einzelne Segmente \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
R\'FCckgabe\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
: list<CInputPoint3D> gibt gel\'E4ttete Segmente zur\'FCck \par
}}}{
Definiert in Zeile {\b 52} der Datei {\b MeanFilter.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00053 \{\par
00054     {\cf18 double} sumX = 0, sumY = 0, sumZ = 0;    {\cf20 // Variablen zum Speichern der Summe}\par
00055     {\cf18 double} div = 0;                         {\cf20 // Variable zum Speichern des Teilers}\par
00056 \par
00057     CInputPoint3D p;        {\cf20 //Point3D zum Zwischenspeichern}\par
00058 \par
00059     {\cf18 size_t} inputSize = segment.size();\par
00060 \par
00061     list<CInputPoint3D>::iterator it = segment.begin();\par
00062     list<CInputPoint3D> newSegment;\par
00063 \par
00064     {\cf19 for} ({\cf18 size_t} i = 0; i < inputSize - windowSize; ++i) {\cf20 //For each element in the Segment}\par
00065     \{\par
00066         sumX = 0, sumY = 0, sumZ = 0;   {\cf20 // Variablen zum Speichern der Summe auf 0 zur\'FCck setzen}\par
00067         div = 0;                        {\cf20 // Variable zum Speichern des Teilers auf 0 zur\'FCck setzen}\par
00068         p.setTime(it->getTime());\par
00069         p.setEulerMatrix(it->getEulerMatrix());\par
00070         {\cf19 for} ({\cf18 size_t} j = i; j < i + windowSize; ++j) {\cf20 // Build the sums for the three points}\par
00071         \{\par
00072             sumX += it->getX();\par
00073             sumY += it->getY();\par
00074             sumZ += it->getZ();\par
00075             div++;\par
00076             it++;\par
00077         \}\par
00078         {\cf19 for} ({\cf18 size_t} index = windowSize; index > 0; index--) {\cf20 // Pain, the iterator has to be set back}\par
00079         \{\par
00080             it--;\par
00081         \}\par
00082         p.set(sumX / div, sumY / div, sumZ / div); {\cf20 // Calculate smoothed values}\par
00083         {\cf19 if}(it != segment.end())\par
00084             it++;\par
00085         newSegment.push_back(p);\par
00086     \}\par
00087     {\cf19 return} newSegment;\par
00088 \}\par
}
{
\ql
Benutzt {\b CPoint3D::set()}, {\b CInputPoint3D::setEulerMatrix()}, {\b CInputPoint3D::setTime()} und {\b windowSize}.}\par
{
\ql
Wird benutzt von {\b mean()}.}\par
}
{\xe \v getPath\:CMeanFilter}
{\xe \v CMeanFilter\:getPath}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
vector< list< {\b CInputPoint3D} > > & CMeanFilter::getPath ()}}
\par
{\bkmkstart AAAAAAAAEG}
{\bkmkend AAAAAAAAEG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gibt den gegl\'E4tteten Pfad zur\'FCck. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
R\'FCckgabe\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
: vector<list<CInputPoint3D>> \par
}}}{
Definiert in Zeile {\b 35} der Datei {\b MeanFilter.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00036 \{\par
00037     {\cf19 return} meanPath;        {\cf20 // Mittelwert zur\'FCck geben}\par
00038 \}\par
}
{
\ql
Benutzt {\b meanPath}.}\par
{
\ql
Wird benutzt von {\b main()}.}\par
}
{\xe \v getWindowSize\:CMeanFilter}
{\xe \v CMeanFilter\:getWindowSize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CMeanFilter::getWindowSize ()}}
\par
{\bkmkstart AAAAAAAAEH}
{\bkmkend AAAAAAAAEH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gibt das gesetzte Fenster zur\'FCck. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
R\'FCckgabe\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
: Window int \par
}}}{
Definiert in Zeile {\b 30} der Datei {\b MeanFilter.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00031 \{\par
00032     {\cf19 return} windowSize;      {\cf20 // Fenstergr\'F6\'DFe zur\'FCck geben}\par
00033 \}\par
}
{
\ql
Benutzt {\b windowSize}.}\par
}
{\xe \v mean\:CMeanFilter}
{\xe \v CMeanFilter\:mean}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CMeanFilter::mean (vector< list< {\b CInputPoint3D} > > &  {\i sourcePath}, {\b CLogging}  {\i log})}}
\par
{\bkmkstart AAAAAAAAEI}
{\bkmkend AAAAAAAAEI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Ruft calculateMean f\'FCr die einzelnen Segmente auf. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Hier wird durch die Segmente interiert und f\'FCr jedes die calculate Mean Funktion aufgerufen. Anschliessend werden sie in meanPath abgespeichert. {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameter\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i list<CInputPoint3D>&} \cell }{segment bekommt einzelne Segmente \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i {\b CLogging}} \cell }{log f\'FCr das Logging \cell }
{\row }
}
}{
Definiert in Zeile {\b 40} der Datei {\b MeanFilter.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00041 \{\par
00042     list<CInputPoint3D> dummyList;\par
00043     {\cf19 for} ({\cf18 size_t} s = 0; s < sourcePath.size(); s++)\par
00044     \{\par
00045         dummyList = calculateMean(sourcePath[s]);\par
00046         meanPath.push_back(dummyList);\par
00047     \}\par
00048     log.setStep(2);\par
00049     log.logData(meanPath);\par
00050 \}\par
}
{
\ql
Benutzt {\b calculateMean()}, {\b CLogging::logData()}, {\b meanPath} und {\b CLogging::setStep()}.}\par
{
\ql
Wird benutzt von {\b main()}.}\par
}
{\xe \v setWindowSize\:CMeanFilter}
{\xe \v CMeanFilter\:setWindowSize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CMeanFilter::setWindowSize (int  {\i Window})}}
\par
{\bkmkstart AAAAAAAAEJ}
{\bkmkend AAAAAAAAEJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Setzt das Fenster. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameter\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i Window} \cell }{int \cell }
{\row }
}
}{
Definiert in Zeile {\b 25} der Datei {\b MeanFilter.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00026 \{\par
00027     windowSize = Window;    {\cf20 // setzen der Fenstergr\'F6\'DFe mit \'DCbergabewert}\par
00028 \}\par
}
{
\ql
Benutzt {\b windowSize}.}\par
{
\ql
Wird benutzt von {\b main()}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Dokumentation der Datenelemente\par
\pard\plain 
{\xe \v meanPath\:CMeanFilter}
{\xe \v CMeanFilter\:meanPath}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
vector<list<{\b CInputPoint3D}> > CMeanFilter::meanPath{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAEK}
{\bkmkend AAAAAAAAEK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Hier werden die gegl\'E4tteten Daten gespeichert \par
}{
Definiert in Zeile {\b 83} der Datei {\b MeanFilter.h}.}\par
{
\ql
Wird benutzt von {\b getPath()} und {\b mean()}.}\par
}
{\xe \v windowSize\:CMeanFilter}
{\xe \v CMeanFilter\:windowSize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CMeanFilter::windowSize{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAEL}
{\bkmkend AAAAAAAAEL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gr\'F6sse des Fensters des gleitenden Mittelwerts \par
}{
Definiert in Zeile {\b 79} der Datei {\b MeanFilter.h}.}\par
{
\ql
Wird benutzt von {\b calculateMean()}, {\b CMeanFilter()}, {\b CMeanFilter()}, {\b getWindowSize()} und {\b setWindowSize()}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
Die Dokumentation f\'FCr diese Klasse wurde erzeugt aufgrund der Dateien:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
header/{\b MeanFilter.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
src/{\b MeanFilter.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
COutputPoint3D Klassenreferenz\par \pard\plain 
{\tc\tcl2 \v COutputPoint3D}
{\xe \v COutputPoint3D}
{\bkmkstart AAAAAAAAEM}
{\bkmkend AAAAAAAAEM}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Output Punkt. }}\par
{
{\f2 #include <Point3D.h>}}\par
Klassendiagramm f\'FCr COutputPoint3D:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c_output_point3_d.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'D6ffentliche Methoden\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b COutputPoint3D} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Default Konstruktor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b COutputPoint3D} (double Speed, double X, double Y, double Z, double A, double B, double C)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Default Konstruktor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~COutputPoint3D} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dekonstruktor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b getSpeed} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gibt die Geschwindigkeit zur\'FCck. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b getA} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gibt A zur\'FCck. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b getB} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gibt B zur\'FCck. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b getC} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gibt C zur\'FCck. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setSpeed} (double {\b speed})\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Setzt die Geschwindigkeit. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setA} (double A)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Setzt A. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setB} (double B)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Setzt B. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setC} (double C)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Setzt C. }{
}\par
}\par}
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
\'D6ffentliche Methoden geerbt von {\b CPoint3D}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CPoint3D} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Default Konstruktor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CPoint3D} (double X, double Y, double Z)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Default Konstruktor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~CPoint3D} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dekonstruktor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b getX} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gibt X zur\'FCck. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b getY} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gibt Y zur\'FCck. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b getZ} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gibt Z zur\'FCck. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setX} (double X)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Setzt X. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setY} (double Y)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Setzt Y. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setZ} (double Z)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Setzt Z. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b set} (double X, double Y, double Z)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Setzt X, Y und Z. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b distanceTo} ({\b CPoint3D} point)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Berechnet die Distanz zu einem anderen Punkt. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b distanceTo} ({\b CLine3D} line)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Berechnet die Distanz zu einer Linie. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Attribute\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b a}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b b}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b c}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b speed}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Weitere Geerbte Elemente\par
\pard\plain 
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Gesch\'FCtzte Attribute geerbt von {\b CPoint3D}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b x}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b y}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b z}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Ausf\'FChrliche Beschreibung\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Output Punkt. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Kind der Punkt Grundklasse, erweitert um die Geschwindigkeit und die Drehwinkel \par
}{
Definiert in Zeile {\b 177} der Datei {\b Point3D.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Beschreibung der Konstruktoren und Destruktoren\par
\pard\plain 
{\xe \v COutputPoint3D\:COutputPoint3D}
{\xe \v COutputPoint3D\:COutputPoint3D}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
COutputPoint3D::COutputPoint3D (void )}}
\par
{\bkmkstart AAAAAAAAEN}
{\bkmkend AAAAAAAAEN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Default Konstruktor. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialisiert des fertig bearbeiteten Punktes mit Null \par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Siehe auch\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\b COutputPoint3D(double Speed, double X, double Y, double Z, double A, double B, double C)}; \par
}}}{
Definiert in Zeile {\b 159} der Datei {\b Point3D.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00159                                    : CPoint3D()\par
00160 \{\par
00161     speed = 0;\par
00162     a = 0;\par
00163     b = 0;\par
00164     c = 0;\par
00165 \}\par
}
{
\ql
Benutzt {\b a}, {\b b}, {\b c} und {\b speed}.}\par
}
{\xe \v COutputPoint3D\:COutputPoint3D}
{\xe \v COutputPoint3D\:COutputPoint3D}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
COutputPoint3D::COutputPoint3D (double  {\i Speed}, double  {\i X}, double  {\i Y}, double  {\i Z}, double  {\i A}, double  {\i B}, double  {\i C})}}
\par
{\bkmkstart AAAAAAAAEO}
{\bkmkend AAAAAAAAEO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Default Konstruktor. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialisiert des eingelesenen Punktes mit Null {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameter\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i double} \cell }{Speed \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i double} \cell }{X \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i double} \cell }{Y \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i double} \cell }{Z \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i double} \cell }{A \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i double} \cell }{B \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i double} \cell }{C \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Siehe auch\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\b CInputPoint3D(double X, double Y, double Z, double Timestamp, CEulerMatrix Matrix)} \par
}}}{
Definiert in Zeile {\b 168} der Datei {\b Point3D.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00169 \{\par
00170     speed = Speed;\par
00171     a = A;\par
00172     b = B;\par
00173     c = C;\par
00174     x = X;\par
00175     y = Y;\par
00176     z = Z;\par
00177 \}\par
}
{
\ql
Benutzt {\b a}, {\b b}, {\b c}, {\b speed}, {\b CPoint3D::x}, {\b CPoint3D::y} und {\b CPoint3D::z}.}\par
}
{\xe \v ~COutputPoint3D\:COutputPoint3D}
{\xe \v COutputPoint3D\:~COutputPoint3D}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
COutputPoint3D::~COutputPoint3D (void )}}
\par
{\bkmkstart AAAAAAAAEP}
{\bkmkend AAAAAAAAEP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dekonstruktor. }}\par
{
Definiert in Zeile {\b 179} der Datei {\b Point3D.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00180 \{\par
00181 \par
00182 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Dokumentation der Elementfunktionen\par
\pard\plain 
{\xe \v getA\:COutputPoint3D}
{\xe \v COutputPoint3D\:getA}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double COutputPoint3D::getA (void )}}
\par
{\bkmkstart AAAAAAAAEQ}
{\bkmkend AAAAAAAAEQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gibt A zur\'FCck. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
R\'FCckgabe\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
: double A \par
}}}{
Definiert in Zeile {\b 184} der Datei {\b Point3D.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00185 \{\par
00186     {\cf19 return} a;   {\cf20 // R\'FCckgabe Winkel alpha}\par
00187 \}\par
}
{
\ql
Benutzt {\b a}.}\par
}
{\xe \v getB\:COutputPoint3D}
{\xe \v COutputPoint3D\:getB}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double COutputPoint3D::getB (void )}}
\par
{\bkmkstart AAAAAAAAER}
{\bkmkend AAAAAAAAER}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gibt B zur\'FCck. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
R\'FCckgabe\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
: double B \par
}}}{
Definiert in Zeile {\b 189} der Datei {\b Point3D.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00190 \{\par
00191     {\cf19 return} b;   {\cf20 // R\'FCckgabe Winkel beta}\par
00192 \}\par
}
{
\ql
Benutzt {\b b}.}\par
}
{\xe \v getC\:COutputPoint3D}
{\xe \v COutputPoint3D\:getC}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double COutputPoint3D::getC (void )}}
\par
{\bkmkstart AAAAAAAAES}
{\bkmkend AAAAAAAAES}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gibt C zur\'FCck. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
R\'FCckgabe\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
: double C \par
}}}{
Definiert in Zeile {\b 194} der Datei {\b Point3D.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00195 \{\par
00196     {\cf19 return} c;   {\cf20 // R\'FCckgabe Winkel gamma}\par
00197 \}\par
}
{
\ql
Benutzt {\b c}.}\par
}
{\xe \v getSpeed\:COutputPoint3D}
{\xe \v COutputPoint3D\:getSpeed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double COutputPoint3D::getSpeed (void )}}
\par
{\bkmkstart AAAAAAAAET}
{\bkmkend AAAAAAAAET}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gibt die Geschwindigkeit zur\'FCck. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
R\'FCckgabe\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
: double Geschwindigkeit \par
}}}{
Definiert in Zeile {\b 199} der Datei {\b Point3D.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00200 \{\par
00201     {\cf19 return} speed;   {\cf20 // R\'FCckgabe Geschwindigkeit}\par
00202 \}\par
}
{
\ql
Benutzt {\b speed}.}\par
}
{\xe \v setA\:COutputPoint3D}
{\xe \v COutputPoint3D\:setA}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void COutputPoint3D::setA (double  {\i A})}}
\par
{\bkmkstart AAAAAAAAEU}
{\bkmkend AAAAAAAAEU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Setzt A. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameter\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i double} \cell }{A \cell }
{\row }
}
}{
Definiert in Zeile {\b 204} der Datei {\b Point3D.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00205 \{\par
00206     a = A;      {\cf20 // setze Winkel alpha}\par
00207 \}\par
}
{
\ql
Benutzt {\b a}.}\par
{
\ql
Wird benutzt von {\b CRobCodeGenerator::calculateAngles()} und {\b CRobCodeGenerator::postProcessing()}.}\par
}
{\xe \v setB\:COutputPoint3D}
{\xe \v COutputPoint3D\:setB}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void COutputPoint3D::setB (double  {\i B})}}
\par
{\bkmkstart AAAAAAAAEV}
{\bkmkend AAAAAAAAEV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Setzt B. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameter\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i double} \cell }{B \cell }
{\row }
}
}{
Definiert in Zeile {\b 209} der Datei {\b Point3D.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00210 \{\par
00211     b = B;      {\cf20 // setze Winkel beta}\par
00212 \}\par
}
{
\ql
Benutzt {\b b}.}\par
{
\ql
Wird benutzt von {\b CRobCodeGenerator::calculateAngles()} und {\b CRobCodeGenerator::postProcessing()}.}\par
}
{\xe \v setC\:COutputPoint3D}
{\xe \v COutputPoint3D\:setC}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void COutputPoint3D::setC (double  {\i C})}}
\par
{\bkmkstart AAAAAAAAEW}
{\bkmkend AAAAAAAAEW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Setzt C. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameter\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i double} \cell }{C \cell }
{\row }
}
}{
Definiert in Zeile {\b 214} der Datei {\b Point3D.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00215 \{\par
00216     c = C;      {\cf20 // setze Winkel gamma}\par
00217 \}\par
}
{
\ql
Benutzt {\b c}.}\par
{
\ql
Wird benutzt von {\b CRobCodeGenerator::calculateAngles()} und {\b CRobCodeGenerator::postProcessing()}.}\par
}
{\xe \v setSpeed\:COutputPoint3D}
{\xe \v COutputPoint3D\:setSpeed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void COutputPoint3D::setSpeed (double  {\i speed})}}
\par
{\bkmkstart AAAAAAAAEX}
{\bkmkend AAAAAAAAEX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Setzt die Geschwindigkeit. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameter\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i double} \cell }{speed \cell }
{\row }
}
}{
Definiert in Zeile {\b 219} der Datei {\b Point3D.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00220 \{\par
00221     speed = Speed;      {\cf20 // setze Geschwindigkeit}\par
00222 \}\par
}
{
\ql
Benutzt {\b speed}.}\par
{
\ql
Wird benutzt von {\b CRobCodeGenerator::postProcessing()}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Dokumentation der Datenelemente\par
\pard\plain 
{\xe \v a\:COutputPoint3D}
{\xe \v COutputPoint3D\:a}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double COutputPoint3D::a{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAEY}
{\bkmkend AAAAAAAAEY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Drehwinkel des Punktes \par
}{
Definiert in Zeile {\b 249} der Datei {\b Point3D.h}.}\par
{
\ql
Wird benutzt von {\b COutputPoint3D()}, {\b COutputPoint3D()}, {\b getA()} und {\b setA()}.}\par
}
{\xe \v b\:COutputPoint3D}
{\xe \v COutputPoint3D\:b}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double COutputPoint3D::b{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAEZ}
{\bkmkend AAAAAAAAEZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definiert in Zeile {\b 249} der Datei {\b Point3D.h}.}\par
{
\ql
Wird benutzt von {\b COutputPoint3D()}, {\b COutputPoint3D()}, {\b getB()} und {\b setB()}.}\par
}
{\xe \v c\:COutputPoint3D}
{\xe \v COutputPoint3D\:c}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double COutputPoint3D::c{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAFA}
{\bkmkend AAAAAAAAFA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definiert in Zeile {\b 249} der Datei {\b Point3D.h}.}\par
{
\ql
Wird benutzt von {\b COutputPoint3D()}, {\b COutputPoint3D()}, {\b getC()} und {\b setC()}.}\par
}
{\xe \v speed\:COutputPoint3D}
{\xe \v COutputPoint3D\:speed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double COutputPoint3D::speed{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAFB}
{\bkmkend AAAAAAAAFB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Geschwindigkeit zum Punkt hin? TODO: \'FCberpr\'FCfen \par
}{
Definiert in Zeile {\b 253} der Datei {\b Point3D.h}.}\par
{
\ql
Wird benutzt von {\b COutputPoint3D()}, {\b COutputPoint3D()}, {\b getSpeed()} und {\b setSpeed()}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
Die Dokumentation f\'FCr diese Klasse wurde erzeugt aufgrund der Dateien:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
header/{\b Point3D.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
src/{\b Point3D.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CPathBuilder Klassenreferenz\par \pard\plain 
{\tc\tcl2 \v CPathBuilder}
{\xe \v CPathBuilder}
{\bkmkstart AAAAAAAAFC}
{\bkmkend AAAAAAAAFC}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Zusammensetzten des Pfades. }}\par
{
{\f2 #include <PathBuilder.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'D6ffentliche Methoden\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CPathBuilder} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Default Konstruktor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~CPathBuilder} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dekonstruktor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
vector< {\b CInputPoint3D} > & {\b getPath} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gibt Pfad zur\'FCck. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b createPath} (vector< list< {\b CInputPoint3D} > > &segments, {\b CLogging} log)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gibt Pfad zur\'FCck. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Attribute\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
vector< {\b CInputPoint3D} > {\b path}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Ausf\'FChrliche Beschreibung\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Zusammensetzten des Pfades. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
In dieser Klasse wird aus den Segmenten ein zusammenh\'E4ngender Pfad erstellt \par
}{
Definiert in Zeile {\b 21} der Datei {\b PathBuilder.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Beschreibung der Konstruktoren und Destruktoren\par
\pard\plain 
{\xe \v CPathBuilder\:CPathBuilder}
{\xe \v CPathBuilder\:CPathBuilder}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CPathBuilder::CPathBuilder (void )}}
\par
{\bkmkstart AAAAAAAAFD}
{\bkmkend AAAAAAAAFD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Default Konstruktor. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialisiert der Klasse \par
}{
Definiert in Zeile {\b 9} der Datei {\b PathBuilder.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00010 \{\par
00011 \}\par
}
}
{\xe \v ~CPathBuilder\:CPathBuilder}
{\xe \v CPathBuilder\:~CPathBuilder}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CPathBuilder::~CPathBuilder (void )}}
\par
{\bkmkstart AAAAAAAAFE}
{\bkmkend AAAAAAAAFE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dekonstruktor. }}\par
{
Definiert in Zeile {\b 14} der Datei {\b PathBuilder.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00015 \{\par
00016 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Dokumentation der Elementfunktionen\par
\pard\plain 
{\xe \v createPath\:CPathBuilder}
{\xe \v CPathBuilder\:createPath}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CPathBuilder::createPath (vector< list< {\b CInputPoint3D} > > &  {\i segments}, {\b CLogging}  {\i log})}}
\par
{\bkmkstart AAAAAAAAFF}
{\bkmkend AAAAAAAAFF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gibt Pfad zur\'FCck. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameter\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i segments} \cell }{vector<list<CInputPoint3D>>& Pfad aus Segmenten \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i {\b CLogging}} \cell }{log f\'FCr das Logging \cell }
{\row }
}
}{
Definiert in Zeile {\b 23} der Datei {\b PathBuilder.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00024 \{\par
00025     CInputPoint3D point; {\cf20 //startpoint}\par
00026 \par
00027     {\cf19 for} ({\cf18 size_t} s = 0; s < segments.size(); s++) {\cf20 //for all segments}\par
00028     \{\par
00029         list<CInputPoint3D>::iterator itr = segments[s].begin();\par
00030 \par
00031         {\cf19 for} (; itr != segments[s].end(); itr++) {\cf20 //for all points in the segment}\par
00032         \{\par
00033             point.set(({\cf18 double})itr->getX(), ({\cf18 double})itr->getY(), ({\cf18 double})itr->getZ());\par
00034             point.setTime(itr->getTime());\par
00035             point.setEulerMatrix(itr->getEulerMatrix());\par
00036             path.push_back(point);\par
00037         \}\par
00038 \par
00039         itr--;\par
00040     \}\par
00041 \par
00042     log.setStep(4);\par
00043     log.logData(path);\par
00044 \}\par
}
{
\ql
Benutzt {\b CLogging::logData()}, {\b path}, {\b CPoint3D::set()}, {\b CInputPoint3D::setEulerMatrix()}, {\b CLogging::setStep()} und {\b CInputPoint3D::setTime()}.}\par
{
\ql
Wird benutzt von {\b main()}.}\par
}
{\xe \v getPath\:CPathBuilder}
{\xe \v CPathBuilder\:getPath}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
vector< {\b CInputPoint3D} > & CPathBuilder::getPath ()}}
\par
{\bkmkstart AAAAAAAAFG}
{\bkmkend AAAAAAAAFG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gibt Pfad zur\'FCck. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
R\'FCckgabe\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
: vector<CInputPoint3D> zusammengesetzter Pfad \par
}}}{
Definiert in Zeile {\b 18} der Datei {\b PathBuilder.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00019 \{\par
00020     {\cf19 return} path;\par
00021 \}\par
}
{
\ql
Benutzt {\b path}.}\par
{
\ql
Wird benutzt von {\b main()}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Dokumentation der Datenelemente\par
\pard\plain 
{\xe \v path\:CPathBuilder}
{\xe \v CPathBuilder\:path}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
vector<{\b CInputPoint3D}> CPathBuilder::path{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAFH}
{\bkmkend AAAAAAAAFH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Vector mit den zusammengesetzten Pfad Daten \par
}{
Definiert in Zeile {\b 50} der Datei {\b PathBuilder.h}.}\par
{
\ql
Wird benutzt von {\b createPath()} und {\b getPath()}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
Die Dokumentation f\'FCr diese Klasse wurde erzeugt aufgrund der Dateien:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
header/{\b PathBuilder.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
src/{\b PathBuilder.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CPoint3D Klassenreferenz\par \pard\plain 
{\tc\tcl2 \v CPoint3D}
{\xe \v CPoint3D}
{\bkmkstart AAAAAAAAFI}
{\bkmkend AAAAAAAAFI}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Grundklasse Punkt. }}\par
{
{\f2 #include <Point3D.h>}}\par
Klassendiagramm f\'FCr CPoint3D:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c_point3_d.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'D6ffentliche Methoden\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CPoint3D} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Default Konstruktor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CPoint3D} (double X, double Y, double Z)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Default Konstruktor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~CPoint3D} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dekonstruktor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b getX} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gibt X zur\'FCck. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b getY} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gibt Y zur\'FCck. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b getZ} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gibt Z zur\'FCck. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setX} (double X)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Setzt X. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setY} (double Y)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Setzt Y. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setZ} (double Z)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Setzt Z. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b set} (double X, double Y, double Z)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Setzt X, Y und Z. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b distanceTo} ({\b CPoint3D} point)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Berechnet die Distanz zu einem anderen Punkt. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b distanceTo} ({\b CLine3D} line)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Berechnet die Distanz zu einer Linie. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Gesch\'FCtzte Attribute\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b x}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b y}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b z}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Ausf\'FChrliche Beschreibung\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Grundklasse Punkt. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Das ist die Grundklasse eines Punktes, hier lassen sich die Basiswerte setzten und Abst\'E4nde zwishen Punkten berechnen. \par
}{
Definiert in Zeile {\b 20} der Datei {\b Point3D.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Beschreibung der Konstruktoren und Destruktoren\par
\pard\plain 
{\xe \v CPoint3D\:CPoint3D}
{\xe \v CPoint3D\:CPoint3D}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CPoint3D::CPoint3D (void )}}
\par
{\bkmkstart AAAAAAAAFJ}
{\bkmkend AAAAAAAAFJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Default Konstruktor. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialisiert des Punktes mit Null \par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Siehe auch\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\b CPoint3D(double X, double Y, double Z)} \par
}}}{
Definiert in Zeile {\b 13} der Datei {\b Point3D.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00014 \{\par
00015     x = 0;\par
00016     y = 0;\par
00017     z = 0;\par
00018 \}\par
}
{
\ql
Benutzt {\b x}, {\b y} und {\b z}.}\par
}
{\xe \v CPoint3D\:CPoint3D}
{\xe \v CPoint3D\:CPoint3D}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CPoint3D::CPoint3D (double  {\i X}, double  {\i Y}, double  {\i Z})}}
\par
{\bkmkstart AAAAAAAAFK}
{\bkmkend AAAAAAAAFK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Default Konstruktor. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialisiert des Punktes mit Null {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameter\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i double} \cell }{X \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i double} \cell }{Y \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i double} \cell }{Z \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Siehe auch\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\b CPoint3D(void)} \par
}}}{
Definiert in Zeile {\b 21} der Datei {\b Point3D.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00022 \{\par
00023     x = X;\par
00024     y = Y;\par
00025     z = Z;\par
00026 \}\par
}
{
\ql
Benutzt {\b x}, {\b y} und {\b z}.}\par
}
{\xe \v ~CPoint3D\:CPoint3D}
{\xe \v CPoint3D\:~CPoint3D}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CPoint3D::~CPoint3D (void )}}
\par
{\bkmkstart AAAAAAAAFL}
{\bkmkend AAAAAAAAFL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dekonstruktor. }}\par
{
Definiert in Zeile {\b 28} der Datei {\b Point3D.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00029 \{\par
00030 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Dokumentation der Elementfunktionen\par
\pard\plain 
{\xe \v distanceTo\:CPoint3D}
{\xe \v CPoint3D\:distanceTo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double CPoint3D::distanceTo ({\b CLine3D}  {\i line})}}
\par
{\bkmkstart AAAAAAAAFM}
{\bkmkend AAAAAAAAFM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Berechnet die Distanz zu einer Linie. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameter\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i {\b CLine3D}} \cell }{line \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
R\'FCckgabe\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
double Distanz \par
}}}{
Definiert in Zeile {\b 76} der Datei {\b Point3D.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00077 \{\par
00078     {\cf18 double} bx, by, bz, rv_sq, dist, vp1, vp2, vp3;          {\cf20 // Variablen Anlegen}\par
00079 \par
00080     {\cf20 /*}\par
00081 {\cf20     Vermessen wird der Punkt selbst}\par
00082 {\cf20 }\par
00083 {\cf20     bx, by, bz      == Vektordifferenz}\par
00084 {\cf20     rv_sq           == Betrag des Linienvektors}\par
00085 {\cf20     dist            == Distanz von Punkt zu Linie}\par
00086 {\cf20     vp1, vp2, vp3   == Vektorprodukte}\par
00087 {\cf20     */}\par
00088 \par
00089     {\cf18 int} rvx = line.p1.x - line.p2.x;        {\cf20 // Parameter X des Linienvektor berechnen}\par
00090     {\cf18 int} rvy = line.p1.y - line.p2.y;        {\cf20 // Parameter Y des Linienvektor berechnen}\par
00091     {\cf18 int} rvz = line.p1.z - line.p2.z;        {\cf20 // Parameter Z des Linienvektor berechnen}\par
00092 \par
00093     rv_sq = sqrt((({\cf18 double})rvx * ({\cf18 double})rvx) + (({\cf18 double})rvy * ({\cf18 double})rvy) + (({\cf18 double})rvz * ({\cf18 double})rvz));      {\cf20 // Betrag des Linienvektor berechnen}\par
00094 \par
00095     bx = x - (double)line.p1.x;             {\cf20 // X(Punkt) - X(Aufpunkt) }\par
00096     by = y - (double)line.p1.y;             {\cf20 // Y(Punkt) - Y(Aufpunkt)}\par
00097     bz = z - (double)line.p1.z;             {\cf20 // Z(Punkt) - Z(Aufpunkt)}\par
00098 \par
00099     vp1 = by * rvz - bz * rvy;              {\cf20 // Parameter X Vektorprodukt}\par
00100     vp2 = bz * rvx - bx * rvz;              {\cf20 // Parameter Y Vektorprodukt}\par
00101     vp3 = bx * rvy - by * rvx;              {\cf20 // Parameter Z Vektorprodukt}\par
00102 \par
00103     dist = sqrt(vp1 * vp1 + vp2 * vp2 + vp3 * vp3) / rv_sq; {\cf20 // Betrag des Vektors berechnen}\par
00104 \par
00105     {\cf19 return} dist;\par
00106 \}\par
}
{
\ql
Benutzt {\b CLine3D::p1}, {\b CLine3D::p2}, {\b x}, {\b y} und {\b z}.}\par
}
{\xe \v distanceTo\:CPoint3D}
{\xe \v CPoint3D\:distanceTo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double CPoint3D::distanceTo ({\b CPoint3D}  {\i point})}}
\par
{\bkmkstart AAAAAAAAFN}
{\bkmkend AAAAAAAAFN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Berechnet die Distanz zu einem anderen Punkt. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameter\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i {\b CPoint3D}} \cell }{point \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
R\'FCckgabe\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
double Distanz \par
}}}{
Definiert in Zeile {\b 71} der Datei {\b Point3D.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00072 \{\par
00073     {\cf19 return} sqrt(pow(({\cf18 double})(x - ({\cf18 double})point.getX()), 2) + pow(({\cf18 double})(y - ({\cf18 double})point.getY()), 2) + pow(({\cf18 double})(z - ({\cf18 double})point.getZ()), 2));  {\cf20 //  Pythagoras 3D}\par
00074 \}\par
}
{
\ql
Benutzt {\b getX()}, {\b getY()}, {\b getZ()}, {\b x}, {\b y} und {\b z}.}\par
}
{\xe \v getX\:CPoint3D}
{\xe \v CPoint3D\:getX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double CPoint3D::getX (void )}}
\par
{\bkmkstart AAAAAAAAFO}
{\bkmkend AAAAAAAAFO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gibt X zur\'FCck. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
R\'FCckgabe\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
double \par
}}}{
Definiert in Zeile {\b 32} der Datei {\b Point3D.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00033 \{\par
00034     {\cf19 return} x;   {\cf20 // X-Koordinate zur\'FCck geben}\par
00035 \}\par
}
{
\ql
Benutzt {\b x}.}\par
{
\ql
Wird benutzt von {\b CInputParameter::detectJump()} und {\b distanceTo()}.}\par
}
{\xe \v getY\:CPoint3D}
{\xe \v CPoint3D\:getY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double CPoint3D::getY (void )}}
\par
{\bkmkstart AAAAAAAAFP}
{\bkmkend AAAAAAAAFP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gibt Y zur\'FCck. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
R\'FCckgabe\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
double \par
}}}{
Definiert in Zeile {\b 37} der Datei {\b Point3D.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00038 \{\par
00039     {\cf19 return} y;   {\cf20 // Y-Koordinate zur\'FCck geben}\par
00040 \}\par
}
{
\ql
Benutzt {\b y}.}\par
{
\ql
Wird benutzt von {\b CInputParameter::detectJump()} und {\b distanceTo()}.}\par
}
{\xe \v getZ\:CPoint3D}
{\xe \v CPoint3D\:getZ}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double CPoint3D::getZ (void )}}
\par
{\bkmkstart AAAAAAAAFQ}
{\bkmkend AAAAAAAAFQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gibt Z zur\'FCck. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
R\'FCckgabe\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
double \par
}}}{
Definiert in Zeile {\b 42} der Datei {\b Point3D.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00043 \{\par
00044     {\cf19 return} z;   {\cf20 // Z-Koordinate zur\'FCck geben}\par
00045 \}\par
}
{
\ql
Benutzt {\b z}.}\par
{
\ql
Wird benutzt von {\b CInputParameter::detectJump()} und {\b distanceTo()}.}\par
}
{\xe \v set\:CPoint3D}
{\xe \v CPoint3D\:set}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CPoint3D::set (double  {\i X}, double  {\i Y}, double  {\i Z})}}
\par
{\bkmkstart AAAAAAAAFR}
{\bkmkend AAAAAAAAFR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Setzt X, Y und Z. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameter\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i double} \cell }{X \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i double} \cell }{Y \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i double} \cell }{Z \cell }
{\row }
}
}{
Definiert in Zeile {\b 63} der Datei {\b Point3D.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00064 \{\par
00065     x = X;  {\cf20 // X-Koordinate setzen}\par
00066     y = Y;  {\cf20 // Y-Koordinate setzen}\par
00067     z = Z;  {\cf20 // Z-Koordinate setzen}\par
00068 \}   \par
}
{
\ql
Benutzt {\b x}, {\b y} und {\b z}.}\par
{
\ql
Wird benutzt von {\b CMeanFilter::calculateMean()}, {\b CPathBuilder::createPath()}, {\b CRobCodeGenerator::postProcessing()} und {\b CInputPoint3D::setPoint()}.}\par
}
{\xe \v setX\:CPoint3D}
{\xe \v CPoint3D\:setX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CPoint3D::setX (double  {\i X})}}
\par
{\bkmkstart AAAAAAAAFS}
{\bkmkend AAAAAAAAFS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Setzt X. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameter\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i double} \cell }{X \cell }
{\row }
}
}{
Definiert in Zeile {\b 47} der Datei {\b Point3D.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00048 \{\par
00049     x = X;  {\cf20 // X-Koordinate setzen}\par
00050 \}\par
}
{
\ql
Benutzt {\b x}.}\par
{
\ql
Wird benutzt von {\b CSegmentApproximator::douglasPeuckerRecursive()}.}\par
}
{\xe \v setY\:CPoint3D}
{\xe \v CPoint3D\:setY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CPoint3D::setY (double  {\i Y})}}
\par
{\bkmkstart AAAAAAAAFT}
{\bkmkend AAAAAAAAFT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Setzt Y. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameter\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i double} \cell }{Y \cell }
{\row }
}
}{
Definiert in Zeile {\b 52} der Datei {\b Point3D.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00053 \{\par
00054     y = Y;  {\cf20 // Y-Koordinate setzen}\par
00055 \}\par
}
{
\ql
Benutzt {\b y}.}\par
{
\ql
Wird benutzt von {\b CSegmentApproximator::douglasPeuckerRecursive()}.}\par
}
{\xe \v setZ\:CPoint3D}
{\xe \v CPoint3D\:setZ}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CPoint3D::setZ (double  {\i Z})}}
\par
{\bkmkstart AAAAAAAAFU}
{\bkmkend AAAAAAAAFU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Setzt Z. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameter\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i double} \cell }{Z \cell }
{\row }
}
}{
Definiert in Zeile {\b 57} der Datei {\b Point3D.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00058 \{\par
00059     z = Z;  {\cf20 // Z-Koordinate setzen}\par
00060 \}\par
}
{
\ql
Benutzt {\b z}.}\par
{
\ql
Wird benutzt von {\b CSegmentApproximator::douglasPeuckerRecursive()}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Dokumentation der Datenelemente\par
\pard\plain 
{\xe \v x\:CPoint3D}
{\xe \v CPoint3D\:x}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double CPoint3D::x{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAFV}
{\bkmkend AAAAAAAAFV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Koordinaten des Punkts \par
}{
Definiert in Zeile {\b 99} der Datei {\b Point3D.h}.}\par
{
\ql
Wird benutzt von {\b CInputPoint3D::CInputPoint3D()}, {\b COutputPoint3D::COutputPoint3D()}, {\b CPoint3D()}, {\b CPoint3D()}, {\b distanceTo()}, {\b distanceTo()}, {\b getX()}, {\b set()} und {\b setX()}.}\par
}
{\xe \v y\:CPoint3D}
{\xe \v CPoint3D\:y}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double CPoint3D::y{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAFW}
{\bkmkend AAAAAAAAFW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definiert in Zeile {\b 99} der Datei {\b Point3D.h}.}\par
{
\ql
Wird benutzt von {\b CInputPoint3D::CInputPoint3D()}, {\b COutputPoint3D::COutputPoint3D()}, {\b CPoint3D()}, {\b CPoint3D()}, {\b distanceTo()}, {\b distanceTo()}, {\b getY()}, {\b set()} und {\b setY()}.}\par
}
{\xe \v z\:CPoint3D}
{\xe \v CPoint3D\:z}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double CPoint3D::z{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAFX}
{\bkmkend AAAAAAAAFX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definiert in Zeile {\b 99} der Datei {\b Point3D.h}.}\par
{
\ql
Wird benutzt von {\b CInputPoint3D::CInputPoint3D()}, {\b COutputPoint3D::COutputPoint3D()}, {\b CPoint3D()}, {\b CPoint3D()}, {\b distanceTo()}, {\b distanceTo()}, {\b getZ()}, {\b set()} und {\b setZ()}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
Die Dokumentation f\'FCr diese Klasse wurde erzeugt aufgrund der Dateien:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
header/{\b Point3D.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
src/{\b Point3D.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CRobCodeGenerator Klassenreferenz\par \pard\plain 
{\tc\tcl2 \v CRobCodeGenerator}
{\xe \v CRobCodeGenerator}
{\bkmkstart AAAAAAAAFY}
{\bkmkend AAAAAAAAFY}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Klasse zum erstellen des Roboter Codes. }}\par
{
{\f2 #include <RobCodeGenerator.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'D6ffentliche Methoden\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CRobCodeGenerator} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Default Konstruktor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CRobCodeGenerator} (double speedIn, bool speedManualIn, bool orientationManualIn, tuple< double, double, double > angles)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Konstruktor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~CRobCodeGenerator} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dekonstruktor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b generateRobCode} (vector< {\b CInputPoint3D} > &path, string filepath, string filename)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Erstellt Roboter Code File. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b postProcessing} (vector< {\b CInputPoint3D} > &path)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Nachbearbeitung der Daten. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b calculateSpeed} ({\b CInputPoint3D} &p, size_t i, double timePrev)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Berechnet die Geschwindigkeit zwischen zwei Punkten. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b calculateAngles} ({\b COutputPoint3D} &p, {\b CInputPoint3D} &pIn)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Berechnet die Geschwindigkeit zwischen zwei Punkten. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Attribute\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
vector< {\b COutputPoint3D} > {\b processedPath}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b speed}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b speedManual}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b orientationManual}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b A}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b B}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b C}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Ausf\'FChrliche Beschreibung\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Klasse zum erstellen des Roboter Codes. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
In dieser Klasse wird die Nachbearbeitung der Daten mit den einstellbaren Daten durchgef\'FChrt. \par
}{
Definiert in Zeile {\b 23} der Datei {\b RobCodeGenerator.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Beschreibung der Konstruktoren und Destruktoren\par
\pard\plain 
{\xe \v CRobCodeGenerator\:CRobCodeGenerator}
{\xe \v CRobCodeGenerator\:CRobCodeGenerator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CRobCodeGenerator::CRobCodeGenerator (void )}}
\par
{\bkmkstart AAAAAAAAFZ}
{\bkmkend AAAAAAAAFZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Default Konstruktor. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialisiert der Daten \par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Siehe auch\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\b CRobCodeGenerator(double speedIn, bool speedManualIn, bool orientationManualIn, tuple<double, double, double> angles)} \par
}}}{
Definiert in Zeile {\b 11} der Datei {\b RobCodeGenerator.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00012 \{\par
00013     speed = 0;\par
00014     speedManual = 0;\par
00015     orientationManual = 0;\par
00016     A = 0;\par
00017     B = 0;\par
00018     C = 0;\par
00019 \}\par
}
{
\ql
Benutzt {\b A}, {\b B}, {\b C}, {\b orientationManual}, {\b speed} und {\b speedManual}.}\par
}
{\xe \v CRobCodeGenerator\:CRobCodeGenerator}
{\xe \v CRobCodeGenerator\:CRobCodeGenerator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CRobCodeGenerator::CRobCodeGenerator (double  {\i speedIn}, bool  {\i speedManualIn}, bool  {\i orientationManualIn}, tuple< double, double, double >  {\i angles})}}
\par
{\bkmkstart AAAAAAAAGA}
{\bkmkend AAAAAAAAGA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Konstruktor. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialisiert der Daten {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameter\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i initSpeed} \cell }{double \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i initSpeedManual} \cell }{bool \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i initOrientationManual} \cell }{bool \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i initA} \cell }{double \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i initB} \cell }{double \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i initC} \cell }{double \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Siehe auch\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\b CRobCodeGenerator(void)} \par
}}}{
Definiert in Zeile {\b 22} der Datei {\b RobCodeGenerator.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00023 \{\par
00024     speed = Speed;\par
00025     speedManual = SpeedManual;\par
00026     orientationManual = OrientationManual;\par
00027     A = get<0>(angles);\par
00028     B = get<1>(angles);\par
00029     C = get<2>(angles);\par
00030 \}\par
}
{
\ql
Benutzt {\b A}, {\b B}, {\b C}, {\b orientationManual}, {\b speed} und {\b speedManual}.}\par
}
{\xe \v ~CRobCodeGenerator\:CRobCodeGenerator}
{\xe \v CRobCodeGenerator\:~CRobCodeGenerator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CRobCodeGenerator::~CRobCodeGenerator (void )}}
\par
{\bkmkstart AAAAAAAAGB}
{\bkmkend AAAAAAAAGB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dekonstruktor. }}\par
{
Definiert in Zeile {\b 32} der Datei {\b RobCodeGenerator.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00033 \{\par
00034 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Dokumentation der Elementfunktionen\par
\pard\plain 
{\xe \v calculateAngles\:CRobCodeGenerator}
{\xe \v CRobCodeGenerator\:calculateAngles}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CRobCodeGenerator::calculateAngles ({\b COutputPoint3D} &  {\i p}, {\b CInputPoint3D} &  {\i pIn})}}
\par
{\bkmkstart AAAAAAAAGC}
{\bkmkend AAAAAAAAGC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Berechnet die Geschwindigkeit zwischen zwei Punkten. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameter\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i COutputPoint3D&} \cell }{p \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i CInputPoint3D&} \cell }{pIn \cell }
{\row }
}
}{
Definiert in Zeile {\b 129} der Datei {\b RobCodeGenerator.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00130 \{\par
00131     {\cf20 // Funktion in Eulermatrix aufrufen die a/b/c neu berechnet}\par
00132 \par
00133     CEulerMatrix matrix = pIn.getEulerMatrix();\par
00134     tuple<double, double, double> abc;\par
00135 \par
00136     abc = matrix.calculateAngels();\par
00137 \par
00138     p.setA(get<0>(abc));\par
00139     p.setB(get<1>(abc));\par
00140     p.setC(get<2>(abc));\par
00141 \}\par
}
{
\ql
Benutzt {\b CEulerMatrix::calculateAngels()}, {\b CInputPoint3D::getEulerMatrix()}, {\b COutputPoint3D::setA()}, {\b COutputPoint3D::setB()} und {\b COutputPoint3D::setC()}.}\par
{
\ql
Wird benutzt von {\b postProcessing()}.}\par
}
{\xe \v calculateSpeed\:CRobCodeGenerator}
{\xe \v CRobCodeGenerator\:calculateSpeed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double CRobCodeGenerator::calculateSpeed ({\b CInputPoint3D} &  {\i p}, size_t  {\i i}, double  {\i timePrev})}}
\par
{\bkmkstart AAAAAAAAGD}
{\bkmkend AAAAAAAAGD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Berechnet die Geschwindigkeit zwischen zwei Punkten. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameter\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i CInputPoint3D&} \cell }{p aktueller Punkt \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i size_t} \cell }{i Position im processedPath \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i double} \cell }{timePrev Zeitstempel des vorherigen Punkts \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
R\'FCckgabe\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
double \par
}}}{
Definiert in Zeile {\b 113} der Datei {\b RobCodeGenerator.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00114 \{\par
00115     {\cf18 double} distance = 0;\par
00116     {\cf18 double} time = 0;\par
00117 \par
00118     distance = processedPath[s - 1].distanceTo(p); {\cf20 //Strecke zwischen p und dem Punkt zuvor}\par
00119     time = p.getTime() - timePrev; {\cf20 //Zeit zwischen p-1 und p}\par
00120 \par
00121     speed = distance / time; {\cf20 // Berechnug Geschwindigkeit zwischen zwei Punkten}\par
00122 \par
00123     {\cf19 if} (speed > MAX_SPEED) {\cf20 //Begrenzung auf maximale Geschwindigkeit, falls Trackerdaten h\'EF\'BF\'BDheren Wert aufweisen}\par
00124         speed = MAX_SPEED;\par
00125 \par
00126     {\cf19 return} speed; {\cf20 //Zuweisung der Geschwindigkeit}\par
00127 \}\par
}
{
\ql
Benutzt {\b CInputPoint3D::getTime()}, {\b MAX_SPEED}, {\b processedPath} und {\b speed}.}\par
{
\ql
Wird benutzt von {\b postProcessing()}.}\par
}
{\xe \v generateRobCode\:CRobCodeGenerator}
{\xe \v CRobCodeGenerator\:generateRobCode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CRobCodeGenerator::generateRobCode (vector< {\b CInputPoint3D} > &  {\i path}, string  {\i filepath}, string  {\i filename})}}
\par
{\bkmkstart AAAAAAAAGE}
{\bkmkend AAAAAAAAGE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Erstellt Roboter Code File. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Ruft das Postprocessing auf und speichert die bearbeiteten Daten als .src File ab {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameter\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i vector<CInputPoint3D>&} \cell }{path \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i string} \cell }{filename \cell }
{\row }
}
}{
Definiert in Zeile {\b 36} der Datei {\b RobCodeGenerator.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00037 \{\par
00038     postProcessing(points); {\cf20 // Calculates all the necessary values}\par
00039 \par
00040     errno_t err;\par
00041     \par
00042     FILE* fid;\par
00043 \par
00044     {\cf18 string} fullPath = filepath + {\cf22 "/"} + filename;\par
00045 \par
00046     {\cf19 if} ((err = fopen_s(&fid, fullPath.c_str(), {\cf22 "w"})) != 0) {\cf20 // Errorhandling for File opening}\par
00047     \{ \par
00048         {\cf18 string} msg = {\cf22 "Open file: "};\par
00049         msg += filename;\par
00050         msg += {\cf22 " failed!"};\par
00051 \par
00052         {\cf19 throw} exception(msg.c_str());\par
00053     \}\par
00054 \par
00055     filename.erase(filename.end()-4,filename.end());        {\cf20 // l\'C3\'B6scht .src}\par
00056     fprintf(fid, {\cf22 "DEF %s \\n"}, filename.c_str());            {\cf20 // DEF in file schreiben}\par
00057 \par
00058     fputs({\cf22 "PTP $POS_ACT\\n"}, fid);                           {\cf20 // PTP zur aktuellen Position in file schreiben}\par
00059 \par
00060     {\cf19 if} (speedManual) {\cf20 // If the speed is set to manual, it will be defined once at the beginning of the file}\par
00061     \{\par
00062         fprintf(fid, {\cf22 "$VEL.CP = %f\\n"}, speed);      {\cf20 // Geschwindigkeit ein file schreiben}\par
00063     \}\par
00064 \par
00065     {\cf19 for} ({\cf18 size_t} s = 0; s < points.size(); s++)\par
00066     \{\par
00067         {\cf19 if} (!speedManual) {\cf20 // If the speed is calculated it needs to be before every LIN command}\par
00068             fprintf(fid, {\cf22 "&VEL.CP = %f\\n"}, ({\cf18 float})processedPath[s].getSpeed());\par
00069         fprintf(fid, {\cf22 "LIN \{X %f, Y %f, Z %f, A %f, B %f, C %f\}\\n"}, round(processedPath[s].getX() * 10.0) / 10.0, round(processedPath[s].getY() * 10.0) / 10.0, \par
00070             round(processedPath[s].getZ() * 10.0) / 10.0, round(processedPath[s].getA() * 10.0) / 10.0, round(processedPath[s].getB() * 10.0) / 10.0, \par
00071             round(processedPath[s].getC() * 10.0) / 10.0);\par
00072     \}\par
00073 \par
00074     fputs({\cf22 "END"}, fid);\par
00075 \}\par
}
{
\ql
Benutzt {\b postProcessing()}, {\b processedPath}, {\b speed} und {\b speedManual}.}\par
{
\ql
Wird benutzt von {\b main()}.}\par
}
{\xe \v postProcessing\:CRobCodeGenerator}
{\xe \v CRobCodeGenerator\:postProcessing}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CRobCodeGenerator::postProcessing (vector< {\b CInputPoint3D} > &  {\i path})}}
\par
{\bkmkstart AAAAAAAAGF}
{\bkmkend AAAAAAAAGF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Nachbearbeitung der Daten. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Integration der Manuellen Eingabedaten in die eingelesenen und bearbeiteten Daten Hier werden calculateSpeed und calculateAngles aufgerufen. {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameter\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i vector<CInputPoint3D>&} \cell }{path \cell }
{\row }
}
}{
Definiert in Zeile {\b 77} der Datei {\b RobCodeGenerator.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00078 \{\par
00079     COutputPoint3D p;\par
00080     {\cf18 double} timePrev = 1;\par
00081 \par
00082     {\cf19 for} ({\cf18 size_t} s = 0; s < path.size(); s++) {\cf20 // F\'C3\'BCr jeden Punkt in dem Vector}\par
00083     \{\par
00084         p.set(path[s].getX(), path[s].getY(), path[s].getZ());\par
00085         {\cf19 if} (speedManual)\par
00086         \{\par
00087             {\cf19 if} (speed > MAX_SPEED) {\cf20 //Wenn maximale Geschwindigkeit ueberschritten wird, Geschwindigkeit begrenzen}\par
00088                 speed = MAX_SPEED;\par
00089         \}\par
00090         {\cf19 else}\par
00091         \{\par
00092             {\cf19 if} (s == 0)\par
00093                 p.setSpeed(1); {\cf20 //Der erste Punkt(0) wird mit Standardgeschwindigkeit 1m/s angefahren.}\par
00094 \par
00095             {\cf19 else}\par
00096                 p.setSpeed(calculateSpeed(path[s], s, timePrev)); {\cf20 //Die Geschwindigkeit zwischen den weiteren Punkten wird berechnet.}\par
00097         \}\par
00098 \par
00099         {\cf19 if} (orientationManual) {\cf20 // Wenn der Winkel vorgegeben ist diesen setzten}\par
00100         \{\par
00101             p.setA(A);\par
00102             p.setB(B);\par
00103             p.setC(C);\par
00104         \}\par
00105         {\cf19 else} {\cf20 // Sonst den Winkel berechnen}\par
00106             calculateAngles(p, path[s]);\par
00107         timePrev = path[s].getTime();\par
00108         processedPath.push_back(p);\par
00109     \}\par
00110 \par
00111 \}\par
}
{
\ql
Benutzt {\b A}, {\b B}, {\b C}, {\b calculateAngles()}, {\b calculateSpeed()}, {\b MAX_SPEED}, {\b orientationManual}, {\b processedPath}, {\b CPoint3D::set()}, {\b COutputPoint3D::setA()}, {\b COutputPoint3D::setB()}, {\b COutputPoint3D::setC()}, {\b COutputPoint3D::setSpeed()}, {\b speed} und {\b speedManual}.}\par
{
\ql
Wird benutzt von {\b generateRobCode()}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Dokumentation der Datenelemente\par
\pard\plain 
{\xe \v A\:CRobCodeGenerator}
{\xe \v CRobCodeGenerator\:A}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double CRobCodeGenerator::A{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAGG}
{\bkmkend AAAAAAAAGG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
User eingegebener Winkel A \par
}{
Definiert in Zeile {\b 98} der Datei {\b RobCodeGenerator.h}.}\par
{
\ql
Wird benutzt von {\b CRobCodeGenerator()}, {\b CRobCodeGenerator()} und {\b postProcessing()}.}\par
}
{\xe \v B\:CRobCodeGenerator}
{\xe \v CRobCodeGenerator\:B}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double CRobCodeGenerator::B{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAGH}
{\bkmkend AAAAAAAAGH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
User eingegebener Winkel B \par
}{
Definiert in Zeile {\b 102} der Datei {\b RobCodeGenerator.h}.}\par
{
\ql
Wird benutzt von {\b CRobCodeGenerator()}, {\b CRobCodeGenerator()} und {\b postProcessing()}.}\par
}
{\xe \v C\:CRobCodeGenerator}
{\xe \v CRobCodeGenerator\:C}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double CRobCodeGenerator::C{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAGI}
{\bkmkend AAAAAAAAGI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
User eingegebener Winkel C \par
}{
Definiert in Zeile {\b 106} der Datei {\b RobCodeGenerator.h}.}\par
{
\ql
Wird benutzt von {\b CRobCodeGenerator()}, {\b CRobCodeGenerator()} und {\b postProcessing()}.}\par
}
{\xe \v orientationManual\:CRobCodeGenerator}
{\xe \v CRobCodeGenerator\:orientationManual}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool CRobCodeGenerator::orientationManual{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAGJ}
{\bkmkend AAAAAAAAGJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Auswahl ob berechnete oder eingegebene Winkel verwendet werden soll \par
}{
Definiert in Zeile {\b 94} der Datei {\b RobCodeGenerator.h}.}\par
{
\ql
Wird benutzt von {\b CRobCodeGenerator()}, {\b CRobCodeGenerator()} und {\b postProcessing()}.}\par
}
{\xe \v processedPath\:CRobCodeGenerator}
{\xe \v CRobCodeGenerator\:processedPath}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
vector<{\b COutputPoint3D}> CRobCodeGenerator::processedPath{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAGK}
{\bkmkend AAAAAAAAGK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Fertig bearbeiteter Pfad \par
}{
Definiert in Zeile {\b 82} der Datei {\b RobCodeGenerator.h}.}\par
{
\ql
Wird benutzt von {\b calculateSpeed()}, {\b generateRobCode()} und {\b postProcessing()}.}\par
}
{\xe \v speed\:CRobCodeGenerator}
{\xe \v CRobCodeGenerator\:speed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double CRobCodeGenerator::speed{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAGL}
{\bkmkend AAAAAAAAGL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
User eingegebene Geschwindigkeit \par
}{
Definiert in Zeile {\b 86} der Datei {\b RobCodeGenerator.h}.}\par
{
\ql
Wird benutzt von {\b calculateSpeed()}, {\b CRobCodeGenerator()}, {\b CRobCodeGenerator()}, {\b generateRobCode()} und {\b postProcessing()}.}\par
}
{\xe \v speedManual\:CRobCodeGenerator}
{\xe \v CRobCodeGenerator\:speedManual}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool CRobCodeGenerator::speedManual{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAGM}
{\bkmkend AAAAAAAAGM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Auswahl ob berechnete oder eingegebene Geschwindigkeit verwendet werden soll \par
}{
Definiert in Zeile {\b 90} der Datei {\b RobCodeGenerator.h}.}\par
{
\ql
Wird benutzt von {\b CRobCodeGenerator()}, {\b CRobCodeGenerator()}, {\b generateRobCode()} und {\b postProcessing()}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
Die Dokumentation f\'FCr diese Klasse wurde erzeugt aufgrund der Dateien:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
header/{\b RobCodeGenerator.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
src/{\b RobCodeGenerator.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CSegmentApproximator Klassenreferenz\par \pard\plain 
{\tc\tcl2 \v CSegmentApproximator}
{\xe \v CSegmentApproximator}
{\bkmkstart AAAAAAAAGN}
{\bkmkend AAAAAAAAGN}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Ausd\'FCnnen des Pfades. }}\par
{
{\f2 #include <SegmentApproximator.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'D6ffentliche Methoden\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CSegmentApproximator} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Default Konstruktor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~CSegmentApproximator} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dekonstruktor. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b approx} (const vector< list< {\b CInputPoint3D} > > &Segments, {\b CLogging} log)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Ruft die Douglas-Peuker Funktion auf. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setmaxDistance} (double maxDistanceSource)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Setzt die maximale Abweichung. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b getmaxDistance} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gibt die maximale Abweichung zur\'FCck. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
vector< list< {\b CInputPoint3D} > > & {\b getSegmentsApproxVector} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gibt den bereinigten Pfad zur\'FCck. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Methoden\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b douglasPeuckerRecursive} (list< {\b CInputPoint3D} > &segment, std::list< {\b CInputPoint3D} >::iterator startItr, std::list< {\b CInputPoint3D} >::iterator endItr)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Rekursive Douglas Peuker Funktion. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Attribute\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
vector< list< {\b CInputPoint3D} > > {\b segmentsApprox}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b maxDistance}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Ausf\'FChrliche Beschreibung\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Ausd\'FCnnen des Pfades. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
In dieser Klasse wird der Pfad mit hilfe des Douglas-Peuker Algorithmusses ausged\'FCnnt \par
}{
Definiert in Zeile {\b 22} der Datei {\b SegmentApproximator.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Beschreibung der Konstruktoren und Destruktoren\par
\pard\plain 
{\xe \v CSegmentApproximator\:CSegmentApproximator}
{\xe \v CSegmentApproximator\:CSegmentApproximator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CSegmentApproximator::CSegmentApproximator (void )}}
\par
{\bkmkstart AAAAAAAAGO}
{\bkmkend AAAAAAAAGO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Default Konstruktor. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialisiert die Klasse \par
}{
Definiert in Zeile {\b 11} der Datei {\b SegmentApproximator.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00012 \{\par
00013 \}\par
}
}
{\xe \v ~CSegmentApproximator\:CSegmentApproximator}
{\xe \v CSegmentApproximator\:~CSegmentApproximator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CSegmentApproximator::~CSegmentApproximator (void )}}
\par
{\bkmkstart AAAAAAAAGP}
{\bkmkend AAAAAAAAGP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Dekonstruktor. }}\par
{
Definiert in Zeile {\b 15} der Datei {\b SegmentApproximator.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00016 \{\par
00017 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Dokumentation der Elementfunktionen\par
\pard\plain 
{\xe \v approx\:CSegmentApproximator}
{\xe \v CSegmentApproximator\:approx}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CSegmentApproximator::approx (const vector< list< {\b CInputPoint3D} > > &  {\i Segments}, {\b CLogging}  {\i log})}}
\par
{\bkmkstart AAAAAAAAGQ}
{\bkmkend AAAAAAAAGQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Ruft die Douglas-Peuker Funktion auf. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Iteriert durch die Listen im Vektor und ruft die Douglas-Peuker-Funktion auf {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameter\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i Segments} \cell }{const vector<list<CInputPoint3D>>& \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i {\b CLogging}} \cell }{log f\'FCr das Logging \cell }
{\row }
}
}{
Definiert in Zeile {\b 19} der Datei {\b SegmentApproximator.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00020 \{\par
00021     CInputPoint3D p;\par
00022 \par
00023     segmentsApprox = segments;\par
00024 \par
00025     {\cf20 /* Douglas Peucker f\'FCr Segmente aufrufen*/}\par
00026     {\cf19 for} ({\cf18 size_t} s = 0; s < segments.size(); s++)\par
00027     \{\par
00028         douglasPeuckerRecursive(segmentsApprox[s], segmentsApprox[s].begin(), --(segmentsApprox[s].end()));\par
00029     \}\par
00030 \par
00031     {\cf20 /*  Logging der Daten*/}\par
00032     log.setStep(3);\par
00033     log.logData(segmentsApprox);\par
00034 \}\par
}
{
\ql
Benutzt {\b douglasPeuckerRecursive()}, {\b CLogging::logData()}, {\b segmentsApprox} und {\b CLogging::setStep()}.}\par
{
\ql
Wird benutzt von {\b main()}.}\par
}
{\xe \v douglasPeuckerRecursive\:CSegmentApproximator}
{\xe \v CSegmentApproximator\:douglasPeuckerRecursive}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CSegmentApproximator::douglasPeuckerRecursive (list< {\b CInputPoint3D} > &  {\i segment}, std::list< {\b CInputPoint3D} >::iterator  {\i startItr}, std::list< {\b CInputPoint3D} >::iterator  {\i endItr}){\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAGR}
{\bkmkend AAAAAAAAGR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Rekursive Douglas Peuker Funktion. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Rekursive Funktion die durch das Segment geht und Punkte aus dem Pfad l\'F6scht wenn ihr Abstand zu gro\'DF wird. {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameter\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i list<CInputPoint3D>&} \cell }{segment \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i std::list<CInputPoint3D>::iterator} \cell }{startIt \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i std::list<CInputPoint3D>::iterator} \cell }{endItr \cell }
{\row }
}
}{
Definiert in Zeile {\b 52} der Datei {\b SegmentApproximator.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00053 \{\par
00054     {\cf19 if} (segment.size() < 3) {\cf19 return};  {\cf20 // min Gr\'F6\'DFe pro Seg 3}\par
00055     {\cf19 if} (distance(startItr, endItr) == 2) {\cf19 return};        {\cf20 // Zeigerabstand == 2}\par
00056     CInputPoint3D pStart; CInputPoint3D pEnd;       {\cf20 // Variablen deklarieren}\par
00057 \par
00058 \par
00059     {\cf20 /* Startpunkt setzen */}\par
00060     pStart.setX(startItr->getX()); pStart.setY(startItr->getY()); pStart.setZ(startItr->getZ());\par
00061     pStart.setTime(startItr->getTime());\par
00062     pStart.setEulerMatrix(startItr->getEulerMatrix());\par
00063 \par
00064     {\cf20 /* Endpunkt setzen */}\par
00065     pEnd.setX(endItr->getX()); pEnd.setY(endItr->getY()); pEnd.setZ(endItr->getZ());\par
00066     pEnd.setTime(endItr->getTime());\par
00067     pEnd.setEulerMatrix(endItr->getEulerMatrix());\par
00068 \par
00069     {\cf18 double} dist = 0.0, maxDist = 0.0;                   {\cf20 // dist und maxDist initialisieren }\par
00070     std::list<CInputPoint3D>::iterator maxItr, itr;     {\cf20 // Zeiger bilden}\par
00071 \par
00072 \par
00073     {\cf20 /* am weitesten Entfernten Punkt suchen */}\par
00074     {\cf19 for} (itr = startItr; itr != endItr; itr++)\par
00075     \{\par
00076         CLine3D line = CLine3D(pStart, pEnd);\par
00077         {\cf20 // calc distance}\par
00078         dist = itr->distanceTo(line);\par
00079         {\cf19 if} (dist > maxDist) \{\par
00080             maxDist = dist;\par
00081             maxItr = itr;\par
00082         \}\par
00083     \}\par
00084 \par
00085     {\cf19 if} (maxDist <= maxDistance) \{\par
00086 \par
00087         segment.erase((++startItr), endItr);        {\cf20 // Punkt l\'F6schen}\par
00088         {\cf19 return};\par
00089     \}\par
00090 \par
00091     {\cf20 /*  Douglas Peucker erneut aufrufen */}\par
00092     douglasPeuckerRecursive(segment, startItr, maxItr);\par
00093     douglasPeuckerRecursive(segment, maxItr, endItr);\par
00094 \}\par
}
{
\ql
Benutzt {\b douglasPeuckerRecursive()}, {\b maxDistance}, {\b CInputPoint3D::setEulerMatrix()}, {\b CInputPoint3D::setTime()}, {\b CPoint3D::setX()}, {\b CPoint3D::setY()} und {\b CPoint3D::setZ()}.}\par
{
\ql
Wird benutzt von {\b approx()} und {\b douglasPeuckerRecursive()}.}\par
}
{\xe \v getmaxDistance\:CSegmentApproximator}
{\xe \v CSegmentApproximator\:getmaxDistance}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double CSegmentApproximator::getmaxDistance ()}}
\par
{\bkmkstart AAAAAAAAGS}
{\bkmkend AAAAAAAAGS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gibt die maximale Abweichung zur\'FCck. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
R\'FCckgabe\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
maxDistanceSource double \par
}}}{
Definiert in Zeile {\b 41} der Datei {\b SegmentApproximator.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00042 \{\par
00043     {\cf19 return} maxDistance;     {\cf20 // Rueckgabe von maxDistance}\par
00044 \}\par
}
{
\ql
Benutzt {\b maxDistance}.}\par
}
{\xe \v getSegmentsApproxVector\:CSegmentApproximator}
{\xe \v CSegmentApproximator\:getSegmentsApproxVector}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
vector< list< {\b CInputPoint3D} > > & CSegmentApproximator::getSegmentsApproxVector ()}}
\par
{\bkmkstart AAAAAAAAGT}
{\bkmkend AAAAAAAAGT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gibt den bereinigten Pfad zur\'FCck. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
R\'FCckgabe\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
vector<list<CInputPoint3D>>& \par
}}}{
Definiert in Zeile {\b 46} der Datei {\b SegmentApproximator.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00047 \{\par
00048     {\cf19 return} segmentsApprox;      {\cf20 // Rueckgabe der Segmente}\par
00049 \}\par
}
{
\ql
Benutzt {\b segmentsApprox}.}\par
{
\ql
Wird benutzt von {\b main()}.}\par
}
{\xe \v setmaxDistance\:CSegmentApproximator}
{\xe \v CSegmentApproximator\:setmaxDistance}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CSegmentApproximator::setmaxDistance (double  {\i maxDistanceSource})}}
\par
{\bkmkstart AAAAAAAAGU}
{\bkmkend AAAAAAAAGU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Setzt die maximale Abweichung. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameter\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i maxDistanceSource} \cell }{double \cell }
{\row }
}
}{
Definiert in Zeile {\b 36} der Datei {\b SegmentApproximator.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00037 \{\par
00038     maxDistance = maxDistanceSource;        {\cf20 // setze maxDistance}\par
00039 \}\par
}
{
\ql
Benutzt {\b maxDistance}.}\par
{
\ql
Wird benutzt von {\b main()}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Dokumentation der Datenelemente\par
\pard\plain 
{\xe \v maxDistance\:CSegmentApproximator}
{\xe \v CSegmentApproximator\:maxDistance}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double CSegmentApproximator::maxDistance{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAGV}
{\bkmkend AAAAAAAAGV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Einstellbare Distanz f\'FCr den Douglas-Peuker-Algorithmus \par
}{
Definiert in Zeile {\b 67} der Datei {\b SegmentApproximator.h}.}\par
{
\ql
Wird benutzt von {\b douglasPeuckerRecursive()}, {\b getmaxDistance()} und {\b setmaxDistance()}.}\par
}
{\xe \v segmentsApprox\:CSegmentApproximator}
{\xe \v CSegmentApproximator\:segmentsApprox}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
vector<list<{\b CInputPoint3D}> > CSegmentApproximator::segmentsApprox{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAGW}
{\bkmkend AAAAAAAAGW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Bereinigten Pfad \par
}{
Definiert in Zeile {\b 63} der Datei {\b SegmentApproximator.h}.}\par
{
\ql
Wird benutzt von {\b approx()} und {\b getSegmentsApproxVector()}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
Die Dokumentation f\'FCr diese Klasse wurde erzeugt aufgrund der Dateien:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
header/{\b SegmentApproximator.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
src/{\b SegmentApproximator.cpp}\par
}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Datei-Dokumentation{\tc \v Datei-Dokumentation}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
header/EulerMatrix.h-Dateireferenz\par \pard\plain 
{\tc\tcl2 \v header/EulerMatrix.h}
{\xe \v header/EulerMatrix.h}
{\bkmkstart AAAAAAAAAV}
{\bkmkend AAAAAAAAAV}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Header File handling Euler Matrix. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <tuple>}\par
{\f2 #include <cmath>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Klassen\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CEulerMatrix}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Handling und Berechnung Euler Matrix. }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Makrodefinitionen\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b _USE_MATH_DEFINES}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Ausf\'FChrliche Beschreibung\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Header File handling Euler Matrix. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definiert in Datei {\b EulerMatrix.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Makro-Dokumentation\par
\pard\plain 
{\xe \v _USE_MATH_DEFINES\:EulerMatrix.h}
{\xe \v EulerMatrix.h\:_USE_MATH_DEFINES}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define _USE_MATH_DEFINES}}
\par
{\bkmkstart AAAAAAAAAW}
{\bkmkend AAAAAAAAAW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definiert in Zeile {\b 10} der Datei {\b EulerMatrix.h}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
EulerMatrix.h\par \pard\plain 
{\tc\tcl2 \v header/EulerMatrix.h}
{\xe \v header/EulerMatrix.h}
{\bkmkstart AAAAAAAAAA}
{\bkmkend AAAAAAAAAA}
gehe zur Dokumentation dieser Datei{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00007 {\cf21 #include <tuple>}\par
00008 {\cf21 #include <cmath>}\par
00009 \par
00010 {\cf21 #define _USE_MATH_DEFINES}\par
00011 \par
00012 {\cf17 using namespace }std;\par
00013 \par
00014 {\cf21 #pragma once}\par
00015 \par
00020 {\cf17 class }CEulerMatrix\par
00021 \{\par
00022 {\cf17 public}:\par
00028     CEulerMatrix({\cf18 void});\par
00035     CEulerMatrix({\cf18 float} inputMatrix[3][3]);\par
00039     ~CEulerMatrix();\par
00040 \par
00045     {\cf18 void} setMatrix({\cf18 float} inputMatrix[3][3]);\par
00050     CEulerMatrix getEulerMatrix({\cf18 void});\par
00051 \par
00056     {\cf18 void} getMatrix({\cf18 float} Matrix[][3]);\par
00064     CEulerMatrix angels2mat({\cf18 double} A, {\cf18 double} B, {\cf18 double} C);\par
00065 \par
00070     tuple<double , double , double> calculateAngels({\cf18 void});\par
00071 \par
00072 {\cf17 private}:\par
00076     {\cf18 float} eulerMatrix[3][3];\par
00077 \par
00078 \};\par
00079 \par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
header/GUI.h-Dateireferenz\par \pard\plain 
{\tc\tcl2 \v header/GUI.h}
{\xe \v header/GUI.h}
{\bkmkstart AAAAAAAAAX}
{\bkmkend AAAAAAAAAX}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Klassen\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CGUI}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
GUI.h\par \pard\plain 
{\tc\tcl2 \v header/GUI.h}
{\xe \v header/GUI.h}
{\bkmkstart AAAAAAAAAB}
{\bkmkend AAAAAAAAAB}
gehe zur Dokumentation dieser Datei{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #pragma once}\par
00002 \par
00003 {\cf17 class }CGUI\par
00004 \{\par
00005 \par
00006 {\cf17 public}:\par
00007     CGUI();\par
00008     ~CGUI();\par
00009 \};\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
header/InputParameter.h-Dateireferenz\par \pard\plain 
{\tc\tcl2 \v header/InputParameter.h}
{\xe \v header/InputParameter.h}
{\bkmkstart AAAAAAAAAY}
{\bkmkend AAAAAAAAAY}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Header File Daten Einlesen. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "EulerMatrix.h"}\par
{\f2 #include "Point3D.h"}\par
{\f2 #include <string>}\par
{\f2 #include <vector>}\par
{\f2 #include <list>}\par
{\f2 #include <iostream>}\par
{\f2 #include <fstream>}\par
{\f2 #include <sstream>}\par
{\f2 #include <tuple>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Klassen\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CInputParameter}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Handling Eingabedaten. }}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Ausf\'FChrliche Beschreibung\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Header File Daten Einlesen. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definiert in Datei {\b InputParameter.h}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
InputParameter.h\par \pard\plain 
{\tc\tcl2 \v header/InputParameter.h}
{\xe \v header/InputParameter.h}
{\bkmkstart AAAAAAAAAC}
{\bkmkend AAAAAAAAAC}
gehe zur Dokumentation dieser Datei{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00007 {\cf21 #include "EulerMatrix.h"}\par
00008 {\cf21 #include "Point3D.h"}\par
00009 {\cf21 #include <string>}\par
00010 {\cf21 #include <vector>}\par
00011 {\cf21 #include <list>}\par
00012 {\cf21 #include <iostream>}\par
00013 {\cf21 #include <fstream>}\par
00014 {\cf21 #include <sstream>} \par
00015 {\cf21 #include <tuple>}\par
00016 \par
00017 {\cf17 using namespace }std;\par
00018 \par
00019 {\cf21 #pragma once}\par
00020 \par
00025 {\cf17 class }CInputParameter\par
00026 \{\par
00027 {\cf17 public}:\par
00033     CInputParameter({\cf18 void});\par
00047     CInputParameter({\cf18 double} initSpeed, {\cf18 bool} initSeepManual, {\cf18 bool} initOrientationManual, {\cf18 double} initA, {\cf18 double} initB, {\cf18 double} initC);\par
00051     ~CInputParameter({\cf18 void});\par
00052 \par
00061     {\cf18 void} setOrientation({\cf18 bool} initOrientationManual, {\cf18 double} initA, {\cf18 double} initB, {\cf18 double} initC);\par
00068     {\cf18 void} setSpeed({\cf18 double} initSpeed, {\cf18 bool} initSpeedManual);\par
00069 \par
00074     {\cf18 double} getSpeed({\cf18 void});\par
00079     {\cf18 bool} getSpeedManual({\cf18 void});\par
00084     {\cf18 bool} getOrientationManual({\cf18 void});\par
00090     tuple <double, double, double> getAngles({\cf18 void});\par
00091 \par
00097     {\cf18 void} openFile(std::string path);\par
00106     {\cf18 bool} detectJump(CInputPoint3D p, {\cf18 double} x_prev, {\cf18 double} y_prev, {\cf18 double} z_prev);\par
00111     vector<list<CInputPoint3D>>& getPath();\par
00112 \par
00113 {\cf17 private}:\par
00117     vector<list<CInputPoint3D>> initialPath;\par
00121     {\cf18 double} speed;\par
00125     {\cf18 bool} speedManual;\par
00129     {\cf18 bool} orientationManual;\par
00133     {\cf18 double} A;\par
00137     {\cf18 double} B;\par
00141     {\cf18 double} C;\par
00145     {\cf18 double} difference = 20;\par
00146 \};\par
00147 \par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
header/Line3D.h-Dateireferenz\par \pard\plain 
{\tc\tcl2 \v header/Line3D.h}
{\xe \v header/Line3D.h}
{\bkmkstart AAAAAAAAAZ}
{\bkmkend AAAAAAAAAZ}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Header File Daten Einlesen. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "Point3D.h"}\par
{\f2 #include <math.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Klassen\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CLine3D}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Berechnung Geraden. }}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Ausf\'FChrliche Beschreibung\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Header File Daten Einlesen. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definiert in Datei {\b Line3D.h}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Line3D.h\par \pard\plain 
{\tc\tcl2 \v header/Line3D.h}
{\xe \v header/Line3D.h}
{\bkmkstart AAAAAAAAAD}
{\bkmkend AAAAAAAAAD}
gehe zur Dokumentation dieser Datei{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00007 {\cf21 #include "Point3D.h"}\par
00008 {\cf21 #include <math.h>}\par
00009 \par
00010 {\cf17 using namespace }std;\par
00011 \par
00012 {\cf21 #pragma once}\par
00013 \par
00018 {\cf17 class }CLine3D\par
00019 \{\par
00020 {\cf17 public}:\par
00026     CLine3D({\cf18 void});\par
00032     CLine3D(CPoint3D P1, CPoint3D P2);\par
00036     ~CLine3D({\cf18 void});\par
00037 \par
00041     CPoint3D p1;\par
00045     CPoint3D p2;\par
00046 \};\par
00047 \par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
header/Logging.h-Dateireferenz\par \pard\plain 
{\tc\tcl2 \v header/Logging.h}
{\xe \v header/Logging.h}
{\bkmkstart AAAAAAAABA}
{\bkmkend AAAAAAAABA}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Logging der Daten. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "EulerMatrix.h"}\par
{\f2 #include "Point3D.h"}\par
{\f2 #include <iostream>}\par
{\f2 #include <fstream>}\par
{\f2 #include <sstream>}\par
{\f2 #include <string>}\par
{\f2 #include <vector>}\par
{\f2 #include <list>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Klassen\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CLogging}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gleitender Mittelwertfilter. }}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Ausf\'FChrliche Beschreibung\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Logging der Daten. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definiert in Datei {\b Logging.h}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Logging.h\par \pard\plain 
{\tc\tcl2 \v header/Logging.h}
{\xe \v header/Logging.h}
{\bkmkstart AAAAAAAAAE}
{\bkmkend AAAAAAAAAE}
gehe zur Dokumentation dieser Datei{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00007 {\cf21 #include "EulerMatrix.h"}\par
00008 {\cf21 #include "Point3D.h"}\par
00009 \par
00010 {\cf21 #include <iostream>}\par
00011 {\cf21 #include <fstream>}\par
00012 {\cf21 #include <sstream>} \par
00013 {\cf21 #include <string>}\par
00014 {\cf21 #include <vector>}\par
00015 {\cf21 #include <list>}\par
00016 \par
00017 {\cf21 #pragma once}\par
00022 {\cf17 class }CLogging\par
00023 \{\par
00024 {\cf17 public}:\par
00030     CLogging({\cf18 void});\par
00036     CLogging({\cf18 string} path);\par
00040     ~CLogging({\cf18 void});\par
00045     {\cf18 void} setStep({\cf18 int} Step);\par
00051     {\cf18 void} logData(vector<list<CInputPoint3D>>& sourcePath);\par
00057     {\cf18 void} logData(vector<CInputPoint3D>& sourcePath);\par
00058 {\cf17 private}:\par
00062     {\cf18 int} step;\par
00066     {\cf18 string} path;\par
00067 \};\par
00068 \par
00069 \par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
header/MeanFilter.h-Dateireferenz\par \pard\plain 
{\tc\tcl2 \v header/MeanFilter.h}
{\xe \v header/MeanFilter.h}
{\bkmkstart AAAAAAAABB}
{\bkmkend AAAAAAAABB}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Berechnung des gleitenden Mittelwertfilters. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <vector>}\par
{\f2 #include <list>}\par
{\f2 #include <string>}\par
{\f2 #include "Point3D.h"}\par
{\f2 #include "Logging.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Klassen\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CMeanFilter}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gleitender Mittelwertfilter. }}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Ausf\'FChrliche Beschreibung\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Berechnung des gleitenden Mittelwertfilters. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definiert in Datei {\b MeanFilter.h}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MeanFilter.h\par \pard\plain 
{\tc\tcl2 \v header/MeanFilter.h}
{\xe \v header/MeanFilter.h}
{\bkmkstart AAAAAAAAAF}
{\bkmkend AAAAAAAAAF}
gehe zur Dokumentation dieser Datei{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00007 {\cf21 #include <vector>}\par
00008 {\cf21 #include <list>}\par
00009 {\cf21 #include <string>}\par
00010 {\cf21 #include "Point3D.h"}\par
00011 {\cf21 #include "Logging.h"}\par
00012 \par
00013 {\cf21 #pragma once}\par
00014 \par
00015 {\cf17 using namespace }std;\par
00016 \par
00021 {\cf17 class }CMeanFilter\par
00022 \{\par
00023 {\cf17 public}:\par
00029     CMeanFilter();\par
00036     CMeanFilter({\cf18 int} Window);\par
00040     ~CMeanFilter();\par
00041 \par
00046     {\cf18 void} setWindowSize({\cf18 int} Window);\par
00047 \par
00052     {\cf18 int} getWindowSize();\par
00057     vector<list<CInputPoint3D>>& getPath();\par
00058 \par
00065     list<CInputPoint3D> calculateMean(list<CInputPoint3D>& segment);\par
00073     {\cf18 void} mean(vector<list<CInputPoint3D>>& sourcePath, CLogging log);\par
00074 \par
00075 {\cf17 private}:\par
00079     {\cf18 int} windowSize;\par
00083     vector<list<CInputPoint3D>> meanPath;\par
00084 \};\par
00085 \par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
header/PathBuilder.h-Dateireferenz\par \pard\plain 
{\tc\tcl2 \v header/PathBuilder.h}
{\xe \v header/PathBuilder.h}
{\bkmkstart AAAAAAAABC}
{\bkmkend AAAAAAAABC}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Setzt die einzelnen Segmente zu einem Vector zusammen. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <vector>}\par
{\f2 #include <list>}\par
{\f2 #include <iostream>}\par
{\f2 #include "Point3D.h"}\par
{\f2 #include "Logging.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Klassen\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CPathBuilder}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Zusammensetzten des Pfades. }}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Ausf\'FChrliche Beschreibung\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Setzt die einzelnen Segmente zu einem Vector zusammen. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definiert in Datei {\b PathBuilder.h}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
PathBuilder.h\par \pard\plain 
{\tc\tcl2 \v header/PathBuilder.h}
{\xe \v header/PathBuilder.h}
{\bkmkstart AAAAAAAAAG}
{\bkmkend AAAAAAAAAG}
gehe zur Dokumentation dieser Datei{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00007 {\cf21 #include <vector>}\par
00008 {\cf21 #include <list>}\par
00009 {\cf21 #include <iostream>}\par
00010 {\cf21 #include "Point3D.h"}\par
00011 {\cf21 #include "Logging.h"}\par
00012 \par
00013 {\cf17 using namespace }std;\par
00014 \par
00015 {\cf21 #pragma once}\par
00016 \par
00021 {\cf17 class }CPathBuilder\par
00022 \{\par
00023 {\cf17 public}:\par
00028     CPathBuilder({\cf18 void});\par
00032     ~CPathBuilder({\cf18 void});\par
00033 \par
00038     vector<CInputPoint3D>& getPath();\par
00044     {\cf18 void} createPath(vector<list<CInputPoint3D>>& segments, CLogging log);\par
00045 \par
00046 {\cf17 private}:\par
00050     vector<CInputPoint3D> path;\par
00051 \};\par
00052 \par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
header/Point3D.h-Dateireferenz\par \pard\plain 
{\tc\tcl2 \v header/Point3D.h}
{\xe \v header/Point3D.h}
{\bkmkstart AAAAAAAABD}
{\bkmkend AAAAAAAABD}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Verarbeitung der Punkte. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "EulerMatrix.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Klassen\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CPoint3D}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Grundklasse Punkt. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CInputPoint3D}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Input Punkt. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b COutputPoint3D}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Output Punkt. }}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Ausf\'FChrliche Beschreibung\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Verarbeitung der Punkte. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definiert in Datei {\b Point3D.h}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Point3D.h\par \pard\plain 
{\tc\tcl2 \v header/Point3D.h}
{\xe \v header/Point3D.h}
{\bkmkstart AAAAAAAAAH}
{\bkmkend AAAAAAAAAH}
gehe zur Dokumentation dieser Datei{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00007 {\cf21 #include "EulerMatrix.h"}\par
00008 \par
00009 {\cf17 class }CLine3D;\par
00010 \par
00011 {\cf17 using namespace }std;\par
00012 \par
00013 {\cf21 #pragma once}\par
00014 \par
00020 {\cf17 class }CPoint3D\par
00021 \{\par
00022 {\cf17 public}:\par
00028     CPoint3D({\cf18 void});\par
00037     CPoint3D({\cf18 double} X, {\cf18 double} Y, {\cf18 double} Z);\par
00041     ~CPoint3D({\cf18 void});\par
00042 \par
00047     {\cf18 double} getX();\par
00052     {\cf18 double} getY();\par
00057     {\cf18 double} getZ();\par
00058 \par
00063     {\cf18 void} setX({\cf18 double} X);\par
00068     {\cf18 void} setY({\cf18 double} Y);\par
00073     {\cf18 void} setZ({\cf18 double} Z);\par
00074 \par
00081     {\cf18 void} set({\cf18 double} X, {\cf18 double} Y, {\cf18 double} Z);\par
00087     {\cf18 double} distanceTo(CPoint3D point);\par
00093     {\cf18 double} distanceTo(CLine3D line);\par
00094 \par
00095 {\cf17 protected}:\par
00099     {\cf18 double} x, y, z;\par
00100 \};\par
00101 \par
00106 {\cf17 class }CInputPoint3D : {\cf17 public} CPoint3D\par
00107 \{   \par
00108 {\cf17 public}:\par
00114     CInputPoint3D({\cf18 void});\par
00125     CInputPoint3D({\cf18 double} X, {\cf18 double} Y, {\cf18 double} Z, {\cf18 double} Timestamp, CEulerMatrix Matrix);\par
00129     ~CInputPoint3D({\cf18 void});\par
00130 \par
00135     {\cf18 double} getTime();\par
00140     CEulerMatrix getEulerMatrix();\par
00141 \par
00146     {\cf18 void} setTime({\cf18 double} time);  \par
00151     {\cf18 void} setEulerMatrix(CEulerMatrix orientation);\par
00160     {\cf18 void} setPoint({\cf18 double} time, {\cf18 double} X, {\cf18 double} Y, {\cf18 double} Z, CEulerMatrix orientation);\par
00161 \par
00162 {\cf17 private}:\par
00166     {\cf18 double} timestamp;\par
00170     CEulerMatrix orientationMatrix;\par
00171 \};\par
00172 \par
00177 {\cf17 class }COutputPoint3D : {\cf17 public} CPoint3D\par
00178 \{\par
00179 {\cf17 public}:\par
00185     COutputPoint3D({\cf18 void});\par
00198     COutputPoint3D({\cf18 double} Speed, {\cf18 double} X, {\cf18 double} Y, {\cf18 double} Z, {\cf18 double} A, {\cf18 double} B, {\cf18 double} C);\par
00202     ~COutputPoint3D({\cf18 void});\par
00203 \par
00208     {\cf18 double} getSpeed();\par
00213     {\cf18 double} getA();\par
00218     {\cf18 double} getB();\par
00223     {\cf18 double} getC();\par
00224 \par
00229     {\cf18 void} setSpeed({\cf18 double} speed);\par
00234     {\cf18 void} setA({\cf18 double} A);\par
00239     {\cf18 void} setB({\cf18 double} B);\par
00244     {\cf18 void} setC({\cf18 double} C);\par
00245 {\cf17 private}:\par
00249     {\cf18 double} a, b, c;\par
00253     {\cf18 double} speed;\par
00254 \};\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
header/RobCodeGenerator.h-Dateireferenz\par \pard\plain 
{\tc\tcl2 \v header/RobCodeGenerator.h}
{\xe \v header/RobCodeGenerator.h}
{\bkmkstart AAAAAAAABE}
{\bkmkend AAAAAAAABE}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Erstellung des Roboter Codes. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <vector>}\par
{\f2 #include <iostream>}\par
{\f2 #include "Point3D.h"}\par
{\f2 #include <tuple>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Klassen\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CRobCodeGenerator}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Klasse zum erstellen des Roboter Codes. }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Makrodefinitionen\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MAX_SPEED}\~ 2.0\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Ausf\'FChrliche Beschreibung\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Erstellung des Roboter Codes. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definiert in Datei {\b RobCodeGenerator.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Makro-Dokumentation\par
\pard\plain 
{\xe \v MAX_SPEED\:RobCodeGenerator.h}
{\xe \v RobCodeGenerator.h\:MAX_SPEED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MAX_SPEED\~ 2.0}}
\par
{\bkmkstart AAAAAAAABF}
{\bkmkend AAAAAAAABF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definiert in Zeile {\b 16} der Datei {\b RobCodeGenerator.h}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
RobCodeGenerator.h\par \pard\plain 
{\tc\tcl2 \v header/RobCodeGenerator.h}
{\xe \v header/RobCodeGenerator.h}
{\bkmkstart AAAAAAAAAI}
{\bkmkend AAAAAAAAAI}
gehe zur Dokumentation dieser Datei{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00007 {\cf21 #include <vector>}\par
00008 {\cf21 #include <iostream>}\par
00009 {\cf21 #include "Point3D.h"}\par
00010 {\cf21 #include <tuple>}\par
00011 \par
00012 {\cf17 using namespace }std;\par
00013 \par
00014 {\cf21 #pragma once}\par
00015 \par
00016 {\cf21 #define MAX_SPEED 2.0}\par
00017 \par
00023 {\cf17 class }CRobCodeGenerator\par
00024 \{\par
00025 {\cf17 public}:\par
00031     CRobCodeGenerator({\cf18 void});\par
00043     CRobCodeGenerator({\cf18 double} speedIn, {\cf18 bool} speedManualIn, {\cf18 bool} orientationManualIn, tuple<double, double, double> angles);\par
00047     ~CRobCodeGenerator({\cf18 void});\par
00048 \par
00055     {\cf18 void} generateRobCode(vector<CInputPoint3D>& path, {\cf18 string} filepath, {\cf18 string} filename);\par
00062     {\cf18 void} postProcessing(vector<CInputPoint3D>& path);\par
00070     {\cf18 double} calculateSpeed(CInputPoint3D& p, {\cf18 size_t} i, {\cf18 double} timePrev);\par
00076     {\cf18 void} calculateAngles(COutputPoint3D& p, CInputPoint3D& pIn);\par
00077 \par
00078 {\cf17 private}:\par
00082     vector<COutputPoint3D> processedPath;\par
00086     {\cf18 double} speed;\par
00090     {\cf18 bool} speedManual;\par
00094     {\cf18 bool} orientationManual;\par
00098     {\cf18 double} A;\par
00102     {\cf18 double} B;\par
00106     {\cf18 double} C;\par
00107 \par
00108 \};\par
00109 \par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
header/SegmentApproximator.h-Dateireferenz\par \pard\plain 
{\tc\tcl2 \v header/SegmentApproximator.h}
{\xe \v header/SegmentApproximator.h}
{\bkmkstart AAAAAAAABG}
{\bkmkend AAAAAAAABG}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Berechnung des Douglas Peuker Algorithmusses. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <vector>}\par
{\f2 #include <list>}\par
{\f2 #include <iostream>}\par
{\f2 #include <math.h>}\par
{\f2 #include "Point3D.h"}\par
{\f2 #include "Logging.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Klassen\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CSegmentApproximator}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Ausd\'FCnnen des Pfades. }}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Ausf\'FChrliche Beschreibung\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Berechnung des Douglas Peuker Algorithmusses. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definiert in Datei {\b SegmentApproximator.h}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SegmentApproximator.h\par \pard\plain 
{\tc\tcl2 \v header/SegmentApproximator.h}
{\xe \v header/SegmentApproximator.h}
{\bkmkstart AAAAAAAAAJ}
{\bkmkend AAAAAAAAAJ}
gehe zur Dokumentation dieser Datei{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00007 {\cf21 #include <vector>}\par
00008 {\cf21 #include <list>}\par
00009 {\cf21 #include <iostream>}\par
00010 {\cf21 #include <math.h>}\par
00011 {\cf21 #include "Point3D.h"}\par
00012 {\cf21 #include "Logging.h"}\par
00013 \par
00014 {\cf17 using namespace }std;\par
00015 \par
00016 {\cf21 #pragma once}\par
00017 \par
00022 {\cf17 class }CSegmentApproximator\par
00023 \{\par
00024 {\cf17 public}:\par
00029     CSegmentApproximator({\cf18 void});\par
00033     ~CSegmentApproximator({\cf18 void});\par
00034 \par
00041     {\cf18 void} approx({\cf17 const} vector<list<CInputPoint3D>>& Segments, CLogging log);\par
00046     {\cf18 void} setmaxDistance({\cf18 double} maxDistanceSource);\par
00051     {\cf18 double} getmaxDistance();\par
00052 \par
00057     vector<list<CInputPoint3D>>& getSegmentsApproxVector();\par
00058 \par
00059 {\cf17 private}:\par
00063     vector<list<CInputPoint3D>> segmentsApprox;\par
00067     {\cf18 double} maxDistance;\par
00068 \par
00077     {\cf18 void} douglasPeuckerRecursive(list<CInputPoint3D>& segment, std::list<CInputPoint3D>::iterator startItr, std::list<CInputPoint3D>::iterator endItr);\par
00078 \};\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/EulerMatrix.cpp-Dateireferenz\par \pard\plain 
{\tc\tcl2 \v src/EulerMatrix.cpp}
{\xe \v src/EulerMatrix.cpp}
{\bkmkstart AAAAAAAABH}
{\bkmkend AAAAAAAABH}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Source Code der Euler Matrix. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "./header/EulerMatrix.h"}\par
{\f2 #include <math.h>}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Ausf\'FChrliche Beschreibung\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Source Code der Euler Matrix. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definiert in Datei {\b EulerMatrix.cpp}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
EulerMatrix.cpp\par \pard\plain 
{\tc\tcl2 \v src/EulerMatrix.cpp}
{\xe \v src/EulerMatrix.cpp}
{\bkmkstart AAAAAAAAAK}
{\bkmkend AAAAAAAAAK}
gehe zur Dokumentation dieser Datei{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00007 {\cf21 #include "./header/EulerMatrix.h"}\par
00008 {\cf21 #include <math.h>}\par
00009 \par
00010 CEulerMatrix::CEulerMatrix({\cf18 void})\par
00011 \{\par
00012     {\cf19 for} ({\cf18 int} i = 0; i < 3; i++)\par
00013     \{\par
00014         {\cf19 for} ({\cf18 int} m = 0; m < 3; m++)\par
00015         \{\par
00016             eulerMatrix[i][m] = 0;                  {\cf20 // eulerMatrix mit 0 initialisieren}\par
00017         \}\par
00018     \}\par
00019 \}\par
00020 \par
00021 CEulerMatrix::CEulerMatrix({\cf18 float} inputMatrix[3][3])\par
00022 \{\par
00023     {\cf19 for} ({\cf18 int} i = 0; i < 3; i++)\par
00024     \{\par
00025         {\cf19 for} ({\cf18 int} m = 0; m < 3; m++)\par
00026         \{\par
00027             eulerMatrix[i][m] = inputMatrix[i][m];  {\cf20 // eulerMatrix mit Startwerten initialisieren}\par
00028         \}\par
00029     \}\par
00030 \}\par
00031 \par
00032 CEulerMatrix::~CEulerMatrix()\par
00033 \{\par
00034 \}\par
00035 \par
00036 \par
00037 {\cf18 void} CEulerMatrix::setMatrix({\cf18 float} inputMatrix[3][3])\par
00038 \{\par
00039     {\cf19 for}({\cf18 int} i = 0; i < 3; i++)\par
00040     \{ \par
00041         {\cf19 for} ({\cf18 int} m = 0; m < 3; m++)\par
00042         \{\par
00043             eulerMatrix[i][m] = inputMatrix[i][m];  {\cf20 // eulerMatrix mit \'C3\'83\'C2\'9Cbergabewerten \'C3\'83\'C2\'BCberschreiben}\par
00044         \}\par
00045     \}\par
00046 \}\par
00047 \par
00048 CEulerMatrix CEulerMatrix::getEulerMatrix()\par
00049 \{\par
00050     {\cf19 return} eulerMatrix;         {\cf20 // EulerMatrix zur\'C3\'BCck geben}\par
00051 \}\par
00052 \par
00053 {\cf18 void} CEulerMatrix::getMatrix({\cf18 float} Matrix[][3])\par
00054 \{\par
00055     {\cf19 for} ({\cf18 int} i = 0; i < 3; i++)\par
00056     \{\par
00057         {\cf19 for} ({\cf18 int} m = 0; m < 3; m++)\par
00058         \{\par
00059             Matrix[i][m] = eulerMatrix[i][m];  {\cf20 // eulerMatrix mit \'EF\'BF\'BDbergabewerten \'EF\'BF\'BDberschreiben}\par
00060         \}\par
00061     \}\par
00062 \}\par
00063 \par
00064 {\cf20 //TODO: Kommentar}\par
00065 CEulerMatrix CEulerMatrix::angels2mat({\cf18 double} A, {\cf18 double} B, {\cf18 double} C)\par
00066 \{\par
00067     {\cf18 float} Matrix[3][3];     {\cf20 // DummyMatrix erstellen}\par
00068 \par
00069     {\cf20 /* Berechnung der Matrix */}\par
00070 \par
00071     Matrix[0][0] = cos(A) * cos(C) - sin(A) * cos(B) * sin(C);\par
00072     Matrix[0][1] = -cos(A) * sin(C) - sin(A) * cos(B) * cos(C);\par
00073     Matrix[0][2] = sin(A) * sin(B);\par
00074 \par
00075     Matrix[1][0] = sin(A) * cos(C) + cos(A) * cos(B) * sin(C);\par
00076     Matrix[1][1] = -sin(A) * sin(C) + cos(A) * cos(B) * cos(C);\par
00077     Matrix[1][2] = -cos(A) * sin(B);\par
00078 \par
00079     Matrix[2][0] = sin(B) * sin(C);\par
00080     Matrix[2][1] = sin(B) * cos(C);\par
00081     Matrix[2][2] = cos(B);\par
00082 \par
00083     CEulerMatrix buffer(Matrix);        {\cf20 // DummyMatrix in DummyEulerMatrix schreiben}\par
00084     {\cf19 return} buffer;                      {\cf20 // Matrix zur\'C3\'BCck geben}\par
00085 \}\par
00086 \par
00087 {\cf20 //TODO: Kommentar}\par
00088 tuple<double , double , double> CEulerMatrix::calculateAngels({\cf18 void})\par
00089 \{\par
00090     {\cf18 double} a, b, c, sin_a, cos_a, sin_b, abs_cos_b, sin_c, cos_c;\par
00091 \par
00092     {\cf20 /*}\par
00093 {\cf20     a == Winkel Alpha}\par
00094 {\cf20     b == Winkel Beta}\par
00095 {\cf20     c == Winkel Gamma}\par
00096 {\cf20 }\par
00097 {\cf20     sin_a == sinus alpha}\par
00098 {\cf20     cos_a == cosinus alpha}\par
00099 {\cf20     sin_b == Matrix[2][0] * -1}\par
00100 {\cf20     abs_cos_b == ??}\par
00101 {\cf20     sin_c == sinus gamma}\par
00102 {\cf20     cos_c == cosinus gamma}\par
00103 {\cf20     */}\par
00104 \par
00105 \par
00106     {\cf20 /* Berechnung von alpha*/}\par
00107     a = atan2(eulerMatrix[1][0], eulerMatrix[0][0]);\par
00108 \par
00109     {\cf20 /* Berechung von beta */}\par
00110     sin_a = sin(a);\par
00111     cos_a = cos(a);\par
00112     sin_b = eulerMatrix[2][0] * -1;\par
00113     abs_cos_b = cos(a) * eulerMatrix[0][0] + sin(a) * eulerMatrix[1][0];\par
00114 \par
00115     b = atan2 (sin_b, abs_cos_b);\par
00116 \par
00117     {\cf20 /* Berechung von gamma */}\par
00118     sin_c =  sin_a * eulerMatrix[0][2] - cos_a * eulerMatrix[1][2];\par
00119     cos_c = -sin_a * eulerMatrix[0][1] + cos_a * eulerMatrix[1][1];\par
00120 \par
00121     c = atan2(sin_c, cos_c);\par
00122 \par
00123     {\cf20 /* Bogenmass in Gradmass umrechnen */}\par
00124     a = a * 180 / M_PI;\par
00125     b = b * 180 / M_PI;\par
00126     c = c * 180 / M_PI;\par
00127 \par
00128 \par
00129     {\cf19 return} make_tuple(a, b, c);     {\cf20 // R\'C3\'BCckgabe der Winkel}\par
00130 \}\par
00131 \par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/GUI.cpp-Dateireferenz\par \pard\plain 
{\tc\tcl2 \v src/GUI.cpp}
{\xe \v src/GUI.cpp}
{\bkmkstart AAAAAAAABI}
{\bkmkend AAAAAAAABI}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "./header/GUI.h"}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
GUI.cpp\par \pard\plain 
{\tc\tcl2 \v src/GUI.cpp}
{\xe \v src/GUI.cpp}
{\bkmkstart AAAAAAAAAL}
{\bkmkend AAAAAAAAAL}
gehe zur Dokumentation dieser Datei{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "./header/GUI.h"}\par
00002 \par
00003 CGUI::CGUI()\par
00004 \{\}\par
00005 \par
00006 CGUI::~CGUI()\par
00007 \{\}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/InputParameter.cpp-Dateireferenz\par \pard\plain 
{\tc\tcl2 \v src/InputParameter.cpp}
{\xe \v src/InputParameter.cpp}
{\bkmkstart AAAAAAAABJ}
{\bkmkend AAAAAAAABJ}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Source File Daten Einlesen. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "./header/InputParameter.h"}\par
{\f2 #include "./header/Point3D.h"}\par
{\f2 #include "./header/EulerMatrix.h"}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Ausf\'FChrliche Beschreibung\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Source File Daten Einlesen. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definiert in Datei {\b InputParameter.cpp}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
InputParameter.cpp\par \pard\plain 
{\tc\tcl2 \v src/InputParameter.cpp}
{\xe \v src/InputParameter.cpp}
{\bkmkstart AAAAAAAAAM}
{\bkmkend AAAAAAAAAM}
gehe zur Dokumentation dieser Datei{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00007 {\cf21 #include "./header/InputParameter.h"}\par
00008 {\cf21 #include "./header/Point3D.h"}\par
00009 {\cf21 #include "./header/EulerMatrix.h"}\par
00010 \par
00011 {\cf20 /* CInputParamameter mir \'DCbergabewerten initialisieren */} \par
00012 CInputParameter::CInputParameter({\cf18 double} initSpeed, {\cf18 bool} initSpeedManual, {\cf18 bool} initOrientationManual, {\cf18 double} initA, {\cf18 double} initB, {\cf18 double} initC)\par
00013 \{\par
00014     speed = initSpeed;\par
00015     speedManual = initSpeedManual;\par
00016     orientationManual = initOrientationManual;\par
00017     A = initA;\par
00018     B = initB;\par
00019     C = initC;\par
00020 \par
00021 \}\par
00022 \par
00023 {\cf20 /* CInputParameter mit 0 initialisieren */}\par
00024 CInputParameter::CInputParameter({\cf18 void})\par
00025 \{\par
00026     speed = 0.1;\par
00027     A = 0;\par
00028     B = 75;\par
00029     C = 0;\par
00030     speedManual = {\cf17 true},\par
00031     orientationManual = {\cf17 true};\par
00032 \par
00033 \}\par
00034 \par
00035 CInputParameter::~CInputParameter({\cf18 void})\par
00036 \{\par
00037 \par
00038 \}\par
00039 \par
00040 \par
00041 {\cf20 /* Einstellung f\'FCr Orientierung und Winkel setzten */}\par
00042 {\cf18 void} CInputParameter::setOrientation({\cf18 bool} initOrientationManual, {\cf18 double} initA, {\cf18 double} initB, {\cf18 double} initC)\par
00043 \{\par
00044     orientationManual = initOrientationManual;\par
00045     A = initA;\par
00046     B = initB;\par
00047     C = initC;\par
00048 \}\par
00049 \par
00050 {\cf20 /* Einstellung f\'FCr Geschwindigkeit und Geschwindigkeit setzen */}\par
00051 {\cf18 void} CInputParameter::setSpeed({\cf18 double} initSpeed, {\cf18 bool} initSpeedManual)\par
00052 \{\par
00053     speed = initSpeed;\par
00054     speedManual = initSpeedManual;\par
00055 \}\par
00056 \par
00057 vector<list<CInputPoint3D>>& CInputParameter::getPath()\par
00058 \{\par
00059     {\cf19 return} initialPath;     {\cf20 // Path zur\'FCck geben}\par
00060 \}\par
00061 \par
00062 {\cf18 double} CInputParameter::getSpeed({\cf18 void})\par
00063 \{\par
00064     {\cf19 return} speed;           {\cf20 // Geschwindigkeit zur\'FCck geben}\par
00065 \}\par
00066 \par
00067 {\cf18 bool} CInputParameter::getSpeedManual({\cf18 void})\par
00068 \{\par
00069     {\cf19 return} speedManual;             {\cf20 // Vorgew\'E4hlte Einstellung f\'FCr Geschwindigkeit zur\'FCck geben}\par
00070 \}\par
00071 \par
00072 {\cf18 bool} CInputParameter::getOrientationManual({\cf18 void})\par
00073 \{\par
00074     {\cf19 return} orientationManual;       {\cf20 // Vorgew\'E4hlte Einstellung f\'FCr Orientierung zur\'FCck geben}\par
00075 \}\par
00076 \par
00077 tuple <double, double, double> CInputParameter::getAngles({\cf18 void})\par
00078 \{\par
00079     {\cf19 return} make_tuple(A, B, C);     {\cf20 // Winkel zur\'FCck geben}\par
00080 \}\par
00081 \par
00082 \par
00083 {\cf20 /* Eingabedatei \'F6ffnen */} \par
00084 {\cf18 void} CInputParameter::openFile({\cf18 string} path)\par
00085 \{\par
00086     ifstream fin(path);\par
00087     CInputPoint3D tmpPoint;     {\cf20 // Zwischenspeicher zum konvertieren von tmpEuler in Point3D}\par
00088     CEulerMatrix tmpEuler;      {\cf20 // Zwischenspeicher zum konverteiren von DummyMatrix in EulerMatrix}\par
00089     {\cf18 double} x, y, z;             {\cf20 // Punktkoordinaten}\par
00090     {\cf18 double} x_prev = 0, y_prev = 0, z_prev = 0;      {\cf20 // Zwischenspeicher f\'FCr Punktkoordinaten}\par
00091     {\cf18 double} timestamp;           {\cf20 // Zeitstempel}\par
00092     {\cf18 int} segmentCount = -1;      {\cf20 // Segmentz\'E4hler}\par
00093     {\cf18 float} dummyMatrix[3][3];    {\cf20 // DummyMatrix zum speichern}\par
00094 \par
00095 \par
00096     {\cf19 if} (!fin.is_open())\par
00097     \{\par
00098         cerr << {\cf22 "Datei konnte nicht ge\'F6ffnet werden"} << endl;       {\cf20 // Fehler Datei konnte nicht ge\'F6ffnet werden.}\par
00099     \}\par
00100     {\cf18 string} line;\par
00101 \par
00102     {\cf19 while}(getline(fin, line))\par
00103     \{\par
00104         std::istringstream sStream (line);\par
00105         sStream >> timestamp >> x >> y >> z >> dummyMatrix[0][0] >> dummyMatrix[0][1] >> dummyMatrix[0][2]                                      {\cf20 // Zeile in die einzelnen Parameter zerlegen }\par
00106             >> dummyMatrix[1][0] >> dummyMatrix[1][1] >> dummyMatrix[1][2] >> dummyMatrix[2][0] >> dummyMatrix[2][1] >> dummyMatrix[2][2];      {\cf20 // und in DummyMatrix bzw. Variablen abspeichern}\par
00107 \par
00108         tmpEuler.setMatrix(dummyMatrix);                                    {\cf20 // DummyMatrix[3][3] in EulerMatrix speichern                           }\par
00109         tmpPoint.setPoint(timestamp, x, y, z, tmpEuler.getEulerMatrix());   {\cf20 // Variablen und EulerWinkel in CPoint3D speichern}\par
00110 \par
00111         {\cf19 if} (detectJump(tmpPoint, x_prev, y_prev, z_prev)) {\cf20 // if there is a jump in the data, start da new segment }\par
00112         \{\par
00113             segmentCount++;                                 {\cf20 // neues Segement anlegen}\par
00114             initialPath.push_back(list<CInputPoint3D>());   {\cf20 // Punkt in Segent speichern}\par
00115         \}\par
00116 \par
00117         initialPath[segmentCount].push_back(tmpPoint);      {\cf20 // Punkt in bestehendes Segment abspeichern}\par
00118 \par
00119         x_prev = x;     {\cf20 // X-Wert zwischenspeichern}\par
00120         y_prev = y;     {\cf20 // Y-Wert zwischenspeichern}\par
00121         z_prev = z;     {\cf20 // Z-Wert zwischenspeichern}\par
00122     \}\par
00123     fin.close();        {\cf20 // Datei schlie\'DFen}\par
00124 \}\par
00125 \par
00126 {\cf18 bool} CInputParameter::detectJump(CInputPoint3D p, {\cf18 double} x_prev, {\cf18 double}  y_prev, {\cf18 double} z_prev)\par
00127 \{\par
00128     {\cf19 if}(abs(p.getX() - x_prev) > difference)             {\cf20 // Abstand zwischen Punkten gr\'F6\'DFer max Differenz??}\par
00129         {\cf19 return} {\cf17 true};\par
00130     {\cf19 else} {\cf19 if}(abs(p.getY() - y_prev) > difference)        {\cf20 // Abstand zwischen Punkten gr\'F6\'DFer max Differenz??}\par
00131         {\cf19 return} {\cf17 true};\par
00132     {\cf19 else} {\cf19 if}(abs(p.getZ() - z_prev) > difference)            {\cf20 // Abstand zwischen Punkten gr\'F6\'DFer max Differenz??}\par
00133         {\cf19 return} {\cf17 true};\par
00134     {\cf19 else}\par
00135         {\cf19 return} {\cf17 false};\par
00136 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/Line3D.cpp-Dateireferenz\par \pard\plain 
{\tc\tcl2 \v src/Line3D.cpp}
{\xe \v src/Line3D.cpp}
{\bkmkstart AAAAAAAABK}
{\bkmkend AAAAAAAABK}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Source File Line3D. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "./header/Line3D.h"}\par
{\f2 #include "./header/Point3D.h"}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Ausf\'FChrliche Beschreibung\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Source File Line3D. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definiert in Datei {\b Line3D.cpp}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Line3D.cpp\par \pard\plain 
{\tc\tcl2 \v src/Line3D.cpp}
{\xe \v src/Line3D.cpp}
{\bkmkstart AAAAAAAAAN}
{\bkmkend AAAAAAAAAN}
gehe zur Dokumentation dieser Datei{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00007 {\cf21 #include "./header/Line3D.h"}\par
00008 {\cf21 #include "./header/Point3D.h"}\par
00009 \par
00010 CLine3D::CLine3D({\cf18 void})\par
00011 \{\par
00012 \}\par
00013 \par
00014 {\cf20 /* initialisieren mit 2 Punkten*/}\par
00015 CLine3D::CLine3D(CPoint3D P1, CPoint3D P2)\par
00016 \{\par
00017     p1 = P1;\par
00018     p2 = P2;\par
00019 \}\par
00020 \par
00021 CLine3D::~CLine3D({\cf18 void})\par
00022 \{\par
00023 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/Logging.cpp-Dateireferenz\par \pard\plain 
{\tc\tcl2 \v src/Logging.cpp}
{\xe \v src/Logging.cpp}
{\bkmkstart AAAAAAAABL}
{\bkmkend AAAAAAAABL}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Source File Logging. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "header/Logging.h"}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Ausf\'FChrliche Beschreibung\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Source File Logging. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definiert in Datei {\b Logging.cpp}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Logging.cpp\par \pard\plain 
{\tc\tcl2 \v src/Logging.cpp}
{\xe \v src/Logging.cpp}
{\bkmkstart AAAAAAAAAO}
{\bkmkend AAAAAAAAAO}
gehe zur Dokumentation dieser Datei{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00007 {\cf21 #include "header/Logging.h"}\par
00008 \par
00009 {\cf20 /* Step mit 0 initialisiren */}\par
00010 CLogging::CLogging({\cf18 void})\par
00011 \{\par
00012     step = 0;\par
00013 \}\par
00014 \par
00015 {\cf20 /* Path mit Parameter initialisieren*/}\par
00016 CLogging::CLogging({\cf18 string} Path)\par
00017 \{\par
00018     path = Path;\par
00019 \}\par
00020 \par
00021 CLogging::~CLogging({\cf18 void})\par
00022 \{\par
00023 \par
00024 \}\par
00025 \par
00026 {\cf18 void} CLogging::setStep({\cf18 int} Step)\par
00027 \{\par
00028     step = Step;    {\cf20 // Step setzen}\par
00029 \}\par
00030 \par
00031 {\cf18 void} CLogging::logData(vector<list<CInputPoint3D>>& sourcePath)\par
00032 \{\par
00033     {\cf18 string} filepath;            {\cf20 // file Pfad}\par
00034     {\cf18 float} dummyMatrix[3][3];    {\cf20 // dummyMatrix zum Zwischenspeichern}\par
00035     CEulerMatrix tmpEuler;      {\cf20 // CEulerMatrix zum Zwischenspeichern}\par
00036 \par
00037     filepath = path + {\cf22 "/"} + {\cf22 "0"} + std::to_string(step) + {\cf22 "_path.csv"};\par
00038 \par
00039     FILE* fid = fopen(filepath.c_str(), {\cf22 "w"});       {\cf20 // file \'F6ffnen}\par
00040 \par
00041     {\cf19 if} (fid == NULL)\par
00042     \{\par
00043         cerr << {\cf22 "ERROR - Can NOT write to output file!\\n"};      {\cf20 // Fehler beim file \'F6ffnen}\par
00044         {\cf19 return};\par
00045     \}\par
00046 \par
00047     {\cf19 for} ({\cf18 size_t} s = 0; s < sourcePath.size(); s++) {\cf20 //for all segments}\par
00048     \{\par
00049         list<CInputPoint3D>::iterator itr = sourcePath[s].begin();\par
00050 \par
00051         tmpEuler = itr->getEulerMatrix();\par
00052         tmpEuler.getMatrix(dummyMatrix);\par
00053 \par
00054         {\cf20 /* Ausgeben der Punkte mit dummyMatrix */}\par
00055         {\cf19 for} (; itr != sourcePath[s].end(); itr++) {\cf20 //for all points in the segment}\par
00056         \{\par
00057             fprintf(fid, {\cf22 "%f %f %f %f %f %f %f %f %f %f %f %f %f\\n"}, ({\cf18 double})itr->getTime(), ({\cf18 double})itr->getX(), ({\cf18 double})itr->getY(), ({\cf18 double})itr->getZ(),\par
00058                 dummyMatrix[0][0], dummyMatrix[0][1], dummyMatrix[0][2],\par
00059                 dummyMatrix[1][0], dummyMatrix[1][1], dummyMatrix[1][2],\par
00060                 dummyMatrix[2][0], dummyMatrix[2][1], dummyMatrix[2][2]);\par
00061         \}\par
00062 \par
00063         itr--;\par
00064     \}\par
00065 \}\par
00066 \par
00067 {\cf18 void} CLogging::logData(vector<CInputPoint3D>& sourcePath)\par
00068 \{\par
00069     {\cf18 string} filepath;            {\cf20 // file Pfad}\par
00070     {\cf18 float} dummyMatrix[3][3];    {\cf20 // dummyMatrix zum Zwischenspeichern}\par
00071     CEulerMatrix tmpEuler;      {\cf20 // CEulerMatrix zum Zwischenspeichern}\par
00072 \par
00073     filepath = path + {\cf22 "/"} + {\cf22 "0"} + std::to_string(step) + {\cf22 "_path.csv"};\par
00074 \par
00075     FILE* fid = fopen(filepath.c_str(), {\cf22 "w"});   {\cf20 // file \'F6ffnen}\par
00076 \par
00077     {\cf19 if} (fid == NULL)\par
00078     \{\par
00079         cerr << {\cf22 "ERROR - Can NOT write to output file!\\n"};  {\cf20 // Fehler beim file \'F6ffnen}\par
00080         {\cf19 return};\par
00081     \}\par
00082 \par
00083     {\cf20 /* Ausgeben der Punkte mit dummyMatrix */}\par
00084     {\cf19 for} ({\cf18 size_t} s = 0; s < sourcePath.size(); s++) {\cf20 //for all points in the vector}\par
00085     \{\par
00086         tmpEuler.getMatrix(dummyMatrix);\par
00087 \par
00088         fprintf(fid, {\cf22 "%f %f %f %f %f %f %f %f %f %f %f %f %f\\n"}, ({\cf18 double})sourcePath[s].getTime(), \par
00089             ({\cf18 double})sourcePath[s].getX(), ({\cf18 double})sourcePath[s].getY(), ({\cf18 double})sourcePath[s].getZ(),\par
00090             dummyMatrix[0][0], dummyMatrix[0][1], dummyMatrix[0][2],\par
00091             dummyMatrix[1][0], dummyMatrix[1][1], dummyMatrix[1][2],\par
00092             dummyMatrix[2][0], dummyMatrix[2][1], dummyMatrix[2][2]);\par
00093     \}\par
00094 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/MeanFilter.cpp-Dateireferenz\par \pard\plain 
{\tc\tcl2 \v src/MeanFilter.cpp}
{\xe \v src/MeanFilter.cpp}
{\bkmkstart AAAAAAAABM}
{\bkmkend AAAAAAAABM}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Source File gleitender Mittelwertfilter. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "./header/MeanFilter.h"}\par
{\f2 #include "./header/Logging.h"}\par
{\f2 #include <math.h>}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Ausf\'FChrliche Beschreibung\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Source File gleitender Mittelwertfilter. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definiert in Datei {\b MeanFilter.cpp}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MeanFilter.cpp\par \pard\plain 
{\tc\tcl2 \v src/MeanFilter.cpp}
{\xe \v src/MeanFilter.cpp}
{\bkmkstart AAAAAAAAAP}
{\bkmkend AAAAAAAAAP}
gehe zur Dokumentation dieser Datei{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00007 {\cf21 #include "./header/MeanFilter.h"}\par
00008 {\cf21 #include "./header/Logging.h"}\par
00009 {\cf21 #include <math.h>}\par
00010 \par
00011 CMeanFilter::CMeanFilter()\par
00012 \{\par
00013     windowSize = 3;         {\cf20 // initialisieren mit Standardfenstergr\'F6\'DFe 3}\par
00014 \}\par
00015 \par
00016 CMeanFilter::CMeanFilter({\cf18 int} Window)\par
00017 \{\par
00018     windowSize = Window;    {\cf20 // initialisieren der Fenstergr\'F6\'DFe mit \'DCbergabewert}\par
00019 \}\par
00020 \par
00021 CMeanFilter::~CMeanFilter()\par
00022 \{\par
00023 \}\par
00024 \par
00025 {\cf18 void} CMeanFilter::setWindowSize({\cf18 int} Window)\par
00026 \{\par
00027     windowSize = Window;    {\cf20 // setzen der Fenstergr\'F6\'DFe mit \'DCbergabewert}\par
00028 \}\par
00029 \par
00030 {\cf18 int} CMeanFilter::getWindowSize()\par
00031 \{\par
00032     {\cf19 return} windowSize;      {\cf20 // Fenstergr\'F6\'DFe zur\'FCck geben}\par
00033 \}\par
00034 \par
00035 vector<list<CInputPoint3D>>& CMeanFilter::getPath()\par
00036 \{\par
00037     {\cf19 return} meanPath;        {\cf20 // Mittelwert zur\'FCck geben}\par
00038 \}\par
00039 \par
00040 {\cf18 void} CMeanFilter::mean(vector<list<CInputPoint3D>>& sourcePath, CLogging log)\par
00041 \{\par
00042     list<CInputPoint3D> dummyList;\par
00043     {\cf19 for} ({\cf18 size_t} s = 0; s < sourcePath.size(); s++)\par
00044     \{\par
00045         dummyList = calculateMean(sourcePath[s]);\par
00046         meanPath.push_back(dummyList);\par
00047     \}\par
00048     log.setStep(2);\par
00049     log.logData(meanPath);\par
00050 \}\par
00051 \par
00052 list<CInputPoint3D> CMeanFilter::calculateMean(list<CInputPoint3D>& segment)\par
00053 \{\par
00054     {\cf18 double} sumX = 0, sumY = 0, sumZ = 0;    {\cf20 // Variablen zum Speichern der Summe}\par
00055     {\cf18 double} div = 0;                         {\cf20 // Variable zum Speichern des Teilers}\par
00056 \par
00057     CInputPoint3D p;        {\cf20 //Point3D zum Zwischenspeichern}\par
00058 \par
00059     {\cf18 size_t} inputSize = segment.size();\par
00060 \par
00061     list<CInputPoint3D>::iterator it = segment.begin();\par
00062     list<CInputPoint3D> newSegment;\par
00063 \par
00064     {\cf19 for} ({\cf18 size_t} i = 0; i < inputSize - windowSize; ++i) {\cf20 //For each element in the Segment}\par
00065     \{\par
00066         sumX = 0, sumY = 0, sumZ = 0;   {\cf20 // Variablen zum Speichern der Summe auf 0 zur\'FCck setzen}\par
00067         div = 0;                        {\cf20 // Variable zum Speichern des Teilers auf 0 zur\'FCck setzen}\par
00068         p.setTime(it->getTime());\par
00069         p.setEulerMatrix(it->getEulerMatrix());\par
00070         {\cf19 for} ({\cf18 size_t} j = i; j < i + windowSize; ++j) {\cf20 // Build the sums for the three points}\par
00071         \{\par
00072             sumX += it->getX();\par
00073             sumY += it->getY();\par
00074             sumZ += it->getZ();\par
00075             div++;\par
00076             it++;\par
00077         \}\par
00078         {\cf19 for} ({\cf18 size_t} index = windowSize; index > 0; index--) {\cf20 // Pain, the iterator has to be set back}\par
00079         \{\par
00080             it--;\par
00081         \}\par
00082         p.set(sumX / div, sumY / div, sumZ / div); {\cf20 // Calculate smoothed values}\par
00083         {\cf19 if}(it != segment.end())\par
00084             it++;\par
00085         newSegment.push_back(p);\par
00086     \}\par
00087     {\cf19 return} newSegment;\par
00088 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/PathBuilder.cpp-Dateireferenz\par \pard\plain 
{\tc\tcl2 \v src/PathBuilder.cpp}
{\xe \v src/PathBuilder.cpp}
{\bkmkstart AAAAAAAABN}
{\bkmkend AAAAAAAABN}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Source File Segmente zu Pfad. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "./header/PathBuilder.h"}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Ausf\'FChrliche Beschreibung\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Source File Segmente zu Pfad. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definiert in Datei {\b PathBuilder.cpp}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
PathBuilder.cpp\par \pard\plain 
{\tc\tcl2 \v src/PathBuilder.cpp}
{\xe \v src/PathBuilder.cpp}
{\bkmkstart AAAAAAAAAQ}
{\bkmkend AAAAAAAAAQ}
gehe zur Dokumentation dieser Datei{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00007 {\cf21 #include "./header/PathBuilder.h"}\par
00008 \par
00009 CPathBuilder::CPathBuilder({\cf18 void})\par
00010 \{\par
00011 \}\par
00012 \par
00013 \par
00014 CPathBuilder::~CPathBuilder({\cf18 void})\par
00015 \{\par
00016 \}\par
00017 \par
00018 vector<CInputPoint3D>& CPathBuilder::getPath()\par
00019 \{\par
00020     {\cf19 return} path;\par
00021 \}\par
00022 \par
00023 {\cf18 void} CPathBuilder::createPath(vector<list<CInputPoint3D>>& segments, CLogging log)\par
00024 \{\par
00025     CInputPoint3D point; {\cf20 //startpoint}\par
00026 \par
00027     {\cf19 for} ({\cf18 size_t} s = 0; s < segments.size(); s++) {\cf20 //for all segments}\par
00028     \{\par
00029         list<CInputPoint3D>::iterator itr = segments[s].begin();\par
00030 \par
00031         {\cf19 for} (; itr != segments[s].end(); itr++) {\cf20 //for all points in the segment}\par
00032         \{\par
00033             point.set(({\cf18 double})itr->getX(), ({\cf18 double})itr->getY(), ({\cf18 double})itr->getZ());\par
00034             point.setTime(itr->getTime());\par
00035             point.setEulerMatrix(itr->getEulerMatrix());\par
00036             path.push_back(point);\par
00037         \}\par
00038 \par
00039         itr--;\par
00040     \}\par
00041 \par
00042     log.setStep(4);\par
00043     log.logData(path);\par
00044 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/Point3D.cpp-Dateireferenz\par \pard\plain 
{\tc\tcl2 \v src/Point3D.cpp}
{\xe \v src/Point3D.cpp}
{\bkmkstart AAAAAAAABO}
{\bkmkend AAAAAAAABO}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Source File Punkte. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "./header/Point3D.h"}\par
{\f2 #include "./header/Line3D.h"}\par
{\f2 #include <math.h>}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Ausf\'FChrliche Beschreibung\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Source File Punkte. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definiert in Datei {\b Point3D.cpp}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Point3D.cpp\par \pard\plain 
{\tc\tcl2 \v src/Point3D.cpp}
{\xe \v src/Point3D.cpp}
{\bkmkstart AAAAAAAAAR}
{\bkmkend AAAAAAAAAR}
gehe zur Dokumentation dieser Datei{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00007 {\cf21 #include "./header/Point3D.h"}\par
00008 {\cf21 #include "./header/Line3D.h"}\par
00009 {\cf21 #include <math.h>}\par
00010 \par
00011 \par
00012 {\cf20 /* initialisieren des Punktes mit 0-Werten */}\par
00013 CPoint3D::CPoint3D({\cf18 void})\par
00014 \{\par
00015     x = 0;\par
00016     y = 0;\par
00017     z = 0;\par
00018 \}\par
00019 \par
00020 {\cf20 /* initialiseren des Punktes mit Koordinaten */}\par
00021 CPoint3D::CPoint3D({\cf18 double} X, {\cf18 double} Y, {\cf18 double} Z)\par
00022 \{\par
00023     x = X;\par
00024     y = Y;\par
00025     z = Z;\par
00026 \}\par
00027 \par
00028 CPoint3D::~CPoint3D({\cf18 void})\par
00029 \{\par
00030 \}\par
00031 \par
00032 {\cf18 double} CPoint3D::getX({\cf18 void})\par
00033 \{\par
00034     {\cf19 return} x;   {\cf20 // X-Koordinate zur\'FCck geben}\par
00035 \}\par
00036 \par
00037 {\cf18 double} CPoint3D::getY({\cf18 void})\par
00038 \{\par
00039     {\cf19 return} y;   {\cf20 // Y-Koordinate zur\'FCck geben}\par
00040 \}\par
00041 \par
00042 {\cf18 double} CPoint3D::getZ({\cf18 void})\par
00043 \{\par
00044     {\cf19 return} z;   {\cf20 // Z-Koordinate zur\'FCck geben}\par
00045 \}\par
00046 \par
00047 {\cf18 void} CPoint3D::setX({\cf18 double} X)\par
00048 \{\par
00049     x = X;  {\cf20 // X-Koordinate setzen}\par
00050 \}\par
00051 \par
00052 {\cf18 void} CPoint3D::setY({\cf18 double} Y)\par
00053 \{\par
00054     y = Y;  {\cf20 // Y-Koordinate setzen}\par
00055 \}\par
00056 \par
00057 {\cf18 void} CPoint3D::setZ({\cf18 double} Z)\par
00058 \{\par
00059     z = Z;  {\cf20 // Z-Koordinate setzen}\par
00060 \}\par
00061 \par
00062 {\cf20 /* X-, Y- und Z-Koordinate setzen */}\par
00063 {\cf18 void} CPoint3D::set({\cf18 double} X, {\cf18 double} Y, {\cf18 double} Z)\par
00064 \{\par
00065     x = X;  {\cf20 // X-Koordinate setzen}\par
00066     y = Y;  {\cf20 // Y-Koordinate setzen}\par
00067     z = Z;  {\cf20 // Z-Koordinate setzen}\par
00068 \}   \par
00069 \par
00070 {\cf20 /* Distanz zwischen Punkt und \'FCbergebenen Punkt berechnen */}\par
00071 {\cf18 double} CPoint3D::distanceTo(CPoint3D point)\par
00072 \{\par
00073     {\cf19 return} sqrt(pow(({\cf18 double})(x - ({\cf18 double})point.getX()), 2) + pow(({\cf18 double})(y - ({\cf18 double})point.getY()), 2) + pow(({\cf18 double})(z - ({\cf18 double})point.getZ()), 2));  {\cf20 //  Pythagoras 3D}\par
00074 \}\par
00075 \par
00076 {\cf18 double} CPoint3D::distanceTo(CLine3D line)\par
00077 \{\par
00078     {\cf18 double} bx, by, bz, rv_sq, dist, vp1, vp2, vp3;          {\cf20 // Variablen Anlegen}\par
00079 \par
00080     {\cf20 /*}\par
00081 {\cf20     Vermessen wird der Punkt selbst}\par
00082 {\cf20 }\par
00083 {\cf20     bx, by, bz      == Vektordifferenz}\par
00084 {\cf20     rv_sq           == Betrag des Linienvektors}\par
00085 {\cf20     dist            == Distanz von Punkt zu Linie}\par
00086 {\cf20     vp1, vp2, vp3   == Vektorprodukte}\par
00087 {\cf20     */}\par
00088 \par
00089     {\cf18 int} rvx = line.p1.x - line.p2.x;        {\cf20 // Parameter X des Linienvektor berechnen}\par
00090     {\cf18 int} rvy = line.p1.y - line.p2.y;        {\cf20 // Parameter Y des Linienvektor berechnen}\par
00091     {\cf18 int} rvz = line.p1.z - line.p2.z;        {\cf20 // Parameter Z des Linienvektor berechnen}\par
00092 \par
00093     rv_sq = sqrt((({\cf18 double})rvx * ({\cf18 double})rvx) + (({\cf18 double})rvy * ({\cf18 double})rvy) + (({\cf18 double})rvz * ({\cf18 double})rvz));      {\cf20 // Betrag des Linienvektor berechnen}\par
00094 \par
00095     bx = x - (double)line.p1.x;             {\cf20 // X(Punkt) - X(Aufpunkt) }\par
00096     by = y - (double)line.p1.y;             {\cf20 // Y(Punkt) - Y(Aufpunkt)}\par
00097     bz = z - (double)line.p1.z;             {\cf20 // Z(Punkt) - Z(Aufpunkt)}\par
00098 \par
00099     vp1 = by * rvz - bz * rvy;              {\cf20 // Parameter X Vektorprodukt}\par
00100     vp2 = bz * rvx - bx * rvz;              {\cf20 // Parameter Y Vektorprodukt}\par
00101     vp3 = bx * rvy - by * rvx;              {\cf20 // Parameter Z Vektorprodukt}\par
00102 \par
00103     dist = sqrt(vp1 * vp1 + vp2 * vp2 + vp3 * vp3) / rv_sq; {\cf20 // Betrag des Vektors berechnen}\par
00104 \par
00105     {\cf19 return} dist;\par
00106 \}\par
00107 \par
00108 {\cf20 // InputPoint3D}\par
00109 \par
00110 CInputPoint3D::CInputPoint3D({\cf18 void}) : CPoint3D()\par
00111 \{\par
00112     timestamp = 0;      {\cf20 // Zeitstempel mit 0 initialisieren}\par
00113 \}\par
00114 \par
00115 {\cf20 /* Initialisieren des Punktes mit Parameter */}\par
00116 CInputPoint3D::CInputPoint3D({\cf18 double} X, {\cf18 double} Y, {\cf18 double} Z, {\cf18 double} Timestamp, CEulerMatrix Matrix)\par
00117 \{\par
00118     x = X;\par
00119     y = Y;\par
00120     z = Z;\par
00121     timestamp = Timestamp;\par
00122     orientationMatrix = Matrix;\par
00123 \}\par
00124 \par
00125 CInputPoint3D::~CInputPoint3D({\cf18 void})\par
00126 \{\par
00127 \}\par
00128 \par
00129 {\cf18 void} CInputPoint3D::setEulerMatrix(CEulerMatrix orientation)\par
00130 \{\par
00131     orientationMatrix = orientation;    {\cf20 // EulerMatrix setzen}\par
00132 \}\par
00133 \par
00134 \par
00135 {\cf18 void} CInputPoint3D::setPoint({\cf18 double} time, {\cf18 double} X, {\cf18 double} Y, {\cf18 double} Z, CEulerMatrix orientation)\par
00136 \{\par
00137     setTime(time);  {\cf20 // Zeitstempel setzen}\par
00138     set(X, Y, Z);   {\cf20 // setze Punkt-Koordinaten}\par
00139     setEulerMatrix(orientation); {\cf20 // EulerMatrix setzen}\par
00140 \}\par
00141 \par
00142 {\cf18 void} CInputPoint3D::setTime({\cf18 double} time)\par
00143 \{\par
00144     timestamp = time;   {\cf20 // Zeitstempel setzen}\par
00145 \}\par
00146 \par
00147 CEulerMatrix CInputPoint3D::getEulerMatrix()\par
00148 \{\par
00149     {\cf19 return} orientationMatrix;   {\cf20 // R\'FCckgabe der EulerMatrix}\par
00150 \}\par
00151 \par
00152 {\cf18 double} CInputPoint3D::getTime()\par
00153 \{\par
00154     {\cf19 return} timestamp;       {\cf20 // R\'FCckgabe des Zeitstempel}\par
00155 \}\par
00156 \par
00157 {\cf20 // OutputPoint3D}\par
00158 {\cf20 /* Punkt mit 0 initialisieren */}\par
00159 COutputPoint3D::COutputPoint3D({\cf18 void}) : CPoint3D()\par
00160 \{\par
00161     speed = 0;\par
00162     a = 0;\par
00163     b = 0;\par
00164     c = 0;\par
00165 \}\par
00166 \par
00167 {\cf20 /* Punkt mit Parameter initialisieren*/}\par
00168 COutputPoint3D::COutputPoint3D({\cf18 double} Speed, {\cf18 double} X, {\cf18 double} Y, {\cf18 double} Z, {\cf18 double} A, {\cf18 double} B, {\cf18 double} C)\par
00169 \{\par
00170     speed = Speed;\par
00171     a = A;\par
00172     b = B;\par
00173     c = C;\par
00174     x = X;\par
00175     y = Y;\par
00176     z = Z;\par
00177 \}\par
00178 \par
00179 COutputPoint3D::~COutputPoint3D({\cf18 void})\par
00180 \{\par
00181 \par
00182 \}\par
00183 \par
00184 {\cf18 double} COutputPoint3D::getA({\cf18 void})\par
00185 \{\par
00186     {\cf19 return} a;   {\cf20 // R\'FCckgabe Winkel alpha}\par
00187 \}\par
00188 \par
00189 {\cf18 double} COutputPoint3D::getB({\cf18 void})\par
00190 \{\par
00191     {\cf19 return} b;   {\cf20 // R\'FCckgabe Winkel beta}\par
00192 \}\par
00193 \par
00194 {\cf18 double} COutputPoint3D::getC({\cf18 void})\par
00195 \{\par
00196     {\cf19 return} c;   {\cf20 // R\'FCckgabe Winkel gamma}\par
00197 \}\par
00198 \par
00199 {\cf18 double} COutputPoint3D::getSpeed({\cf18 void})\par
00200 \{\par
00201     {\cf19 return} speed;   {\cf20 // R\'FCckgabe Geschwindigkeit}\par
00202 \}\par
00203 \par
00204 {\cf18 void} COutputPoint3D::setA({\cf18 double} A)\par
00205 \{\par
00206     a = A;      {\cf20 // setze Winkel alpha}\par
00207 \}\par
00208 \par
00209 {\cf18 void} COutputPoint3D::setB({\cf18 double} B)\par
00210 \{\par
00211     b = B;      {\cf20 // setze Winkel beta}\par
00212 \}\par
00213 \par
00214 {\cf18 void} COutputPoint3D::setC({\cf18 double} C)\par
00215 \{\par
00216     c = C;      {\cf20 // setze Winkel gamma}\par
00217 \}\par
00218 \par
00219 {\cf18 void} COutputPoint3D::setSpeed({\cf18 double} Speed)\par
00220 \{\par
00221     speed = Speed;      {\cf20 // setze Geschwindigkeit}\par
00222 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/RobCodeGenerator.cpp-Dateireferenz\par \pard\plain 
{\tc\tcl2 \v src/RobCodeGenerator.cpp}
{\xe \v src/RobCodeGenerator.cpp}
{\bkmkstart AAAAAAAABP}
{\bkmkend AAAAAAAABP}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Source File Roboter Code Erstellung. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "./header/RobCodeGenerator.h"}\par
{\f2 #include "./header/Point3D.h"}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Ausf\'FChrliche Beschreibung\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Source File Roboter Code Erstellung. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definiert in Datei {\b RobCodeGenerator.cpp}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
RobCodeGenerator.cpp\par \pard\plain 
{\tc\tcl2 \v src/RobCodeGenerator.cpp}
{\xe \v src/RobCodeGenerator.cpp}
{\bkmkstart AAAAAAAAAS}
{\bkmkend AAAAAAAAAS}
gehe zur Dokumentation dieser Datei{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00007 {\cf21 #include "./header/RobCodeGenerator.h"}\par
00008 {\cf21 #include "./header/Point3D.h"}\par
00009 \par
00010 {\cf20 /* CRobCodeGenerator mit 0 initialiseren */}\par
00011 CRobCodeGenerator::CRobCodeGenerator({\cf18 void})\par
00012 \{\par
00013     speed = 0;\par
00014     speedManual = 0;\par
00015     orientationManual = 0;\par
00016     A = 0;\par
00017     B = 0;\par
00018     C = 0;\par
00019 \}\par
00020 \par
00021 {\cf20 /* CRobCodeGenerator mit Uebergabewerten initialisieren */}\par
00022 CRobCodeGenerator::CRobCodeGenerator({\cf18 double} Speed, {\cf18 bool} SpeedManual, {\cf18 bool} OrientationManual, tuple<double, double, double> angles)\par
00023 \{\par
00024     speed = Speed;\par
00025     speedManual = SpeedManual;\par
00026     orientationManual = OrientationManual;\par
00027     A = get<0>(angles);\par
00028     B = get<1>(angles);\par
00029     C = get<2>(angles);\par
00030 \}\par
00031 \par
00032 CRobCodeGenerator::~CRobCodeGenerator({\cf18 void})\par
00033 \{\par
00034 \}\par
00035 \par
00036 {\cf18 void} CRobCodeGenerator::generateRobCode(vector<CInputPoint3D>& points, {\cf18 string} filepath, {\cf18 string} filename)\par
00037 \{\par
00038     postProcessing(points); {\cf20 // Calculates all the necessary values}\par
00039 \par
00040     errno_t err;\par
00041     \par
00042     FILE* fid;\par
00043 \par
00044     {\cf18 string} fullPath = filepath + {\cf22 "/"} + filename;\par
00045 \par
00046     {\cf19 if} ((err = fopen_s(&fid, fullPath.c_str(), {\cf22 "w"})) != 0) {\cf20 // Errorhandling for File opening}\par
00047     \{ \par
00048         {\cf18 string} msg = {\cf22 "Open file: "};\par
00049         msg += filename;\par
00050         msg += {\cf22 " failed!"};\par
00051 \par
00052         {\cf19 throw} exception(msg.c_str());\par
00053     \}\par
00054 \par
00055     filename.erase(filename.end()-4,filename.end());        {\cf20 // l\'C3\'B6scht .src}\par
00056     fprintf(fid, {\cf22 "DEF %s \\n"}, filename.c_str());            {\cf20 // DEF in file schreiben}\par
00057 \par
00058     fputs({\cf22 "PTP $POS_ACT\\n"}, fid);                           {\cf20 // PTP zur aktuellen Position in file schreiben}\par
00059 \par
00060     {\cf19 if} (speedManual) {\cf20 // If the speed is set to manual, it will be defined once at the beginning of the file}\par
00061     \{\par
00062         fprintf(fid, {\cf22 "$VEL.CP = %f\\n"}, speed);      {\cf20 // Geschwindigkeit ein file schreiben}\par
00063     \}\par
00064 \par
00065     {\cf19 for} ({\cf18 size_t} s = 0; s < points.size(); s++)\par
00066     \{\par
00067         {\cf19 if} (!speedManual) {\cf20 // If the speed is calculated it needs to be before every LIN command}\par
00068             fprintf(fid, {\cf22 "&VEL.CP = %f\\n"}, ({\cf18 float})processedPath[s].getSpeed());\par
00069         fprintf(fid, {\cf22 "LIN \{X %f, Y %f, Z %f, A %f, B %f, C %f\}\\n"}, round(processedPath[s].getX() * 10.0) / 10.0, round(processedPath[s].getY() * 10.0) / 10.0, \par
00070             round(processedPath[s].getZ() * 10.0) / 10.0, round(processedPath[s].getA() * 10.0) / 10.0, round(processedPath[s].getB() * 10.0) / 10.0, \par
00071             round(processedPath[s].getC() * 10.0) / 10.0);\par
00072     \}\par
00073 \par
00074     fputs({\cf22 "END"}, fid);\par
00075 \}\par
00076 \par
00077 {\cf18 void} CRobCodeGenerator::postProcessing(vector<CInputPoint3D>& path)\par
00078 \{\par
00079     COutputPoint3D p;\par
00080     {\cf18 double} timePrev = 1;\par
00081 \par
00082     {\cf19 for} ({\cf18 size_t} s = 0; s < path.size(); s++) {\cf20 // F\'C3\'BCr jeden Punkt in dem Vector}\par
00083     \{\par
00084         p.set(path[s].getX(), path[s].getY(), path[s].getZ());\par
00085         {\cf19 if} (speedManual)\par
00086         \{\par
00087             {\cf19 if} (speed > MAX_SPEED) {\cf20 //Wenn maximale Geschwindigkeit ueberschritten wird, Geschwindigkeit begrenzen}\par
00088                 speed = MAX_SPEED;\par
00089         \}\par
00090         {\cf19 else}\par
00091         \{\par
00092             {\cf19 if} (s == 0)\par
00093                 p.setSpeed(1); {\cf20 //Der erste Punkt(0) wird mit Standardgeschwindigkeit 1m/s angefahren.}\par
00094 \par
00095             {\cf19 else}\par
00096                 p.setSpeed(calculateSpeed(path[s], s, timePrev)); {\cf20 //Die Geschwindigkeit zwischen den weiteren Punkten wird berechnet.}\par
00097         \}\par
00098 \par
00099         {\cf19 if} (orientationManual) {\cf20 // Wenn der Winkel vorgegeben ist diesen setzten}\par
00100         \{\par
00101             p.setA(A);\par
00102             p.setB(B);\par
00103             p.setC(C);\par
00104         \}\par
00105         {\cf19 else} {\cf20 // Sonst den Winkel berechnen}\par
00106             calculateAngles(p, path[s]);\par
00107         timePrev = path[s].getTime();\par
00108         processedPath.push_back(p);\par
00109     \}\par
00110 \par
00111 \}\par
00112 \par
00113 {\cf18 double} CRobCodeGenerator::calculateSpeed(CInputPoint3D& p, {\cf18 size_t} s, {\cf18 double} timePrev)\par
00114 \{\par
00115     {\cf18 double} distance = 0;\par
00116     {\cf18 double} time = 0;\par
00117 \par
00118     distance = processedPath[s - 1].distanceTo(p); {\cf20 //Strecke zwischen p und dem Punkt zuvor}\par
00119     time = p.getTime() - timePrev; {\cf20 //Zeit zwischen p-1 und p}\par
00120 \par
00121     speed = distance / time; {\cf20 // Berechnug Geschwindigkeit zwischen zwei Punkten}\par
00122 \par
00123     {\cf19 if} (speed > MAX_SPEED) {\cf20 //Begrenzung auf maximale Geschwindigkeit, falls Trackerdaten h\'EF\'BF\'BDheren Wert aufweisen}\par
00124         speed = MAX_SPEED;\par
00125 \par
00126     {\cf19 return} speed; {\cf20 //Zuweisung der Geschwindigkeit}\par
00127 \}\par
00128 \par
00129 {\cf18 void} CRobCodeGenerator::calculateAngles(COutputPoint3D& p, CInputPoint3D& pIn)\par
00130 \{\par
00131     {\cf20 // Funktion in Eulermatrix aufrufen die a/b/c neu berechnet}\par
00132 \par
00133     CEulerMatrix matrix = pIn.getEulerMatrix();\par
00134     tuple<double, double, double> abc;\par
00135 \par
00136     abc = matrix.calculateAngels();\par
00137 \par
00138     p.setA(get<0>(abc));\par
00139     p.setB(get<1>(abc));\par
00140     p.setC(get<2>(abc));\par
00141 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/RobPathEditor.cpp-Dateireferenz\par \pard\plain 
{\tc\tcl2 \v src/RobPathEditor.cpp}
{\xe \v src/RobPathEditor.cpp}
{\bkmkstart AAAAAAAABQ}
{\bkmkend AAAAAAAABQ}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Hier wird die main Funktion aufgerufen. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "./header/SegmentApproximator.h"}\par
{\f2 #include "./header/PathBuilder.h"}\par
{\f2 #include "./header/RobCodeGenerator.h"}\par
{\f2 #include "./header/InputParameter.h"}\par
{\f2 #include "./header/MeanFilter.h"}\par
{\f2 #include "./header/GUI.h"}\par
{\f2 #include "./header/Logging.h"}\par
{\f2 #include <iostream>}\par
{\f2 #include <ctime>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Funktionen\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b main} ()\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Ausf\'FChrliche Beschreibung\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Hier wird die main Funktion aufgerufen. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definiert in Datei {\b RobPathEditor.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Dokumentation der Funktionen\par
\pard\plain 
{\xe \v main\:RobPathEditor.cpp}
{\xe \v RobPathEditor.cpp\:main}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int main ()}}
\par
{\bkmkstart AAAAAAAABR}
{\bkmkend AAAAAAAABR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definiert in Zeile {\b 55} der Datei {\b RobPathEditor.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00056 \{\par
00057     clock_t start;\par
00058     start = clock();\par
00059 \par
00060     {\cf19 try}\par
00061     \{\par
00062         {\cf20 //logging Initialisieren}\par
00063         {\cf18 string} loggingPath = {\cf22 "output"};\par
00064         CLogging logging(loggingPath);\par
00065 \par
00066         {\cf20 //read Data}\par
00067 \par
00068         CInputParameter inputParameter;\par
00069         {\cf18 string} path = {\cf22 "input/path_01.csv"};\par
00070         inputParameter.openFile(path);\par
00071 \par
00072         {\cf20 //moving Average}\par
00073 \par
00074         CMeanFilter meanFilter;\par
00075         meanFilter.setWindowSize(3);\par
00076         meanFilter.mean(inputParameter.getPath(), logging);\par
00077 \par
00078         {\cf20 // Douglas-Peuker Algorithm}\par
00079 \par
00080         CSegmentApproximator segmentApproximator;\par
00081         segmentApproximator.setmaxDistance(1.5);\par
00082         segmentApproximator.approx(meanFilter.getPath(), logging);\par
00083 \par
00084         {\cf20 // Puts the Segments together to one path}\par
00085 \par
00086         CPathBuilder pathBuilder;\par
00087         pathBuilder.createPath(segmentApproximator.getSegmentsApproxVector(), logging);\par
00088 \par
00089         {\cf20 // Calculates Speed, Angle and generates the Output Data}\par
00090 \par
00091         CRobCodeGenerator codeGenerator(inputParameter.getSpeed(), inputParameter.getSpeedManual(),\par
00092             inputParameter.getOrientationManual(), inputParameter.getAngles());\par
00093         codeGenerator.generateRobCode(pathBuilder.getPath(), loggingPath, {\cf22 "robCode.src"});\par
00094     \par
00095         {\cf18 float} elapsed = (float)(clock() - start) / CLOCKS_PER_SEC;\par
00096     \}\par
00097 \par
00098     {\cf19 catch} (exception& e)\par
00099     \{\par
00100         cerr << e.what() << {\cf22 "\\n"};\par
00101     \}\par
00102 \par
00103     system({\cf22 "pause"});\par
00104 \par
00105    {\cf19 return} 0;\par
00106 \}\par
}
{
\ql
Benutzt {\b CSegmentApproximator::approx()}, {\b CPathBuilder::createPath()}, {\b CRobCodeGenerator::generateRobCode()}, {\b CInputParameter::getAngles()}, {\b CInputParameter::getOrientationManual()}, {\b CInputParameter::getPath()}, {\b CMeanFilter::getPath()}, {\b CPathBuilder::getPath()}, {\b CSegmentApproximator::getSegmentsApproxVector()}, {\b CInputParameter::getSpeed()}, {\b CInputParameter::getSpeedManual()}, {\b CMeanFilter::mean()}, {\b CInputParameter::openFile()}, {\b CSegmentApproximator::setmaxDistance()} und {\b CMeanFilter::setWindowSize()}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
RobPathEditor.cpp\par \pard\plain 
{\tc\tcl2 \v src/RobPathEditor.cpp}
{\xe \v src/RobPathEditor.cpp}
{\bkmkstart AAAAAAAAAT}
{\bkmkend AAAAAAAAAT}
gehe zur Dokumentation dieser Datei{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00043 {\cf21 #include "./header/SegmentApproximator.h"}\par
00044 {\cf21 #include "./header/PathBuilder.h"}\par
00045 {\cf21 #include "./header/RobCodeGenerator.h"}\par
00046 {\cf21 #include "./header/InputParameter.h"}\par
00047 {\cf21 #include "./header/MeanFilter.h"}\par
00048 {\cf21 #include "./header/GUI.h"}\par
00049 {\cf21 #include "./header/Logging.h"}\par
00050 {\cf21 #include <iostream>}\par
00051 {\cf21 #include <ctime>}\par
00052 \par
00053 {\cf17 using namespace }std;\par
00054 \par
00055 {\cf18 int} main()\par
00056 \{\par
00057     clock_t start;\par
00058     start = clock();\par
00059 \par
00060     {\cf19 try}\par
00061     \{\par
00062         {\cf20 //logging Initialisieren}\par
00063         {\cf18 string} loggingPath = {\cf22 "output"};\par
00064         CLogging logging(loggingPath);\par
00065 \par
00066         {\cf20 //read Data}\par
00067 \par
00068         CInputParameter inputParameter;\par
00069         {\cf18 string} path = {\cf22 "input/path_01.csv"};\par
00070         inputParameter.openFile(path);\par
00071 \par
00072         {\cf20 //moving Average}\par
00073 \par
00074         CMeanFilter meanFilter;\par
00075         meanFilter.setWindowSize(3);\par
00076         meanFilter.mean(inputParameter.getPath(), logging);\par
00077 \par
00078         {\cf20 // Douglas-Peuker Algorithm}\par
00079 \par
00080         CSegmentApproximator segmentApproximator;\par
00081         segmentApproximator.setmaxDistance(1.5);\par
00082         segmentApproximator.approx(meanFilter.getPath(), logging);\par
00083 \par
00084         {\cf20 // Puts the Segments together to one path}\par
00085 \par
00086         CPathBuilder pathBuilder;\par
00087         pathBuilder.createPath(segmentApproximator.getSegmentsApproxVector(), logging);\par
00088 \par
00089         {\cf20 // Calculates Speed, Angle and generates the Output Data}\par
00090 \par
00091         CRobCodeGenerator codeGenerator(inputParameter.getSpeed(), inputParameter.getSpeedManual(),\par
00092             inputParameter.getOrientationManual(), inputParameter.getAngles());\par
00093         codeGenerator.generateRobCode(pathBuilder.getPath(), loggingPath, {\cf22 "robCode.src"});\par
00094     \par
00095         {\cf18 float} elapsed = (float)(clock() - start) / CLOCKS_PER_SEC;\par
00096     \}\par
00097 \par
00098     {\cf19 catch} (exception& e)\par
00099     \{\par
00100         cerr << e.what() << {\cf22 "\\n"};\par
00101     \}\par
00102 \par
00103     system({\cf22 "pause"});\par
00104 \par
00105    {\cf19 return} 0;\par
00106 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/SegmentApproximator.cpp-Dateireferenz\par \pard\plain 
{\tc\tcl2 \v src/SegmentApproximator.cpp}
{\xe \v src/SegmentApproximator.cpp}
{\bkmkstart AAAAAAAABS}
{\bkmkend AAAAAAAABS}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Source File Douglas-Peuker. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "./header/SegmentApproximator.h"}\par
{\f2 #include "./header/Point3D.h"}\par
{\f2 #include "./header/Line3D.h"}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Ausf\'FChrliche Beschreibung\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Source File Douglas-Peuker. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definiert in Datei {\b SegmentApproximator.cpp}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SegmentApproximator.cpp\par \pard\plain 
{\tc\tcl2 \v src/SegmentApproximator.cpp}
{\xe \v src/SegmentApproximator.cpp}
{\bkmkstart AAAAAAAAAU}
{\bkmkend AAAAAAAAAU}
gehe zur Dokumentation dieser Datei{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00007 {\cf21 #include "./header/SegmentApproximator.h"}\par
00008 {\cf21 #include "./header/Point3D.h"}\par
00009 {\cf21 #include "./header/Line3D.h"}\par
00010 \par
00011 CSegmentApproximator::CSegmentApproximator({\cf18 void})\par
00012 \{\par
00013 \}\par
00014 \par
00015 CSegmentApproximator::~CSegmentApproximator({\cf18 void})\par
00016 \{\par
00017 \}\par
00018 \par
00019 {\cf18 void} CSegmentApproximator::approx({\cf17 const} vector<list<CInputPoint3D>>& segments, CLogging log)\par
00020 \{\par
00021     CInputPoint3D p;\par
00022 \par
00023     segmentsApprox = segments;\par
00024 \par
00025     {\cf20 /* Douglas Peucker f\'FCr Segmente aufrufen*/}\par
00026     {\cf19 for} ({\cf18 size_t} s = 0; s < segments.size(); s++)\par
00027     \{\par
00028         douglasPeuckerRecursive(segmentsApprox[s], segmentsApprox[s].begin(), --(segmentsApprox[s].end()));\par
00029     \}\par
00030 \par
00031     {\cf20 /*  Logging der Daten*/}\par
00032     log.setStep(3);\par
00033     log.logData(segmentsApprox);\par
00034 \}\par
00035 \par
00036 {\cf18 void} CSegmentApproximator::setmaxDistance({\cf18 double} maxDistanceSource)\par
00037 \{\par
00038     maxDistance = maxDistanceSource;        {\cf20 // setze maxDistance}\par
00039 \}\par
00040 \par
00041 {\cf18 double} CSegmentApproximator::getmaxDistance()\par
00042 \{\par
00043     {\cf19 return} maxDistance;     {\cf20 // Rueckgabe von maxDistance}\par
00044 \}\par
00045 \par
00046 vector<list<CInputPoint3D>>& CSegmentApproximator::getSegmentsApproxVector()\par
00047 \{\par
00048     {\cf19 return} segmentsApprox;      {\cf20 // Rueckgabe der Segmente}\par
00049 \}\par
00050 \par
00051 {\cf20 //TODO: Kommentar}\par
00052 {\cf18 void} CSegmentApproximator::douglasPeuckerRecursive(list<CInputPoint3D>& segment, std::list<CInputPoint3D>::iterator startItr, std::list<CInputPoint3D>::iterator endItr)\par
00053 \{\par
00054     {\cf19 if} (segment.size() < 3) {\cf19 return};  {\cf20 // min Gr\'F6\'DFe pro Seg 3}\par
00055     {\cf19 if} (distance(startItr, endItr) == 2) {\cf19 return};        {\cf20 // Zeigerabstand == 2}\par
00056     CInputPoint3D pStart; CInputPoint3D pEnd;       {\cf20 // Variablen deklarieren}\par
00057 \par
00058 \par
00059     {\cf20 /* Startpunkt setzen */}\par
00060     pStart.setX(startItr->getX()); pStart.setY(startItr->getY()); pStart.setZ(startItr->getZ());\par
00061     pStart.setTime(startItr->getTime());\par
00062     pStart.setEulerMatrix(startItr->getEulerMatrix());\par
00063 \par
00064     {\cf20 /* Endpunkt setzen */}\par
00065     pEnd.setX(endItr->getX()); pEnd.setY(endItr->getY()); pEnd.setZ(endItr->getZ());\par
00066     pEnd.setTime(endItr->getTime());\par
00067     pEnd.setEulerMatrix(endItr->getEulerMatrix());\par
00068 \par
00069     {\cf18 double} dist = 0.0, maxDist = 0.0;                   {\cf20 // dist und maxDist initialisieren }\par
00070     std::list<CInputPoint3D>::iterator maxItr, itr;     {\cf20 // Zeiger bilden}\par
00071 \par
00072 \par
00073     {\cf20 /* am weitesten Entfernten Punkt suchen */}\par
00074     {\cf19 for} (itr = startItr; itr != endItr; itr++)\par
00075     \{\par
00076         CLine3D line = CLine3D(pStart, pEnd);\par
00077         {\cf20 // calc distance}\par
00078         dist = itr->distanceTo(line);\par
00079         {\cf19 if} (dist > maxDist) \{\par
00080             maxDist = dist;\par
00081             maxItr = itr;\par
00082         \}\par
00083     \}\par
00084 \par
00085     {\cf19 if} (maxDist <= maxDistance) \{\par
00086 \par
00087         segment.erase((++startItr), endItr);        {\cf20 // Punkt l\'F6schen}\par
00088         {\cf19 return};\par
00089     \}\par
00090 \par
00091     {\cf20 /*  Douglas Peucker erneut aufrufen */}\par
00092     douglasPeuckerRecursive(segment, startItr, maxItr);\par
00093     douglasPeuckerRecursive(segment, maxItr, endItr);\par
00094 \}\par
}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid Index\par 
\pard\plain 
{\tc \v Index}
{\field\fldedit {\*\fldinst INDEX \\c2 \\*MERGEFORMAT}{\fldrslt INDEX}}
}
