{\rtf1\ansi\ansicpg1252\uc1 \deff0\deflang1033\deflangfe1033
{\fonttbl {\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}
{\f1\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}Arial;}
{\f2\fmodern\fcharset0\fprq1{\*\panose 02070309020205020404}Courier New;}
{\f3\froman\fcharset2\fprq2{\*\panose 05050102010706020507}Symbol;}
}
{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;\red0\green128\blue0;\red96\green64\blue32;\rede0\green128\blue0;\red128\green0\blue0;\red128\green96\blue32;\red0\green32\blue128;\red0\green128\blue128;\red255\green0\blue255;\red0\green0\blue0;\red112\green0\blue112;\red255\green0\blue0;}
{\stylesheet
{\widctlpar\adjustright \fs20\cgrid \snext0 Normal;}
{\paperw11900\paperh16840\margl1800\margr1800\margt1440\margb1440\gutter0\ltrsect}
{\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid \sbasedon0 \snext0 heading 1;}
{\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid \sbasedon0 \snext0 heading 2;}
{\s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid \sbasedon0 \snext0 heading 3;}
{\s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 4;}{\*\cs10 \additive Default Paragraph Font;}
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 5;}{\*\cs10 \additive Default Paragraph Font;}
{\s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid \sbasedon0 \snext15 Title;}
{\s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid \sbasedon0 \snext16 Subtitle;}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid \sbasedon0 \snext17 BodyText;}
{\s18\widctlpar\fs22\cgrid \sbasedon0 \snext18 DenseText;}
{\s28\widctlpar\tqc\tx4320\tqr\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext28 header;}
{\s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid \sbasedon0 \snext29 footer;}
{\s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext30 GroupHeader;}
{\s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext41 Code Example 0;}
{\s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext42 Code Example 1;}
{\s42\li720\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext43 Code Example 2;}
{\s43\li1080\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext44 Code Example 3;}
{\s44\li1440\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext45 Code Example 4;}
{\s45\li1800\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext46 Code Example 5;}
{\s46\li2160\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext47 Code Example 6;}
{\s47\li2520\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext48 Code Example 7;}
{\s48\li2880\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext49 Code Example 8;}
{\s49\li3240\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext50 Code Example 9;}
{\s50\li3600\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext51 Code Example 10;}
{\s51\li3960\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext52 Code Example 11;}
{\s52\li4320\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext53 Code Example 12;}
{\s53\li4680\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext53 Code Example 13;}
{\s60\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext61 List Continue 0;}
{\s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext62 List Continue 1;}
{\s62\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext63 List Continue 2;}
{\s63\li1080\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext64 List Continue 3;}
{\s64\li1440\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext65 List Continue 4;}
{\s65\li1800\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext66 List Continue 5;}
{\s66\li2160\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext67 List Continue 6;}
{\s67\li2520\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext68 List Continue 7;}
{\s68\li2880\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext69 List Continue 8;}
{\s69\li3240\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext70 List Continue 9;}
{\s70\li3600\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext71 List Continue 10;}
{\s71\li3960\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext72 List Continue 11;}
{\s72\li4320\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext73 List Continue 12;}
{\s73\li4680\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext73 List Continue 13;}
{\s80\li0\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext81 DescContinue 0;}
{\s81\li360\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext82 DescContinue 1;}
{\s82\li720\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext83 DescContinue 2;}
{\s83\li1080\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext84 DescContinue 3;}
{\s84\li1440\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext85 DescContinue 4;}
{\s85\li1800\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext86 DescContinue 5;}
{\s86\li2160\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext87 DescContinue 6;}
{\s87\li2520\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext88 DescContinue 7;}
{\s88\li2880\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext89 DescContinue 8;}
{\s89\li3240\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext90 DescContinue 9;}
{\s90\li3600\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext91 DescContinue 10;}
{\s91\li3960\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext92 DescContinue 11;}
{\s92\li4320\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext93 DescContinue 12;}
{\s93\li4680\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext93 DescContinue 13;}
{\s100\li0\sa30\sb30\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext101 LatexTOC 0;}
{\s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext102 LatexTOC 1;}
{\s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext103 LatexTOC 2;}
{\s103\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext104 LatexTOC 3;}
{\s104\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext105 LatexTOC 4;}
{\s105\li1800\sa15\sb15\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext106 LatexTOC 5;}
{\s106\li2160\sa12\sb12\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext107 LatexTOC 6;}
{\s107\li2520\sa9\sb9\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext108 LatexTOC 7;}
{\s108\li2880\sa6\sb6\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext109 LatexTOC 8;}
{\s109\li3240\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext110 LatexTOC 9;}
{\s110\li3600\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext111 LatexTOC 10;}
{\s111\li3960\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext112 LatexTOC 11;}
{\s112\li4320\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext113 LatexTOC 12;}
{\s113\li4680\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext113 LatexTOC 13;}
{\s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext121 \sautoupd List Bullet 0;}
{\s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext122 \sautoupd List Bullet 1;}
{\s122\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext123 \sautoupd List Bullet 2;}
{\s123\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext124 \sautoupd List Bullet 3;}
{\s124\fi-360\li1800\widctlpar\jclisttab\tx1800{\*\pn \pnlvlbody\ilvl0\ls5\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext125 \sautoupd List Bullet 4;}
{\s125\fi-360\li2160\widctlpar\jclisttab\tx2160{\*\pn \pnlvlbody\ilvl0\ls6\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext126 \sautoupd List Bullet 5;}
{\s126\fi-360\li2520\widctlpar\jclisttab\tx2520{\*\pn \pnlvlbody\ilvl0\ls7\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext127 \sautoupd List Bullet 6;}
{\s127\fi-360\li2880\widctlpar\jclisttab\tx2880{\*\pn \pnlvlbody\ilvl0\ls8\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext128 \sautoupd List Bullet 7;}
{\s128\fi-360\li3240\widctlpar\jclisttab\tx3240{\*\pn \pnlvlbody\ilvl0\ls9\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext129 \sautoupd List Bullet 8;}
{\s129\fi-360\li3600\widctlpar\jclisttab\tx3600{\*\pn \pnlvlbody\ilvl0\ls10\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext130 \sautoupd List Bullet 9;}
{\s130\fi-360\li3960\widctlpar\jclisttab\tx3960{\*\pn \pnlvlbody\ilvl0\ls11\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext131 \sautoupd List Bullet 10;}
{\s131\fi-360\li4320\widctlpar\jclisttab\tx4320{\*\pn \pnlvlbody\ilvl0\ls12\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext132 \sautoupd List Bullet 11;}
{\s132\fi-360\li4680\widctlpar\jclisttab\tx4680{\*\pn \pnlvlbody\ilvl0\ls13\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext133 \sautoupd List Bullet 12;}
{\s133\fi-360\li5040\widctlpar\jclisttab\tx5040{\*\pn \pnlvlbody\ilvl0\ls14\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext133 \sautoupd List Bullet 13;}
{\s140\fi-360\li360\widctlpar\fs20\cgrid \sbasedon0 \snext141 \sautoupd List Enum 0;}
{\s141\fi-360\li720\widctlpar\fs20\cgrid \sbasedon0 \snext142 \sautoupd List Enum 1;}
{\s142\fi-360\li1080\widctlpar\fs20\cgrid \sbasedon0 \snext143 \sautoupd List Enum 2;}
{\s143\fi-360\li1440\widctlpar\fs20\cgrid \sbasedon0 \snext144 \sautoupd List Enum 3;}
{\s144\fi-360\li1800\widctlpar\fs20\cgrid \sbasedon0 \snext145 \sautoupd List Enum 4;}
{\s145\fi-360\li2160\widctlpar\fs20\cgrid \sbasedon0 \snext146 \sautoupd List Enum 5;}
{\s146\fi-360\li2520\widctlpar\fs20\cgrid \sbasedon0 \snext147 \sautoupd List Enum 6;}
{\s147\fi-360\li2880\widctlpar\fs20\cgrid \sbasedon0 \snext148 \sautoupd List Enum 7;}
{\s148\fi-360\li3240\widctlpar\fs20\cgrid \sbasedon0 \snext149 \sautoupd List Enum 8;}
{\s149\fi-360\li3600\widctlpar\fs20\cgrid \sbasedon0 \snext150 \sautoupd List Enum 9;}
{\s150\fi-360\li3960\widctlpar\fs20\cgrid \sbasedon0 \snext151 \sautoupd List Enum 10;}
{\s151\fi-360\li4320\widctlpar\fs20\cgrid \sbasedon0 \snext152 \sautoupd List Enum 11;}
{\s152\fi-360\li4680\widctlpar\fs20\cgrid \sbasedon0 \snext153 \sautoupd List Enum 12;}
{\s153\fi-360\li5040\widctlpar\fs20\cgrid \sbasedon0 \snext153 \sautoupd List Enum 13;}
}
{\info 
{\title {\comment RobCodeGenerator }RobCodeGenerator}
{\comment Erzeugt von doxygen 1.9.7.}
}\pard\plain 
\sectd\pgnlcrm
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\vertalc\qc\par\par\par\par\par\par\par
\pard\plain \s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid 
{\field\fldedit {\*\fldinst TITLE \\*MERGEFORMAT}{\fldrslt RobCodeGenerator}}\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\par
\par\par\par\par\par\par\par\par\par\par\par\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
{\field\fldedit {\*\fldinst AUTHOR \\*MERGEFORMAT}{\fldrslt AUTHOR}}\par
Version \par\page\page\vertalt
\pard\plain 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid Inhaltsverzeichnis\par
\pard\plain \par
{\field\fldedit {\*\fldinst TOC \\f \\*MERGEFORMAT}{\fldrslt Table of contents}}\par
\pard\plain 
\sect \sbkpage \pgndec \pgnrestart
\sect \sectd \sbknone
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
\par \pard\plain 
\pard\plain \s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
My Personal Index Page\par \pard\plain 
{\tc\tcl1 \v My Personal Index Page}
{\xe \v My Personal Index Page}
{\bkmkstart AAAAAAAAHT}
{\bkmkend AAAAAAAAHT}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{\bkmkstart AAAAAAAAHU}
{\bkmkend AAAAAAAAHU}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Introduction
\par}
{\tc\tcl2 \v Introduction}
This is the introduction.\par}
{\bkmkstart AAAAAAAAHV}
{\bkmkend AAAAAAAAHV}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Installation
\par}
{\tc\tcl2 \v Installation}
{\bkmkstart AAAAAAAAHW}
{\bkmkend AAAAAAAAHW}
{{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Step 1: Opening the box
\par}
{\tc\tcl3 \v Step 1: Opening the box}
etc... \par}
\par}
}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Hierarchie-Verzeichnis\par \pard\plain 
{\tc \v Hierarchie-Verzeichnis}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Klassenhierarchie\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Die Liste der Ableitungen ist -mit Einschr\'E4nkungen- alphabetisch sortiert:}
{
\par
\pard\plain \s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
CEulerMatrix\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
CGUI\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
CInputParameter\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
CLine3D\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
CMeanFilter\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
CPathBuilder\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
CPathPostProcessing\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
CPoint3D\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGB \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
CInputPoint3D\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
COutputPoint3D\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
CRobCodeGenerator\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
CSegmentApproximator\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Klassen-Verzeichnis\par \pard\plain 
{\tc \v Klassen-Verzeichnis}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Auflistung der Klassen\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Hier folgt die Aufz\'E4hlung aller Klassen, Strukturen, Varianten und Schnittstellen mit einer Kurzbeschreibung:}
{
\par
\pard\plain \s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b {\b CEulerMatrix} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
: Handling und Berechnung Euler Matrix })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CGUI} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CInputParameter} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
: Handling Eingabedaten })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CInputPoint3D} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CLine3D} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CMeanFilter} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b COutputPoint3D} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CPathBuilder} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CPathPostProcessing} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CPoint3D} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CRobCodeGenerator} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CSegmentApproximator} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Datei-Verzeichnis\par \pard\plain 
{\tc \v Datei-Verzeichnis}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Auflistung der Dateien\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Hier folgt die Aufz\'E4hlung aller Dateien mit einer Kurzbeschreibung:}
{
\par
\pard\plain \s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b {\b plotPath.m} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b header/{\b EulerMatrix.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
: Header File handling Euler Matrix })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b header/{\b GUI.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b header/{\b InputParameter.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
: Header File Daten Einlesen })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b header/{\b Line3D.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b header/{\b MeanFilter.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b header/{\b PathBuilder.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b header/{\b PathPostProcessing.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b header/{\b Point3D.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b header/{\b RobCodeGenerator.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b header/{\b SegmentApproximator.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b EulerMatrix.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b GUI.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b InputParameter.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b Line3D.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b MeanFilter.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b PathBuilder.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b PathPostProcessing.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b Point3D.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b RobCodeGenerator.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b RobPathEditor.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b SegmentApproximator.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Klassen-Dokumentation{\tc \v Klassen-Dokumentation}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CEulerMatrix Klassenreferenz\par \pard\plain 
{\tc\tcl2 \v CEulerMatrix}
{\xe \v CEulerMatrix}
{\bkmkstart AAAAAAAACF}
{\bkmkend AAAAAAAACF}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
: Handling und Berechnung Euler Matrix }}\par
{
{\f2 #include <EulerMatrix.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'D6ffentliche Methoden\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CEulerMatrix} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
: Default Konstruktor }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CEulerMatrix} (float inputMatrix[3][3])\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
: Default Konstruktor }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~CEulerMatrix} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
: Dekonstruktor }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setMatrix} (float inputMatrix[3][3])\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
: Setzt eine Matrix }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CEulerMatrix} {\b getMatrix} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
: Auslesen eine Matrix }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CEulerMatrix} {\b calculatAngel} (double A, double B, double C)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
: Berechnet die neue Umdrehungsmatrix }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Attribute\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b eulerMatrix} [3][3]\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Ausf\'FChrliche Beschreibung\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
: Handling und Berechnung Euler Matrix \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Diese Klasse speichert die Euler Matrix und hat Funktionen f\'FCr Berechnungen mit eben jener. \par
}{
Definiert in Zeile {\b 15} der Datei {\b EulerMatrix.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Beschreibung der Konstruktoren und Destruktoren\par
\pard\plain 
{\xe \v CEulerMatrix\:CEulerMatrix}
{\xe \v CEulerMatrix\:CEulerMatrix}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CEulerMatrix::CEulerMatrix (void )}}
\par
{\bkmkstart AAAAAAAACG}
{\bkmkend AAAAAAAACG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
: Default Konstruktor }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialisiert die Input Daten mit Null \par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Siehe auch\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
: {\b CEulerMatrix(float inputMatrix[3][3])} \par
}}}{
Definiert in Zeile {\b 4} der Datei {\b EulerMatrix.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00005 \{\par
00006     {\cf19 for} ({\cf18 int} i = 0; i < 3; i++)\par
00007     \{\par
00008         {\cf19 for} ({\cf18 int} m = 0; m < 3; m++)\par
00009         \{\par
00010             eulerMatrix[i][m] = 0;                  {\cf20 // eulerMatrix mit 0 initialisieren}\par
00011         \}\par
00012     \}\par
00013 \}\par
}
{
\ql
Benutzt {\b eulerMatrix} und {\b i}.}\par
}
{\xe \v CEulerMatrix\:CEulerMatrix}
{\xe \v CEulerMatrix\:CEulerMatrix}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CEulerMatrix::CEulerMatrix (float  {\i inputMatrix}[3][3])}}
\par
{\bkmkstart AAAAAAAACH}
{\bkmkend AAAAAAAACH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
: Default Konstruktor }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialisiert die Input Daten mit Null {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameter\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i } \cell }{float inputMatrix[3][3] initialisiert die Klasse mit einer Euler Matrix \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Siehe auch\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
: {\b CEulerMatrix(void)} \par
}}}{
Definiert in Zeile {\b 15} der Datei {\b EulerMatrix.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00016 \{\par
00017     {\cf19 for} ({\cf18 int} i = 0; i < 3; i++)\par
00018     \{\par
00019         {\cf19 for} ({\cf18 int} m = 0; m < 3; m++)\par
00020         \{\par
00021             eulerMatrix[i][m] = inputMatrix[i][m];  {\cf20 // eulerMatrix mit Startwerten initialisieren}\par
00022         \}\par
00023     \}\par
00024 \}\par
}
{
\ql
Benutzt {\b eulerMatrix} und {\b i}.}\par
}
{\xe \v ~CEulerMatrix\:CEulerMatrix}
{\xe \v CEulerMatrix\:~CEulerMatrix}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CEulerMatrix::~CEulerMatrix ()}}
\par
{\bkmkstart AAAAAAAACI}
{\bkmkend AAAAAAAACI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
: Dekonstruktor }}\par
{
Definiert in Zeile {\b 26} der Datei {\b EulerMatrix.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00027 \{\par
00028 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Dokumentation der Elementfunktionen\par
\pard\plain 
{\xe \v calculatAngel\:CEulerMatrix}
{\xe \v CEulerMatrix\:calculatAngel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CEulerMatrix} CEulerMatrix::calculatAngel (double  {\i A}, double  {\i B}, double  {\i C})}}
\par
{\bkmkstart AAAAAAAACJ}
{\bkmkend AAAAAAAACJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
: Berechnet die neue Umdrehungsmatrix }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameter\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i A} \cell }{double Winkel a \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i B} \cell }{double Winkel b \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i C} \cell }{double Winkel c \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
R\'FCckgabe\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
: float inputMatrix[3][3] gibt die neu berechnete Matrix zur\'FCck \par
}}}{
Definiert in Zeile {\b 47} der Datei {\b EulerMatrix.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00048 \{\par
00049     {\cf18 float} Matrix[3][3];\par
00050 \par
00051     Matrix[0][0] = cos(A) * cos(C) - sin(A) * cos(B) * sin(C);\par
00052     Matrix[0][1] = -cos(A) * sin(C) - sin(A) * cos(B) * cos(C);\par
00053     Matrix[0][2] = sin(A) * sin(B);\par
00054 \par
00055     Matrix[1][0] = sin(A) * cos(C) + cos(A) * cos(B) * sin(C);\par
00056     Matrix[1][1] = -sin(A) * sin(C) + cos(A) * cos(B) * cos(C);\par
00057     Matrix[1][2] = -cos(A) * sin(B);\par
00058 \par
00059     Matrix[2][0] = sin(B) * sin(C);\par
00060     Matrix[2][1] = sin(B) * cos(C);\par
00061     Matrix[2][2] = cos(B);\par
00062 \par
00063     CEulerMatrix buffer(Matrix);\par
00064     {\cf19 return} buffer;\par
00065 \}\par
}
}
{\xe \v getMatrix\:CEulerMatrix}
{\xe \v CEulerMatrix\:getMatrix}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CEulerMatrix} CEulerMatrix::getMatrix ()}}
\par
{\bkmkstart AAAAAAAACK}
{\bkmkend AAAAAAAACK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
: Auslesen eine Matrix }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
R\'FCckgabe\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
: float inputMatrix[3][3] gibt gespeicherte Matrix zur\'FCck \par
}}}{
Definiert in Zeile {\b 42} der Datei {\b EulerMatrix.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00043 \{\par
00044     {\cf19 return} eulerMatrix;\par
00045 \}\par
}
{
\ql
Benutzt {\b eulerMatrix}.}\par
{
\ql
Wird benutzt von {\b CInputParameter::openFile()}.}\par
}
{\xe \v setMatrix\:CEulerMatrix}
{\xe \v CEulerMatrix\:setMatrix}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CEulerMatrix::setMatrix (float  {\i inputMatrix}[3][3])}}
\par
{\bkmkstart AAAAAAAACL}
{\bkmkend AAAAAAAACL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
: Setzt eine Matrix }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameter\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i } \cell }{float inputMatrix[3][3] zum setzten einer Matrix \cell }
{\row }
}
}{
Definiert in Zeile {\b 31} der Datei {\b EulerMatrix.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00032 \{\par
00033     {\cf19 for}({\cf18 int} i = 0; i < 3; i++)\par
00034     \{ \par
00035         {\cf19 for} ({\cf18 int} m = 0; m < 3; m++)\par
00036         \{\par
00037             eulerMatrix[i][m] = inputMatrix[i][m];  {\cf20 // eulerMatrix mit \'DCbergabewerten \'FCberschreiben}\par
00038         \}\par
00039     \}\par
00040 \}\par
}
{
\ql
Benutzt {\b eulerMatrix} und {\b i}.}\par
{
\ql
Wird benutzt von {\b CInputParameter::openFile()}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Dokumentation der Datenelemente\par
\pard\plain 
{\xe \v eulerMatrix\:CEulerMatrix}
{\xe \v CEulerMatrix\:eulerMatrix}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float CEulerMatrix::eulerMatrix[3][3]{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAACM}
{\bkmkend AAAAAAAACM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gespeicherte Euler Matrix \par
}{
Definiert in Zeile {\b 60} der Datei {\b EulerMatrix.h}.}\par
{
\ql
Wird benutzt von {\b CEulerMatrix()}, {\b CEulerMatrix()}, {\b getMatrix()} und {\b setMatrix()}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
Die Dokumentation f\'FCr diese Klasse wurde erzeugt aufgrund der Dateien:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
header/{\b EulerMatrix.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
src/{\b EulerMatrix.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CGUI Klassenreferenz\par \pard\plain 
{\tc\tcl2 \v CGUI}
{\xe \v CGUI}
{\bkmkstart AAAAAAAACN}
{\bkmkend AAAAAAAACN}
\par
{
{\f2 #include <GUI.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'D6ffentliche Methoden\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CGUI} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~CGUI} ()\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Ausf\'FChrliche Beschreibung\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definiert in Zeile {\b 3} der Datei {\b GUI.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Beschreibung der Konstruktoren und Destruktoren\par
\pard\plain 
{\xe \v CGUI\:CGUI}
{\xe \v CGUI\:CGUI}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CGUI::CGUI ()}}
\par
{\bkmkstart AAAAAAAACO}
{\bkmkend AAAAAAAACO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definiert in Zeile {\b 3} der Datei {\b GUI.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00004 \{\}\par
}
}
{\xe \v ~CGUI\:CGUI}
{\xe \v CGUI\:~CGUI}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CGUI::~CGUI ()}}
\par
{\bkmkstart AAAAAAAACP}
{\bkmkend AAAAAAAACP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definiert in Zeile {\b 6} der Datei {\b GUI.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00007 \{\}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
Die Dokumentation f\'FCr diese Klasse wurde erzeugt aufgrund der Dateien:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
header/{\b GUI.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
src/{\b GUI.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CInputParameter Klassenreferenz\par \pard\plain 
{\tc\tcl2 \v CInputParameter}
{\xe \v CInputParameter}
{\bkmkstart AAAAAAAACQ}
{\bkmkend AAAAAAAACQ}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
: Handling Eingabedaten }}\par
{
{\f2 #include <InputParameter.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'D6ffentliche Methoden\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CInputParameter} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
: Default Konstruktor }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CInputParameter} (double initSpeed, bool initSeepManual, bool initOrientationManual, double initA, double initB, double initC)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
: Konstruktor mit Werten }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~CInputParameter} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
: Dekonstruktor }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setOrientation} (bool initOrientationManual, double initA, double initB, double initC)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
: Setzt Orientierungs Daten }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setSpeed} (double initSpeed, bool initSpeedManual)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
: Setzt Geschwindigkeits Daten }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b getSpeed} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
: Gibt Geschwindigkeit zur\'FCck }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b getSpeedManual} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
: Gibt zur\'FCck ob h\'E4ndische Geschwindigkeit verwendet werden soll }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b getOrientationManual} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
: Gibt zur\'FCck ob h\'E4ndische Orientierung verwendet werden soll }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
tuple< double, double, double > {\b getAngles} (void)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
: Gibt Winkel zur\'FCck @output: tuple <double double double> angles }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b openFile} (std::string path)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
: Liest die Daten aus dem Input File ein }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b detectJump} ({\b CInputPoint3D} p, double x_prev, double y_prev, double z_prev)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
: Erkennt Spr\'FCnge in den Daten }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
vector< list< {\b CInputPoint3D} > > & {\b getPath} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
: Gibt Pfad zur\'FCck }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Attribute\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
vector< list< {\b CInputPoint3D} > > {\b initialPath}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b speed}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b speedManual}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b orientationManual}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b A}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b B}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b C}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b difference} = 20\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Ausf\'FChrliche Beschreibung\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
: Handling Eingabedaten \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
In dieser Klasse werden die eingelesenen einstellbaren Daten und das einlesen der Daten aus der Eingabedatei gehandelt. \par
}{
Definiert in Zeile {\b 25} der Datei {\b InputParameter.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Beschreibung der Konstruktoren und Destruktoren\par
\pard\plain 
{\xe \v CInputParameter\:CInputParameter}
{\xe \v CInputParameter\:CInputParameter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CInputParameter::CInputParameter (void )}}
\par
{\bkmkstart AAAAAAAACR}
{\bkmkend AAAAAAAACR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
: Default Konstruktor }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialisiert die Input Daten mit Null \par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Siehe auch\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
: {\b CInputParameter(double initSpeed, bool initSeepManual, bool initOrientationManual, double initA, double initB, double initC)}\par
}}Initialiserung der Klasse mit 0 \par
}{
Definiert in Zeile {\b 27} der Datei {\b InputParameter.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00028 \{\par
00029     speed = 0;\par
00030     A = 0;\par
00031     B = 0;\par
00032     C = 0;\par
00033     speedManual = {\cf17 false},\par
00034     orientationManual = {\cf17 false};\par
00035 \par
00036 \}\par
}
{
\ql
Benutzt {\b A}, {\b B}, {\b C}, {\b orientationManual}, {\b speed} und {\b speedManual}.}\par
}
{\xe \v CInputParameter\:CInputParameter}
{\xe \v CInputParameter\:CInputParameter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CInputParameter::CInputParameter (double  {\i initSpeed}, bool  {\i initSpeedManual}, bool  {\i initOrientationManual}, double  {\i initA}, double  {\i initB}, double  {\i initC})}}
\par
{\bkmkstart AAAAAAAACS}
{\bkmkend AAAAAAAACS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
: Konstruktor mit Werten }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialisiert die Input Daten {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameter\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i initSpeed} \cell }{double \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i initSpeedManual} \cell }{bool \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i initOrientationManual} \cell }{bool \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i initA} \cell }{double \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i initB} \cell }{double \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i initC} \cell }{double \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Siehe auch\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\b CInputParameter()} \par
{\b ~CInputParameter()} \par
: {\b CInputParameter(void)};\par
}}Initialiserung der Klasse mit allen Werten \par
}{
Definiert in Zeile {\b 14} der Datei {\b InputParameter.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00015 \{\par
00016     speed = initSpeed;\par
00017     speedManual = initSpeedManual;\par
00018     orientationManual = initOrientationManual;\par
00019     A = initA;\par
00020     B = initB;\par
00021     C = initC;\par
00022 \par
00023 \}\par
}
{
\ql
Benutzt {\b A}, {\b B}, {\b C}, {\b orientationManual}, {\b speed} und {\b speedManual}.}\par
}
{\xe \v ~CInputParameter\:CInputParameter}
{\xe \v CInputParameter\:~CInputParameter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CInputParameter::~CInputParameter (void )}}
\par
{\bkmkstart AAAAAAAACT}
{\bkmkend AAAAAAAACT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
: Dekonstruktor }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialisiert die Input Daten\par
Dekonstruktor \par
}{
Definiert in Zeile {\b 40} der Datei {\b InputParameter.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00041 \{\par
00042 \par
00043 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Dokumentation der Elementfunktionen\par
\pard\plain 
{\xe \v detectJump\:CInputParameter}
{\xe \v CInputParameter\:detectJump}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool CInputParameter::detectJump ({\b CInputPoint3D}  {\i p}, double  {\i x_prev}, double  {\i y_prev}, double  {\i z_prev})}}
\par
{\bkmkstart AAAAAAAACU}
{\bkmkend AAAAAAAACU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
: Erkennt Spr\'FCnge in den Daten }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Um zu erkennen ob es mehrere Pfade sind wird nach Spr\'FCngen gesucht, bei einem Sprung wird eine neue Liste angefangen. {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameter\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i } \cell }{{\b CInputPoint3D} p den aktuellen Punkt \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i } \cell }{double x_prev die vorherige x Position \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i } \cell }{double y_prev die vorherige y Position \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i } \cell }{double z_prev die vorherige z Position \cell }
{\row }
}
}{
Definiert in Zeile {\b 127} der Datei {\b InputParameter.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00128 \{\par
00129     {\cf19 if}(abs(p.getX() - x_prev) > difference)\par
00130         {\cf19 return} {\cf17 true};\par
00131     {\cf19 else} {\cf19 if}(abs(p.getY() - y_prev) > difference)\par
00132         {\cf19 return} {\cf17 true};\par
00133     {\cf19 else} {\cf19 if}(abs(p.getZ() - z_prev) > difference)\par
00134         {\cf19 return} {\cf17 true};\par
00135     {\cf19 else}\par
00136         {\cf19 return} {\cf17 false};\par
00137 \}\par
}
{
\ql
Benutzt {\b difference}, {\b CPoint3D::getX()}, {\b CPoint3D::getY()} und {\b CPoint3D::getZ()}.}\par
{
\ql
Wird benutzt von {\b openFile()}.}\par
}
{\xe \v getAngles\:CInputParameter}
{\xe \v CInputParameter\:getAngles}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
tuple< double, double, double > CInputParameter::getAngles (void )}}
\par
{\bkmkstart AAAAAAAACV}
{\bkmkend AAAAAAAACV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
: Gibt Winkel zur\'FCck @output: tuple <double double double> angles }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gibt die eingegebenen Winkel als tuple zur\'FCck \par
}{
Definiert in Zeile {\b 79} der Datei {\b InputParameter.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00080 \{\par
00081     {\cf19 return} make_tuple(A, B, C);\par
00082 \}\par
}
{
\ql
Benutzt {\b A}, {\b B} und {\b C}.}\par
{
\ql
Wird benutzt von {\b main()}.}\par
}
{\xe \v getOrientationManual\:CInputParameter}
{\xe \v CInputParameter\:getOrientationManual}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool CInputParameter::getOrientationManual (void )}}
\par
{\bkmkstart AAAAAAAACW}
{\bkmkend AAAAAAAACW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
: Gibt zur\'FCck ob h\'E4ndische Orientierung verwendet werden soll }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gibt zur\'FCck ob h\'E4ndische Orientierung verwendet werden soll, sonst wird sie sp\'E4ter berechnet. \par
}{
Definiert in Zeile {\b 74} der Datei {\b InputParameter.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00075 \{\par
00076     {\cf19 return} orientationManual;\par
00077 \}\par
}
{
\ql
Benutzt {\b orientationManual}.}\par
{
\ql
Wird benutzt von {\b main()}.}\par
}
{\xe \v getPath\:CInputParameter}
{\xe \v CInputParameter\:getPath}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
vector< list< {\b CInputPoint3D} > > & CInputParameter::getPath ()}}
\par
{\bkmkstart AAAAAAAACX}
{\bkmkend AAAAAAAACX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
: Gibt Pfad zur\'FCck }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gibt die eingegebenen Winkel als tuple zur\'FCck \par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
R\'FCckgabe\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
: vector<list<CInputPoint3D>> den eingelesen Pfad \par
}}}{
Definiert in Zeile {\b 59} der Datei {\b InputParameter.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00060 \{\par
00061     {\cf19 return} initialPath;\par
00062 \}\par
}
{
\ql
Benutzt {\b initialPath}.}\par
{
\ql
Wird benutzt von {\b main()}.}\par
}
{\xe \v getSpeed\:CInputParameter}
{\xe \v CInputParameter\:getSpeed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double CInputParameter::getSpeed (void )}}
\par
{\bkmkstart AAAAAAAACY}
{\bkmkend AAAAAAAACY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
: Gibt Geschwindigkeit zur\'FCck }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gibt die eingegebene Geschwindigkeit zur\'FCck \par
}{
Definiert in Zeile {\b 64} der Datei {\b InputParameter.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00065 \{\par
00066     {\cf19 return} speed;\par
00067 \}\par
}
{
\ql
Benutzt {\b speed}.}\par
{
\ql
Wird benutzt von {\b main()}.}\par
}
{\xe \v getSpeedManual\:CInputParameter}
{\xe \v CInputParameter\:getSpeedManual}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool CInputParameter::getSpeedManual (void )}}
\par
{\bkmkstart AAAAAAAACZ}
{\bkmkend AAAAAAAACZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
: Gibt zur\'FCck ob h\'E4ndische Geschwindigkeit verwendet werden soll }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Gibt zur\'FCck ob h\'E4ndische Geschwindigekit verwendet werden soll, sonst wird sie sp\'E4ter berechnet. \par
}{
Definiert in Zeile {\b 69} der Datei {\b InputParameter.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00070 \{\par
00071     {\cf19 return} speedManual;\par
00072 \}\par
}
{
\ql
Benutzt {\b speedManual}.}\par
{
\ql
Wird benutzt von {\b main()}.}\par
}
{\xe \v openFile\:CInputParameter}
{\xe \v CInputParameter\:openFile}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CInputParameter::openFile (std::string  {\i path})}}
\par
{\bkmkstart AAAAAAAADA}
{\bkmkend AAAAAAAADA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
: Liest die Daten aus dem Input File ein }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Liest die Daten aus einen beliebigen File ein und ruft @detectJump auf um zu erkennen ob es mehrere Aufnahmen sind. {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameter\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i } \cell }{File Pfad \cell }
{\row }
}
}{
Definiert in Zeile {\b 84} der Datei {\b InputParameter.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00085 \{\par
00086     ifstream fin(path);\par
00087     {\cf18 char} delimiter = {\cf23 ' '};\par
00088     CInputPoint3D tmpPoint;\par
00089     CEulerMatrix tmpEuler;\par
00090     {\cf18 double} x, y, z;\par
00091     {\cf18 double} x_prev = 0, y_prev = 0, z_prev = 0;\par
00092     {\cf18 double} timestamp;\par
00093     {\cf18 int} segmentCount = -1;\par
00094     {\cf18 float} dummyMatrix[3][3];\par
00095 \par
00096 \par
00097     {\cf19 if} (!fin.is_open())\par
00098     \{\par
00099         cerr << {\cf22 "Datei konnte nicht ge\'F6ffnet werden"} << endl;\par
00100     \}\par
00101     {\cf18 string} line;\par
00102 \par
00103     {\cf19 while}(getline(fin, line))\par
00104     \{\par
00105         std::istringstream sStream (line);\par
00106         sStream >> timestamp >> x >> y >> z >> dummyMatrix[0][0] >> dummyMatrix[0][1] >> dummyMatrix[0][2]\par
00107             >> dummyMatrix[1][0] >> dummyMatrix[1][1] >> dummyMatrix[1][2] >> dummyMatrix[2][0] >> dummyMatrix[2][1] >> dummyMatrix[2][2];\par
00108 \par
00109         tmpEuler.setMatrix(dummyMatrix);\par
00110         tmpPoint.setPoint(timestamp, x, y, z, tmpEuler.getMatrix());\par
00111 \par
00112         {\cf19 if} (detectJump(tmpPoint, x_prev, y_prev, z_prev))\par
00113         \{\par
00114             segmentCount++;\par
00115             initialPath.push_back(list<CInputPoint3D>());\par
00116         \}\par
00117 \par
00118         initialPath[segmentCount].push_back(tmpPoint);\par
00119 \par
00120         x_prev = x;\par
00121         y_prev = y;\par
00122         z_prev = z;\par
00123     \}\par
00124     fin.close();\par
00125 \}\par
}
{
\ql
Benutzt {\b detectJump()}, {\b CEulerMatrix::getMatrix()}, {\b initialPath}, {\b CEulerMatrix::setMatrix()} und {\b CInputPoint3D::setPoint()}.}\par
{
\ql
Wird benutzt von {\b main()}.}\par
}
{\xe \v setOrientation\:CInputParameter}
{\xe \v CInputParameter\:setOrientation}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CInputParameter::setOrientation (bool  {\i initOrientationManual}, double  {\i initA}, double  {\i initB}, double  {\i initC})}}
\par
{\bkmkstart AAAAAAAADB}
{\bkmkend AAAAAAAADB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
: Setzt Orientierungs Daten }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Setzt ob die Orientierung H\'E4ndisch eingegeben werden soll und die drei Winkel {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameter\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i initOrientationManual} \cell }{bool \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i initA} \cell }{double \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i initB} \cell }{double \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i initC} \cell }{double \cell }
{\row }
}
}{
Definiert in Zeile {\b 45} der Datei {\b InputParameter.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00046 \{\par
00047     orientationManual = initOrientationManual;\par
00048     A = initA;\par
00049     B = initB;\par
00050     C = initC;\par
00051 \}\par
}
{
\ql
Benutzt {\b A}, {\b B}, {\b C} und {\b orientationManual}.}\par
}
{\xe \v setSpeed\:CInputParameter}
{\xe \v CInputParameter\:setSpeed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CInputParameter::setSpeed (double  {\i initSpeed}, bool  {\i initSpeedManual})}}
\par
{\bkmkstart AAAAAAAADC}
{\bkmkend AAAAAAAADC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
: Setzt Geschwindigkeits Daten }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Setzt ob die Geschwindigkeit H\'E4ndisch eingegeben werden soll und die Geschwindigkeit in m/s {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameter\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i initSpeed} \cell }{double \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i initSpeedManual} \cell }{bool \cell }
{\row }
}
}{
Definiert in Zeile {\b 53} der Datei {\b InputParameter.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00054 \{\par
00055     speed = initSpeed;\par
00056     speedManual = initSpeedManual;\par
00057 \}\par
}
{
\ql
Benutzt {\b speed} und {\b speedManual}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Dokumentation der Datenelemente\par
\pard\plain 
{\xe \v A\:CInputParameter}
{\xe \v CInputParameter\:A}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double CInputParameter::A{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAADD}
{\bkmkend AAAAAAAADD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
User eingegebener Winkel A \par
}{
Definiert in Zeile {\b 135} der Datei {\b InputParameter.h}.}\par
{
\ql
Wird benutzt von {\b CInputParameter()}, {\b CInputParameter()}, {\b getAngles()} und {\b setOrientation()}.}\par
}
{\xe \v B\:CInputParameter}
{\xe \v CInputParameter\:B}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double CInputParameter::B{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAADE}
{\bkmkend AAAAAAAADE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
User eingegebener Winkel B \par
}{
Definiert in Zeile {\b 139} der Datei {\b InputParameter.h}.}\par
{
\ql
Wird benutzt von {\b CInputParameter()}, {\b CInputParameter()}, {\b getAngles()} und {\b setOrientation()}.}\par
}
{\xe \v C\:CInputParameter}
{\xe \v CInputParameter\:C}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double CInputParameter::C{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAADF}
{\bkmkend AAAAAAAADF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
User eingegebener Winkel C \par
}{
Definiert in Zeile {\b 143} der Datei {\b InputParameter.h}.}\par
{
\ql
Wird benutzt von {\b CInputParameter()}, {\b CInputParameter()}, {\b getAngles()} und {\b setOrientation()}.}\par
}
{\xe \v difference\:CInputParameter}
{\xe \v CInputParameter\:difference}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double CInputParameter::difference = 20{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAADG}
{\bkmkend AAAAAAAADG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sprung ab dem eine neue Liste angefangen wird \par
}{
Definiert in Zeile {\b 147} der Datei {\b InputParameter.h}.}\par
{
\ql
Wird benutzt von {\b detectJump()}.}\par
}
{\xe \v initialPath\:CInputParameter}
{\xe \v CInputParameter\:initialPath}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
vector<list<{\b CInputPoint3D}> > CInputParameter::initialPath{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAADH}
{\bkmkend AAAAAAAADH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Vector mit Listen an Input Daten \par
}{
Definiert in Zeile {\b 119} der Datei {\b InputParameter.h}.}\par
{
\ql
Wird benutzt von {\b getPath()} und {\b openFile()}.}\par
}
{\xe \v orientationManual\:CInputParameter}
{\xe \v CInputParameter\:orientationManual}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool CInputParameter::orientationManual{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAADI}
{\bkmkend AAAAAAAADI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Auswahl ob berechnete oder eingegebene Winkel verwendet werden soll \par
}{
Definiert in Zeile {\b 131} der Datei {\b InputParameter.h}.}\par
{
\ql
Wird benutzt von {\b CInputParameter()}, {\b CInputParameter()}, {\b getOrientationManual()} und {\b setOrientation()}.}\par
}
{\xe \v speed\:CInputParameter}
{\xe \v CInputParameter\:speed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double CInputParameter::speed{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAADJ}
{\bkmkend AAAAAAAADJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
User eingegebene Geschwindigkeit \par
}{
Definiert in Zeile {\b 123} der Datei {\b InputParameter.h}.}\par
{
\ql
Wird benutzt von {\b CInputParameter()}, {\b CInputParameter()}, {\b getSpeed()} und {\b setSpeed()}.}\par
}
{\xe \v speedManual\:CInputParameter}
{\xe \v CInputParameter\:speedManual}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool CInputParameter::speedManual{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAADK}
{\bkmkend AAAAAAAADK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Auswahl ob berechnete oder eingegebene Geschwindigkeit verwendet werden soll \par
}{
Definiert in Zeile {\b 127} der Datei {\b InputParameter.h}.}\par
{
\ql
Wird benutzt von {\b CInputParameter()}, {\b CInputParameter()}, {\b getSpeedManual()} und {\b setSpeed()}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
Die Dokumentation f\'FCr diese Klasse wurde erzeugt aufgrund der Dateien:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
header/{\b InputParameter.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
src/{\b InputParameter.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CInputPoint3D Klassenreferenz\par \pard\plain 
{\tc\tcl2 \v CInputPoint3D}
{\xe \v CInputPoint3D}
{\bkmkstart AAAAAAAADL}
{\bkmkend AAAAAAAADL}
\par
{
{\f2 #include <Point3D.h>}}\par
Klassendiagramm f\'FCr CInputPoint3D:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c_input_point3_d.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'D6ffentliche Methoden\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CInputPoint3D} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CInputPoint3D} (double {\b X}, double {\b Y}, double {\b Z}, double Timestamp, {\b CEulerMatrix} Matrix)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~CInputPoint3D} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b getTime} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CEulerMatrix} {\b getEulerMatrix} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setTime} (double time)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setEulerMatrix} ({\b CEulerMatrix} orientation)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setPoint} (double time, double {\b X}, double {\b Y}, double {\b Z}, {\b CEulerMatrix} orientation)\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
\'D6ffentliche Methoden geerbt von {\b CPoint3D}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CPoint3D} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CPoint3D} (double {\b X}, double {\b Y}, double {\b Z})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~CPoint3D} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b getX} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b getY} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b getZ} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setX} (double {\b X})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setY} (double {\b Y})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setZ} (double {\b Z})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b set} (double {\b X}, double {\b Y}, double {\b Z})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b distanceTo} ({\b CPoint3D} point)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b distanceTo} ({\b CLine3D} line)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Attribute\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b timestamp}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CEulerMatrix} {\b orientationMatrix}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Weitere Geerbte Elemente\par
\pard\plain 
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Gesch\'FCtzte Attribute geerbt von {\b CPoint3D}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b x}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b y}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b z}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Ausf\'FChrliche Beschreibung\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definiert in Zeile {\b 31} der Datei {\b Point3D.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Beschreibung der Konstruktoren und Destruktoren\par
\pard\plain 
{\xe \v CInputPoint3D\:CInputPoint3D}
{\xe \v CInputPoint3D\:CInputPoint3D}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CInputPoint3D::CInputPoint3D (void )}}
\par
{\bkmkstart AAAAAAAADM}
{\bkmkend AAAAAAAADM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definiert in Zeile {\b 101} der Datei {\b Point3D.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00101                                  : CPoint3D()\par
00102 \{\par
00103     timestamp = 0;\par
00104 \}\par
}
{
\ql
Benutzt {\b timestamp}.}\par
}
{\xe \v CInputPoint3D\:CInputPoint3D}
{\xe \v CInputPoint3D\:CInputPoint3D}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CInputPoint3D::CInputPoint3D (double  {\i X}, double  {\i Y}, double  {\i Z}, double  {\i Timestamp}, {\b CEulerMatrix}  {\i Matrix})}}
\par
{\bkmkstart AAAAAAAADN}
{\bkmkend AAAAAAAADN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definiert in Zeile {\b 106} der Datei {\b Point3D.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00107 \{\par
00108     x = X;\par
00109     y = Y;\par
00110     z = Z;\par
00111     timestamp = Timestamp;\par
00112     orientationMatrix = Matrix;\par
00113 \par
00114 \}\par
}
{
\ql
Benutzt {\b orientationMatrix}, {\b timestamp}, {\b CPoint3D::x}, {\b X}, {\b CPoint3D::y}, {\b Y}, {\b CPoint3D::z} und {\b Z}.}\par
}
{\xe \v ~CInputPoint3D\:CInputPoint3D}
{\xe \v CInputPoint3D\:~CInputPoint3D}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CInputPoint3D::~CInputPoint3D (void )}}
\par
{\bkmkstart AAAAAAAADO}
{\bkmkend AAAAAAAADO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definiert in Zeile {\b 116} der Datei {\b Point3D.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00117 \{\par
00118 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Dokumentation der Elementfunktionen\par
\pard\plain 
{\xe \v getEulerMatrix\:CInputPoint3D}
{\xe \v CInputPoint3D\:getEulerMatrix}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CEulerMatrix} CInputPoint3D::getEulerMatrix ()}}
\par
{\bkmkstart AAAAAAAADP}
{\bkmkend AAAAAAAADP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definiert in Zeile {\b 138} der Datei {\b Point3D.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00139 \{\par
00140     {\cf19 return} orientationMatrix;\par
00141 \}\par
}
{
\ql
Benutzt {\b orientationMatrix}.}\par
}
{\xe \v getTime\:CInputPoint3D}
{\xe \v CInputPoint3D\:getTime}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double CInputPoint3D::getTime ()}}
\par
{\bkmkstart AAAAAAAADQ}
{\bkmkend AAAAAAAADQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definiert in Zeile {\b 143} der Datei {\b Point3D.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00144 \{\par
00145     {\cf19 return} timestamp;\par
00146 \}\par
}
{
\ql
Benutzt {\b timestamp}.}\par
{
\ql
Wird benutzt von {\b CRobCodeGenerator::calculateSpeed()}.}\par
}
{\xe \v setEulerMatrix\:CInputPoint3D}
{\xe \v CInputPoint3D\:setEulerMatrix}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CInputPoint3D::setEulerMatrix ({\b CEulerMatrix}  {\i orientation})}}
\par
{\bkmkstart AAAAAAAADR}
{\bkmkend AAAAAAAADR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definiert in Zeile {\b 120} der Datei {\b Point3D.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00121 \{\par
00122     orientationMatrix = orientation;\par
00123 \}\par
}
{
\ql
Benutzt {\b orientationMatrix}.}\par
{
\ql
Wird benutzt von {\b CMeanFilter::calculateMean()} und {\b setPoint()}.}\par
}
{\xe \v setPoint\:CInputPoint3D}
{\xe \v CInputPoint3D\:setPoint}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CInputPoint3D::setPoint (double  {\i time}, double  {\i X}, double  {\i Y}, double  {\i Z}, {\b CEulerMatrix}  {\i orientation})}}
\par
{\bkmkstart AAAAAAAADS}
{\bkmkend AAAAAAAADS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definiert in Zeile {\b 126} der Datei {\b Point3D.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00127 \{\par
00128     setTime(time);\par
00129     set(X, Y, Z);\par
00130     setEulerMatrix(orientation);\par
00131 \}\par
}
{
\ql
Benutzt {\b CPoint3D::set()}, {\b setEulerMatrix()}, {\b setTime()}, {\b X}, {\b Y} und {\b Z}.}\par
{
\ql
Wird benutzt von {\b CInputParameter::openFile()}.}\par
}
{\xe \v setTime\:CInputPoint3D}
{\xe \v CInputPoint3D\:setTime}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CInputPoint3D::setTime (double  {\i time})}}
\par
{\bkmkstart AAAAAAAADT}
{\bkmkend AAAAAAAADT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definiert in Zeile {\b 133} der Datei {\b Point3D.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00134 \{\par
00135     timestamp = time;\par
00136 \}\par
}
{
\ql
Benutzt {\b timestamp}.}\par
{
\ql
Wird benutzt von {\b CMeanFilter::calculateMean()} und {\b setPoint()}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Dokumentation der Datenelemente\par
\pard\plain 
{\xe \v orientationMatrix\:CInputPoint3D}
{\xe \v CInputPoint3D\:orientationMatrix}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CEulerMatrix} CInputPoint3D::orientationMatrix{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAADU}
{\bkmkend AAAAAAAADU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definiert in Zeile {\b 47} der Datei {\b Point3D.h}.}\par
{
\ql
Wird benutzt von {\b CInputPoint3D()}, {\b getEulerMatrix()} und {\b setEulerMatrix()}.}\par
}
{\xe \v timestamp\:CInputPoint3D}
{\xe \v CInputPoint3D\:timestamp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double CInputPoint3D::timestamp{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAADV}
{\bkmkend AAAAAAAADV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definiert in Zeile {\b 46} der Datei {\b Point3D.h}.}\par
{
\ql
Wird benutzt von {\b CInputPoint3D()}, {\b CInputPoint3D()}, {\b getTime()} und {\b setTime()}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
Die Dokumentation f\'FCr diese Klasse wurde erzeugt aufgrund der Dateien:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
header/{\b Point3D.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
src/{\b Point3D.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CLine3D Klassenreferenz\par \pard\plain 
{\tc\tcl2 \v CLine3D}
{\xe \v CLine3D}
{\bkmkstart AAAAAAAADW}
{\bkmkend AAAAAAAADW}
\par
{
{\f2 #include <Line3D.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'D6ffentliche Methoden\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CLine3D} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CLine3D} ({\b CPoint3D} P1, {\b CPoint3D} P2)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~CLine3D} (void)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'D6ffentliche Attribute\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CPoint3D} {\b p1}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CPoint3D} {\b p2}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Ausf\'FChrliche Beschreibung\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definiert in Zeile {\b 7} der Datei {\b Line3D.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Beschreibung der Konstruktoren und Destruktoren\par
\pard\plain 
{\xe \v CLine3D\:CLine3D}
{\xe \v CLine3D\:CLine3D}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CLine3D::CLine3D (void )}}
\par
{\bkmkstart AAAAAAAADX}
{\bkmkend AAAAAAAADX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definiert in Zeile {\b 4} der Datei {\b Line3D.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00005 \{\par
00006 \}\par
}
}
{\xe \v CLine3D\:CLine3D}
{\xe \v CLine3D\:CLine3D}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CLine3D::CLine3D ({\b CPoint3D}  {\i P1}, {\b CPoint3D}  {\i P2})}}
\par
{\bkmkstart AAAAAAAADY}
{\bkmkend AAAAAAAADY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definiert in Zeile {\b 8} der Datei {\b Line3D.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00009 \{\par
00010     p1 = P1;\par
00011     p2 = P2;\par
00012 \}\par
}
{
\ql
Benutzt {\b p1} und {\b p2}.}\par
}
{\xe \v ~CLine3D\:CLine3D}
{\xe \v CLine3D\:~CLine3D}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CLine3D::~CLine3D (void )}}
\par
{\bkmkstart AAAAAAAADZ}
{\bkmkend AAAAAAAADZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definiert in Zeile {\b 14} der Datei {\b Line3D.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00015 \{\par
00016 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Dokumentation der Datenelemente\par
\pard\plain 
{\xe \v p1\:CLine3D}
{\xe \v CLine3D\:p1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CPoint3D} CLine3D::p1}}
\par
{\bkmkstart AAAAAAAAEA}
{\bkmkend AAAAAAAAEA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definiert in Zeile {\b 14} der Datei {\b Line3D.h}.}\par
{
\ql
Wird benutzt von {\b CLine3D()} und {\b CPoint3D::distanceTo()}.}\par
}
{\xe \v p2\:CLine3D}
{\xe \v CLine3D\:p2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CPoint3D} CLine3D::p2}}
\par
{\bkmkstart AAAAAAAAEB}
{\bkmkend AAAAAAAAEB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definiert in Zeile {\b 15} der Datei {\b Line3D.h}.}\par
{
\ql
Wird benutzt von {\b CLine3D()} und {\b CPoint3D::distanceTo()}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
Die Dokumentation f\'FCr diese Klasse wurde erzeugt aufgrund der Dateien:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
header/{\b Line3D.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
src/{\b Line3D.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CMeanFilter Klassenreferenz\par \pard\plain 
{\tc\tcl2 \v CMeanFilter}
{\xe \v CMeanFilter}
{\bkmkstart AAAAAAAAEC}
{\bkmkend AAAAAAAAEC}
\par
{
{\f2 #include <MeanFilter.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'D6ffentliche Methoden\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CMeanFilter} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CMeanFilter} (int Window, long lenth)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~CMeanFilter} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setWindowSize} (int Window)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b getWindowSize} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
vector< list< {\b CInputPoint3D} > > & {\b getPath} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
list< {\b CInputPoint3D} > {\b calculateMean} (list< {\b CInputPoint3D} > &segment)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b mean} (vector< list< {\b CInputPoint3D} > > &sourcePath)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Attribute\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b windowSize}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b position}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b sum}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
vector< list< {\b CInputPoint3D} > > {\b meanPath}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Ausf\'FChrliche Beschreibung\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definiert in Zeile {\b 10} der Datei {\b MeanFilter.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Beschreibung der Konstruktoren und Destruktoren\par
\pard\plain 
{\xe \v CMeanFilter\:CMeanFilter}
{\xe \v CMeanFilter\:CMeanFilter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CMeanFilter::CMeanFilter ()}}
\par
{\bkmkstart AAAAAAAAED}
{\bkmkend AAAAAAAAED}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definiert in Zeile {\b 4} der Datei {\b MeanFilter.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00005 \{\par
00006     setWindowSize(0);\par
00007 \}\par
}
{
\ql
Benutzt {\b setWindowSize()}.}\par
}
{\xe \v CMeanFilter\:CMeanFilter}
{\xe \v CMeanFilter\:CMeanFilter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CMeanFilter::CMeanFilter (int  {\i Window}, long  {\i lenth})}}
\par
{\bkmkstart AAAAAAAAEE}
{\bkmkend AAAAAAAAEE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definiert in Zeile {\b 9} der Datei {\b MeanFilter.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00010 \{\par
00011     setWindowSize(Window);\par
00012 \}\par
}
{
\ql
Benutzt {\b setWindowSize()}.}\par
}
{\xe \v ~CMeanFilter\:CMeanFilter}
{\xe \v CMeanFilter\:~CMeanFilter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CMeanFilter::~CMeanFilter ()}}
\par
{\bkmkstart AAAAAAAAEF}
{\bkmkend AAAAAAAAEF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definiert in Zeile {\b 14} der Datei {\b MeanFilter.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00015 \{\par
00016 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Dokumentation der Elementfunktionen\par
\pard\plain 
{\xe \v calculateMean\:CMeanFilter}
{\xe \v CMeanFilter\:calculateMean}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
list< {\b CInputPoint3D} > CMeanFilter::calculateMean (list< {\b CInputPoint3D} > &  {\i segment})}}
\par
{\bkmkstart AAAAAAAAEG}
{\bkmkend AAAAAAAAEG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definiert in Zeile {\b 43} der Datei {\b MeanFilter.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00044 \{\par
00045     {\cf18 double} sumX = 0, sumY = 0, sumZ = 0;        {\cf20 // oder long??}\par
00046     {\cf18 double} div = 0;\par
00047     {\cf18 int} m = 0;\par
00048     {\cf18 int} OffsetPos = 0;\par
00049     {\cf18 int} OffsetNeg = 0;\par
00050 \par
00051     CInputPoint3D p;\par
00052 \par
00053     {\cf18 size_t} inputSize = segment.size();\par
00054 \par
00055     list<CInputPoint3D>::iterator it = segment.begin();\par
00056     list<CInputPoint3D> newSegment;\par
00057 \par
00058     {\cf19 for} ({\cf18 size_t} i = 0; i < inputSize - windowSize; ++i)\par
00059     \{\par
00060         sumX = 0, sumY = 0, sumZ = 0;\par
00061         div = 0;\par
00062         p.setTime(it->getTime());\par
00063         p.setEulerMatrix(it->getEulerMatrix());\par
00064         {\cf19 for} ({\cf18 size_t} j = i; j < i + windowSize; ++j)\par
00065         \{\par
00066 \par
00067             sumX += it->getX();\par
00068             sumY += it->getY();\par
00069             sumZ += it->getZ();\par
00070             div++;\par
00071             it++;\par
00072         \}\par
00073         {\cf19 for} ({\cf18 size_t} index = windowSize; index > 0; index--)\par
00074         \{\par
00075             it--;\par
00076         \}\par
00077         p.set(sumX / div, sumY / div, sumZ / div);\par
00078         {\cf19 if}(it != segment.end())\par
00079             it++;\par
00080         newSegment.push_back(p);\par
00081 \par
00082         \par
00083     \}\par
00084     {\cf19 return} newSegment;\par
00085 \}\par
}
{
\ql
Benutzt {\b i}, {\b CPoint3D::set()}, {\b CInputPoint3D::setEulerMatrix()}, {\b CInputPoint3D::setTime()} und {\b windowSize}.}\par
{
\ql
Wird benutzt von {\b mean()}.}\par
}
{\xe \v getPath\:CMeanFilter}
{\xe \v CMeanFilter\:getPath}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
vector< list< {\b CInputPoint3D} > > & CMeanFilter::getPath ()}}
\par
{\bkmkstart AAAAAAAAEH}
{\bkmkend AAAAAAAAEH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definiert in Zeile {\b 28} der Datei {\b MeanFilter.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00029 \{\par
00030     {\cf19 return} meanPath;\par
00031 \}\par
}
{
\ql
Benutzt {\b meanPath}.}\par
{
\ql
Wird benutzt von {\b main()}.}\par
}
{\xe \v getWindowSize\:CMeanFilter}
{\xe \v CMeanFilter\:getWindowSize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CMeanFilter::getWindowSize ()}}
\par
{\bkmkstart AAAAAAAAEI}
{\bkmkend AAAAAAAAEI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definiert in Zeile {\b 23} der Datei {\b MeanFilter.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00024 \{\par
00025     {\cf19 return} windowSize;\par
00026 \}\par
}
{
\ql
Benutzt {\b windowSize}.}\par
}
{\xe \v mean\:CMeanFilter}
{\xe \v CMeanFilter\:mean}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CMeanFilter::mean (vector< list< {\b CInputPoint3D} > > &  {\i sourcePath})}}
\par
{\bkmkstart AAAAAAAAEJ}
{\bkmkend AAAAAAAAEJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definiert in Zeile {\b 33} der Datei {\b MeanFilter.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00034 \{\par
00035     list<CInputPoint3D> dummyList;\par
00036     {\cf19 for} ({\cf18 size_t} s = 0; s < sourcePath.size(); s++)\par
00037     \{\par
00038         dummyList = calculateMean(sourcePath[s]);\par
00039         meanPath.push_back(dummyList);\par
00040     \}\par
00041 \}\par
}
{
\ql
Benutzt {\b calculateMean()} und {\b meanPath}.}\par
{
\ql
Wird benutzt von {\b main()}.}\par
}
{\xe \v setWindowSize\:CMeanFilter}
{\xe \v CMeanFilter\:setWindowSize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CMeanFilter::setWindowSize (int  {\i Window})}}
\par
{\bkmkstart AAAAAAAAEK}
{\bkmkend AAAAAAAAEK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definiert in Zeile {\b 18} der Datei {\b MeanFilter.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00019 \{\par
00020     windowSize = Window;\par
00021 \}\par
}
{
\ql
Benutzt {\b windowSize}.}\par
{
\ql
Wird benutzt von {\b CMeanFilter()}, {\b CMeanFilter()} und {\b main()}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Dokumentation der Datenelemente\par
\pard\plain 
{\xe \v meanPath\:CMeanFilter}
{\xe \v CMeanFilter\:meanPath}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
vector<list<{\b CInputPoint3D}> > CMeanFilter::meanPath{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAEL}
{\bkmkend AAAAAAAAEL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definiert in Zeile {\b 31} der Datei {\b MeanFilter.h}.}\par
{
\ql
Wird benutzt von {\b getPath()} und {\b mean()}.}\par
}
{\xe \v position\:CMeanFilter}
{\xe \v CMeanFilter\:position}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CMeanFilter::position{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAEM}
{\bkmkend AAAAAAAAEM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definiert in Zeile {\b 28} der Datei {\b MeanFilter.h}.}\par
}
{\xe \v sum\:CMeanFilter}
{\xe \v CMeanFilter\:sum}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double CMeanFilter::sum{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAEN}
{\bkmkend AAAAAAAAEN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definiert in Zeile {\b 29} der Datei {\b MeanFilter.h}.}\par
}
{\xe \v windowSize\:CMeanFilter}
{\xe \v CMeanFilter\:windowSize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CMeanFilter::windowSize{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAEO}
{\bkmkend AAAAAAAAEO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definiert in Zeile {\b 27} der Datei {\b MeanFilter.h}.}\par
{
\ql
Wird benutzt von {\b calculateMean()}, {\b getWindowSize()} und {\b setWindowSize()}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
Die Dokumentation f\'FCr diese Klasse wurde erzeugt aufgrund der Dateien:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
header/{\b MeanFilter.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
src/{\b MeanFilter.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
COutputPoint3D Klassenreferenz\par \pard\plain 
{\tc\tcl2 \v COutputPoint3D}
{\xe \v COutputPoint3D}
{\bkmkstart AAAAAAAAEP}
{\bkmkend AAAAAAAAEP}
\par
{
{\f2 #include <Point3D.h>}}\par
Klassendiagramm f\'FCr COutputPoint3D:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c_output_point3_d.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'D6ffentliche Methoden\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b COutputPoint3D} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b COutputPoint3D} (double Speed, double {\b X}, double {\b Y}, double {\b Z}, double A, double B, double C)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~COutputPoint3D} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b getSpeed} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b getA} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b getB} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b getC} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setSpeed} (double {\b speed})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setA} (double A)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setB} (double B)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setC} (double C)\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
\'D6ffentliche Methoden geerbt von {\b CPoint3D}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CPoint3D} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CPoint3D} (double {\b X}, double {\b Y}, double {\b Z})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~CPoint3D} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b getX} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b getY} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b getZ} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setX} (double {\b X})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setY} (double {\b Y})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setZ} (double {\b Z})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b set} (double {\b X}, double {\b Y}, double {\b Z})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b distanceTo} ({\b CPoint3D} point)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b distanceTo} ({\b CLine3D} line)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Attribute\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b a}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b b}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b c}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b speed}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Weitere Geerbte Elemente\par
\pard\plain 
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Gesch\'FCtzte Attribute geerbt von {\b CPoint3D}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b x}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b y}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b z}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Ausf\'FChrliche Beschreibung\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definiert in Zeile {\b 50} der Datei {\b Point3D.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Beschreibung der Konstruktoren und Destruktoren\par
\pard\plain 
{\xe \v COutputPoint3D\:COutputPoint3D}
{\xe \v COutputPoint3D\:COutputPoint3D}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
COutputPoint3D::COutputPoint3D (void )}}
\par
{\bkmkstart AAAAAAAAEQ}
{\bkmkend AAAAAAAAEQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definiert in Zeile {\b 150} der Datei {\b Point3D.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00150                                    : CPoint3D()\par
00151 \{\par
00152     speed = 0;\par
00153     a = 0;\par
00154     b = 0;\par
00155     c = 0;\par
00156 \}\par
}
{
\ql
Benutzt {\b a}, {\b b}, {\b c} und {\b speed}.}\par
}
{\xe \v COutputPoint3D\:COutputPoint3D}
{\xe \v COutputPoint3D\:COutputPoint3D}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
COutputPoint3D::COutputPoint3D (double  {\i Speed}, double  {\i X}, double  {\i Y}, double  {\i Z}, double  {\i A}, double  {\i B}, double  {\i C})}}
\par
{\bkmkstart AAAAAAAAER}
{\bkmkend AAAAAAAAER}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definiert in Zeile {\b 158} der Datei {\b Point3D.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00159 \{\par
00160     speed = Speed;\par
00161     a = A;\par
00162     b = B;\par
00163     c = C;\par
00164     x = X;\par
00165     y = Y;\par
00166     z = Z;\par
00167 \}\par
}
{
\ql
Benutzt {\b a}, {\b b}, {\b c}, {\b speed}, {\b CPoint3D::x}, {\b X}, {\b CPoint3D::y}, {\b Y}, {\b CPoint3D::z} und {\b Z}.}\par
}
{\xe \v ~COutputPoint3D\:COutputPoint3D}
{\xe \v COutputPoint3D\:~COutputPoint3D}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
COutputPoint3D::~COutputPoint3D (void )}}
\par
{\bkmkstart AAAAAAAAES}
{\bkmkend AAAAAAAAES}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definiert in Zeile {\b 169} der Datei {\b Point3D.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00170 \{\par
00171 \par
00172 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Dokumentation der Elementfunktionen\par
\pard\plain 
{\xe \v getA\:COutputPoint3D}
{\xe \v COutputPoint3D\:getA}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double COutputPoint3D::getA (void )}}
\par
{\bkmkstart AAAAAAAAET}
{\bkmkend AAAAAAAAET}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definiert in Zeile {\b 174} der Datei {\b Point3D.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00175 \{\par
00176     {\cf19 return} a;\par
00177 \}\par
}
{
\ql
Benutzt {\b a}.}\par
{
\ql
Wird benutzt von {\b CRobCodeGenerator::generateRobCode()}.}\par
}
{\xe \v getB\:COutputPoint3D}
{\xe \v COutputPoint3D\:getB}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double COutputPoint3D::getB (void )}}
\par
{\bkmkstart AAAAAAAAEU}
{\bkmkend AAAAAAAAEU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definiert in Zeile {\b 179} der Datei {\b Point3D.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00180 \{\par
00181     {\cf19 return} b;\par
00182 \}\par
}
{
\ql
Benutzt {\b b}.}\par
{
\ql
Wird benutzt von {\b CRobCodeGenerator::generateRobCode()}.}\par
}
{\xe \v getC\:COutputPoint3D}
{\xe \v COutputPoint3D\:getC}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double COutputPoint3D::getC (void )}}
\par
{\bkmkstart AAAAAAAAEV}
{\bkmkend AAAAAAAAEV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definiert in Zeile {\b 184} der Datei {\b Point3D.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00185 \{\par
00186     {\cf19 return} c;\par
00187 \}\par
}
{
\ql
Benutzt {\b c}.}\par
{
\ql
Wird benutzt von {\b CRobCodeGenerator::generateRobCode()}.}\par
}
{\xe \v getSpeed\:COutputPoint3D}
{\xe \v COutputPoint3D\:getSpeed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double COutputPoint3D::getSpeed (void )}}
\par
{\bkmkstart AAAAAAAAEW}
{\bkmkend AAAAAAAAEW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definiert in Zeile {\b 189} der Datei {\b Point3D.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00190 \{\par
00191     {\cf19 return} speed;\par
00192 \}\par
}
{
\ql
Benutzt {\b speed}.}\par
{
\ql
Wird benutzt von {\b CRobCodeGenerator::generateRobCode()}.}\par
}
{\xe \v setA\:COutputPoint3D}
{\xe \v COutputPoint3D\:setA}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void COutputPoint3D::setA (double  {\i A})}}
\par
{\bkmkstart AAAAAAAAEX}
{\bkmkend AAAAAAAAEX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definiert in Zeile {\b 194} der Datei {\b Point3D.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00195 \{\par
00196     a = A;\par
00197 \}\par
}
{
\ql
Benutzt {\b a}.}\par
{
\ql
Wird benutzt von {\b CRobCodeGenerator::calculateAngles()} und {\b CRobCodeGenerator::postProcessing()}.}\par
}
{\xe \v setB\:COutputPoint3D}
{\xe \v COutputPoint3D\:setB}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void COutputPoint3D::setB (double  {\i B})}}
\par
{\bkmkstart AAAAAAAAEY}
{\bkmkend AAAAAAAAEY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definiert in Zeile {\b 199} der Datei {\b Point3D.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00200 \{\par
00201     b = B;\par
00202 \}\par
}
{
\ql
Benutzt {\b b}.}\par
{
\ql
Wird benutzt von {\b CRobCodeGenerator::calculateAngles()} und {\b CRobCodeGenerator::postProcessing()}.}\par
}
{\xe \v setC\:COutputPoint3D}
{\xe \v COutputPoint3D\:setC}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void COutputPoint3D::setC (double  {\i C})}}
\par
{\bkmkstart AAAAAAAAEZ}
{\bkmkend AAAAAAAAEZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definiert in Zeile {\b 204} der Datei {\b Point3D.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00205 \{\par
00206     c = C;\par
00207 \}\par
}
{
\ql
Benutzt {\b c}.}\par
{
\ql
Wird benutzt von {\b CRobCodeGenerator::calculateAngles()} und {\b CRobCodeGenerator::postProcessing()}.}\par
}
{\xe \v setSpeed\:COutputPoint3D}
{\xe \v COutputPoint3D\:setSpeed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void COutputPoint3D::setSpeed (double  {\i speed})}}
\par
{\bkmkstart AAAAAAAAFA}
{\bkmkend AAAAAAAAFA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definiert in Zeile {\b 209} der Datei {\b Point3D.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00210 \{\par
00211     speed = Speed;\par
00212 \}\par
}
{
\ql
Benutzt {\b speed}.}\par
{
\ql
Wird benutzt von {\b CRobCodeGenerator::postProcessing()}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Dokumentation der Datenelemente\par
\pard\plain 
{\xe \v a\:COutputPoint3D}
{\xe \v COutputPoint3D\:a}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double COutputPoint3D::a{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAFB}
{\bkmkend AAAAAAAAFB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definiert in Zeile {\b 68} der Datei {\b Point3D.h}.}\par
{
\ql
Wird benutzt von {\b COutputPoint3D()}, {\b COutputPoint3D()}, {\b getA()} und {\b setA()}.}\par
}
{\xe \v b\:COutputPoint3D}
{\xe \v COutputPoint3D\:b}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double COutputPoint3D::b{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAFC}
{\bkmkend AAAAAAAAFC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definiert in Zeile {\b 68} der Datei {\b Point3D.h}.}\par
{
\ql
Wird benutzt von {\b COutputPoint3D()}, {\b COutputPoint3D()}, {\b getB()} und {\b setB()}.}\par
}
{\xe \v c\:COutputPoint3D}
{\xe \v COutputPoint3D\:c}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double COutputPoint3D::c{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAFD}
{\bkmkend AAAAAAAAFD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definiert in Zeile {\b 68} der Datei {\b Point3D.h}.}\par
{
\ql
Wird benutzt von {\b COutputPoint3D()}, {\b COutputPoint3D()}, {\b getC()} und {\b setC()}.}\par
}
{\xe \v speed\:COutputPoint3D}
{\xe \v COutputPoint3D\:speed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double COutputPoint3D::speed{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAFE}
{\bkmkend AAAAAAAAFE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definiert in Zeile {\b 69} der Datei {\b Point3D.h}.}\par
{
\ql
Wird benutzt von {\b COutputPoint3D()}, {\b COutputPoint3D()}, {\b getSpeed()} und {\b setSpeed()}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
Die Dokumentation f\'FCr diese Klasse wurde erzeugt aufgrund der Dateien:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
header/{\b Point3D.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
src/{\b Point3D.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CPathBuilder Klassenreferenz\par \pard\plain 
{\tc\tcl2 \v CPathBuilder}
{\xe \v CPathBuilder}
{\bkmkstart AAAAAAAAFF}
{\bkmkend AAAAAAAAFF}
\par
{
{\f2 #include <PathBuilder.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'D6ffentliche Methoden\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CPathBuilder} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~CPathBuilder} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
vector< {\b CInputPoint3D} > & {\b getPath} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b createPath} (vector< list< {\b CInputPoint3D} > > &segments, string filename)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Attribute\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
vector< {\b CInputPoint3D} > {\b path}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Ausf\'FChrliche Beschreibung\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definiert in Zeile {\b 9} der Datei {\b PathBuilder.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Beschreibung der Konstruktoren und Destruktoren\par
\pard\plain 
{\xe \v CPathBuilder\:CPathBuilder}
{\xe \v CPathBuilder\:CPathBuilder}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CPathBuilder::CPathBuilder (void )}}
\par
{\bkmkstart AAAAAAAAFG}
{\bkmkend AAAAAAAAFG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definiert in Zeile {\b 3} der Datei {\b PathBuilder.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00004 \{\par
00005 \}\par
}
}
{\xe \v ~CPathBuilder\:CPathBuilder}
{\xe \v CPathBuilder\:~CPathBuilder}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CPathBuilder::~CPathBuilder (void )}}
\par
{\bkmkstart AAAAAAAAFH}
{\bkmkend AAAAAAAAFH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definiert in Zeile {\b 8} der Datei {\b PathBuilder.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00009 \{\par
00010 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Dokumentation der Elementfunktionen\par
\pard\plain 
{\xe \v createPath\:CPathBuilder}
{\xe \v CPathBuilder\:createPath}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CPathBuilder::createPath (vector< list< {\b CInputPoint3D} > > &  {\i segments}, string  {\i filename})}}
\par
{\bkmkstart AAAAAAAAFI}
{\bkmkend AAAAAAAAFI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definiert in Zeile {\b 17} der Datei {\b PathBuilder.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00018 \{\par
00019 \par
00020     FILE* fid = fopen(filename.c_str(), {\cf22 "w"});\par
00021 \par
00022     {\cf19 if} (fid == NULL)\par
00023     \{ \par
00024         cerr << {\cf22 "ERROR - Can NOT write to output file!\\n"};\par
00025         {\cf19 return};\par
00026     \}\par
00027 \par
00028     {\cf18 double} zOffset = 1.0;\par
00029 \par
00030     CInputPoint3D point; {\cf20 //startpoint}\par
00031     path.push_back(point);\par
00032 \par
00033     fprintf(fid, {\cf22 "%f %f %f\\n"}, ({\cf18 double})0, ({\cf18 double})0, ({\cf18 double})0 + zOffset);\par
00034 \par
00035     {\cf19 for} ({\cf18 size_t} s = 0; s < segments.size(); s++) {\cf20 //for all segments}\par
00036     \{\par
00037         list<CInputPoint3D>::iterator itr = segments[s].begin();\par
00038 \par
00039         point.set(({\cf18 double})itr->getX(), ({\cf18 double})itr->getY(), ({\cf18 double})itr->getZ()); {\cf20 //point over start of segment}\par
00040         path.push_back(point);\par
00041 \par
00042         fprintf(fid, {\cf22 "%f %f %f\\n"}, ({\cf18 double})itr->getX(), ({\cf18 double})itr->getY(), ({\cf18 double})itr->getZ());\par
00043         \par
00044 \par
00045         {\cf19 for} (; itr != segments[s].end(); itr++) {\cf20 //for all points in the segment}\par
00046         \{\par
00047             fprintf(fid, {\cf22 "%f %f %f\\n"}, ({\cf18 double})itr->getX(), ({\cf18 double})itr->getY(), ({\cf18 double})itr->getZ());\par
00048 \par
00049             point.set(({\cf18 double})itr->getX(), ({\cf18 double})itr->getY(), ({\cf18 double})itr->getZ());\par
00050             path.push_back(point);\par
00051 \par
00052         \}\par
00053 \par
00054         itr--;\par
00055         fprintf(fid, {\cf22 "%f %f %f\\n"}, ({\cf18 double})itr->getX(), ({\cf18 double})itr->getY(), ({\cf18 double})itr->getZ());\par
00056 \par
00057         point.set(({\cf18 double})itr->getX(), ({\cf18 double})itr->getY(), ({\cf18 double})0 + zOffset); {\cf20 //point over end of segment}\par
00058         path.push_back(point);\par
00059     \}\par
00060 \par
00061     fprintf(fid, {\cf22 "%f %f %f\\n"}, ({\cf18 double})0, ({\cf18 double})0, ({\cf18 double})0);\par
00062 \par
00063     point.set(0, 0, 0); {\cf20 //endpoint (== startpoint)}\par
00064     path.push_back(point);\par
00065 \}\par
}
{
\ql
Benutzt {\b path} und {\b CPoint3D::set()}.}\par
{
\ql
Wird benutzt von {\b main()}.}\par
}
{\xe \v getPath\:CPathBuilder}
{\xe \v CPathBuilder\:getPath}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
vector< {\b CInputPoint3D} > & CPathBuilder::getPath ()}}
\par
{\bkmkstart AAAAAAAAFJ}
{\bkmkend AAAAAAAAFJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definiert in Zeile {\b 12} der Datei {\b PathBuilder.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00013 \{\par
00014     {\cf19 return} path;\par
00015 \}\par
}
{
\ql
Benutzt {\b path}.}\par
{
\ql
Wird benutzt von {\b main()}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Dokumentation der Datenelemente\par
\pard\plain 
{\xe \v path\:CPathBuilder}
{\xe \v CPathBuilder\:path}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
vector<{\b CInputPoint3D}> CPathBuilder::path{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAFK}
{\bkmkend AAAAAAAAFK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definiert in Zeile {\b 20} der Datei {\b PathBuilder.h}.}\par
{
\ql
Wird benutzt von {\b createPath()} und {\b getPath()}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
Die Dokumentation f\'FCr diese Klasse wurde erzeugt aufgrund der Dateien:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
header/{\b PathBuilder.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
src/{\b PathBuilder.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CPathPostProcessing Klassenreferenz\par \pard\plain 
{\tc\tcl2 \v CPathPostProcessing}
{\xe \v CPathPostProcessing}
{\bkmkstart AAAAAAAAFL}
{\bkmkend AAAAAAAAFL}
\par
{
{\f2 #include <PathPostProcessing.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'D6ffentliche Methoden\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CPathPostProcessing} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CPathPostProcessing} (double speedIn, bool speedManualIn, bool orientationManualIn, double AIn, double BIn, double CIn)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~CPathPostProcessing} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
vector< {\b CPoint3D} > & {\b getProcessedPath} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b postProcessing} (vector< {\b CPoint3D} > &path)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b calculateSpeed} ({\b COutputPoint3D} &p, size_t {\b i})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b calculateAngles} ({\b COutputPoint3D} &p)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setData} (double {\b speed}, bool {\b speedManual}, bool {\b orientationManual}, tuple< double, double, double > angles)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Attribute\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
vector< {\b COutputPoint3D} > {\b processedPath}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b speed}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b speedManual}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b orientationManual}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b A}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b B}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b C}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Ausf\'FChrliche Beschreibung\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definiert in Zeile {\b 13} der Datei {\b PathPostProcessing.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Beschreibung der Konstruktoren und Destruktoren\par
\pard\plain 
{\xe \v CPathPostProcessing\:CPathPostProcessing}
{\xe \v CPathPostProcessing\:CPathPostProcessing}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CPathPostProcessing::CPathPostProcessing (void )}}
\par
{\bkmkstart AAAAAAAAFM}
{\bkmkend AAAAAAAAFM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definiert in Zeile {\b 4} der Datei {\b PathPostProcessing.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00005 \{\par
00006 \}\par
}
}
{\xe \v CPathPostProcessing\:CPathPostProcessing}
{\xe \v CPathPostProcessing\:CPathPostProcessing}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CPathPostProcessing::CPathPostProcessing (double  {\i speedIn}, bool  {\i speedManualIn}, bool  {\i orientationManualIn}, double  {\i AIn}, double  {\i BIn}, double  {\i CIn})}}
\par
{\bkmkstart AAAAAAAAFN}
{\bkmkend AAAAAAAAFN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definiert in Zeile {\b 8} der Datei {\b PathPostProcessing.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00009 \{\par
00010     speed = speedIn;\par
00011     speedManual = speedManualIn;\par
00012     orientationManual = orientationManualIn;\par
00013     A = AIn;\par
00014     B = BIn;\par
00015     C = CIn;\par
00016 \}\par
}
{
\ql
Benutzt {\b A}, {\b B}, {\b C}, {\b orientationManual}, {\b speed} und {\b speedManual}.}\par
}
{\xe \v ~CPathPostProcessing\:CPathPostProcessing}
{\xe \v CPathPostProcessing\:~CPathPostProcessing}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CPathPostProcessing::~CPathPostProcessing (void )}}
\par
{\bkmkstart AAAAAAAAFO}
{\bkmkend AAAAAAAAFO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definiert in Zeile {\b 18} der Datei {\b PathPostProcessing.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00019 \{\par
00020 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Dokumentation der Elementfunktionen\par
\pard\plain 
{\xe \v calculateAngles\:CPathPostProcessing}
{\xe \v CPathPostProcessing\:calculateAngles}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CPathPostProcessing::calculateAngles ({\b COutputPoint3D} &  {\i p})}}
\par
{\bkmkstart AAAAAAAAFP}
{\bkmkend AAAAAAAAFP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definiert in Zeile {\b 90} der Datei {\b PathPostProcessing.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00091 \{\par
00092     {\cf18 double} a, b, c;\par
00093 \par
00094     {\cf20 // Funktion in Eulermatrix aufrufen die a/b/c neu berechnet}\par
00095 \par
00096     p.setA(a);\par
00097     p.setB(b);\par
00098     p.setC(c);\par
00099 \}\par
}
{
\ql
Wird benutzt von {\b postProcessing()}.}\par
}
{\xe \v calculateSpeed\:CPathPostProcessing}
{\xe \v CPathPostProcessing\:calculateSpeed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CPathPostProcessing::calculateSpeed ({\b COutputPoint3D} &  {\i p}, size_t  {\i i})}}
\par
{\bkmkstart AAAAAAAAFQ}
{\bkmkend AAAAAAAAFQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definiert in Zeile {\b 74} der Datei {\b PathPostProcessing.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00075 \{\par
00076     {\cf18 double} distance = 0;\par
00077     {\cf18 double} time = 0;\par
00078 \par
00079     distance = processedPath[s-1].distanceTo(p); {\cf20 //Strecke zwischen p und dem Punkt zuvor}\par
00080     time = p.getTime() - processedPath[s-1].getTime(); {\cf20 //Zeit zwischen p-1 und p}\par
00081 \par
00082     speed = distance/time; {\cf20 // Berechnug Geschwindigkeit zwischen zwei Punkten}\par
00083 \par
00084     {\cf19 if} (speed > MAX_SPEED) {\cf20 //Begrenzung auf maximale Geschwindigkeit, falls Trackerdaten h\'F6heren Wert aufweisen}\par
00085     speed = MAX_SPEED;\par
00086 \par
00087     p.setSpeed(speed); {\cf20 //Zuweisung der Geschwindigkeit}\par
00088 \}\par
}
{
\ql
Benutzt {\b MAX_SPEED}, {\b processedPath} und {\b speed}.}\par
{
\ql
Wird benutzt von {\b postProcessing()}.}\par
}
{\xe \v getProcessedPath\:CPathPostProcessing}
{\xe \v CPathPostProcessing\:getProcessedPath}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
vector< {\b CPoint3D} > & CPathPostProcessing::getProcessedPath (void )}}
\par
{\bkmkstart AAAAAAAAFR}
{\bkmkend AAAAAAAAFR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definiert in Zeile {\b 32} der Datei {\b PathPostProcessing.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00033 \{\par
00034     {\cf19 return} processedPath;\par
00035 \}\par
}
{
\ql
Benutzt {\b processedPath}.}\par
}
{\xe \v postProcessing\:CPathPostProcessing}
{\xe \v CPathPostProcessing\:postProcessing}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CPathPostProcessing::postProcessing (vector< {\b CPoint3D} > &  {\i path})}}
\par
{\bkmkstart AAAAAAAAFS}
{\bkmkend AAAAAAAAFS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definiert in Zeile {\b 37} der Datei {\b PathPostProcessing.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00038 \{\par
00039     CPoint3D p;\par
00040 \par
00041     {\cf19 for} ({\cf18 size_t} s = 0; s < path.size(); s++)\par
00042     \{\par
00043         p.setPoint(path[s].getTime(), path[s].getX(), path[s].getY(), path[s].getZ(), path[s].getEulerMatrix());\par
00044         {\cf19 if} (speedManual)\par
00045         \{\par
00046             {\cf19 if} (speed > MAX_SPEED) {\cf20 //Wenn maximale Geschwindigkeit \'FCberschritten wird, Geschwindigkeit begrenzen}\par
00047             speed = MAX_SPEED;\par
00048 \par
00049             p.setSpeed(speed);\par
00050         \}\par
00051         {\cf19 else}\par
00052         \{\par
00053             {\cf19 if} (s == 0)\par
00054                 p.setSpeed(1); {\cf20 //Der erste Punkt(0) wird mit Standardgeschwindigkeit 1m/s angefahren.}\par
00055 \par
00056             {\cf19 else}\par
00057                 calculateSpeed(p, s); {\cf20 //Die Geschwindigkeit zwischen den weiteren Punkten wird berechnet.}\par
00058         \}\par
00059             \par
00060         {\cf19 if} (orientationManual)\par
00061         \{\par
00062             p.setA(A);\par
00063             p.setB(B);\par
00064             p.setC(C);\par
00065         \}\par
00066         {\cf19 else}\par
00067             calculateAngles(p);\par
00068 \par
00069         processedPath.push_back(p);\par
00070     \}\par
00071 \par
00072 \}\par
}
{
\ql
Benutzt {\b A}, {\b B}, {\b C}, {\b calculateAngles()}, {\b calculateSpeed()}, {\b MAX_SPEED}, {\b orientationManual}, {\b processedPath}, {\b speed} und {\b speedManual}.}\par
}
{\xe \v setData\:CPathPostProcessing}
{\xe \v CPathPostProcessing\:setData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CPathPostProcessing::setData (double  {\i speed}, bool  {\i speedManual}, bool  {\i orientationManual}, tuple< double, double, double >  {\i angles})}}
\par
{\bkmkstart AAAAAAAAFT}
{\bkmkend AAAAAAAAFT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definiert in Zeile {\b 22} der Datei {\b PathPostProcessing.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00023 \{\par
00024     speed = speedIn;\par
00025     speedManual = speedManualIn;\par
00026     orientationManual = orientationManualIn;\par
00027     A = get<0>(angles);\par
00028     B = get<1>(angles);\par
00029     C = get<2>(angles);\par
00030 \}\par
}
{
\ql
Benutzt {\b A}, {\b B}, {\b C}, {\b orientationManual}, {\b speed} und {\b speedManual}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Dokumentation der Datenelemente\par
\pard\plain 
{\xe \v A\:CPathPostProcessing}
{\xe \v CPathPostProcessing\:A}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double CPathPostProcessing::A{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAFU}
{\bkmkend AAAAAAAAFU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definiert in Zeile {\b 33} der Datei {\b PathPostProcessing.h}.}\par
{
\ql
Wird benutzt von {\b CPathPostProcessing()}, {\b postProcessing()} und {\b setData()}.}\par
}
{\xe \v B\:CPathPostProcessing}
{\xe \v CPathPostProcessing\:B}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double CPathPostProcessing::B{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAFV}
{\bkmkend AAAAAAAAFV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definiert in Zeile {\b 34} der Datei {\b PathPostProcessing.h}.}\par
{
\ql
Wird benutzt von {\b CPathPostProcessing()}, {\b postProcessing()} und {\b setData()}.}\par
}
{\xe \v C\:CPathPostProcessing}
{\xe \v CPathPostProcessing\:C}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double CPathPostProcessing::C{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAFW}
{\bkmkend AAAAAAAAFW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definiert in Zeile {\b 35} der Datei {\b PathPostProcessing.h}.}\par
{
\ql
Wird benutzt von {\b CPathPostProcessing()}, {\b postProcessing()} und {\b setData()}.}\par
}
{\xe \v orientationManual\:CPathPostProcessing}
{\xe \v CPathPostProcessing\:orientationManual}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool CPathPostProcessing::orientationManual{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAFX}
{\bkmkend AAAAAAAAFX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definiert in Zeile {\b 32} der Datei {\b PathPostProcessing.h}.}\par
{
\ql
Wird benutzt von {\b CPathPostProcessing()}, {\b postProcessing()} und {\b setData()}.}\par
}
{\xe \v processedPath\:CPathPostProcessing}
{\xe \v CPathPostProcessing\:processedPath}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
vector<{\b COutputPoint3D}> CPathPostProcessing::processedPath{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAFY}
{\bkmkend AAAAAAAAFY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definiert in Zeile {\b 29} der Datei {\b PathPostProcessing.h}.}\par
{
\ql
Wird benutzt von {\b calculateSpeed()}, {\b getProcessedPath()} und {\b postProcessing()}.}\par
}
{\xe \v speed\:CPathPostProcessing}
{\xe \v CPathPostProcessing\:speed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double CPathPostProcessing::speed{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAFZ}
{\bkmkend AAAAAAAAFZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definiert in Zeile {\b 30} der Datei {\b PathPostProcessing.h}.}\par
{
\ql
Wird benutzt von {\b calculateSpeed()}, {\b CPathPostProcessing()}, {\b postProcessing()} und {\b setData()}.}\par
}
{\xe \v speedManual\:CPathPostProcessing}
{\xe \v CPathPostProcessing\:speedManual}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool CPathPostProcessing::speedManual{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAGA}
{\bkmkend AAAAAAAAGA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definiert in Zeile {\b 31} der Datei {\b PathPostProcessing.h}.}\par
{
\ql
Wird benutzt von {\b CPathPostProcessing()}, {\b postProcessing()} und {\b setData()}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
Die Dokumentation f\'FCr diese Klasse wurde erzeugt aufgrund der Dateien:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
header/{\b PathPostProcessing.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
src/{\b PathPostProcessing.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CPoint3D Klassenreferenz\par \pard\plain 
{\tc\tcl2 \v CPoint3D}
{\xe \v CPoint3D}
{\bkmkstart AAAAAAAAGB}
{\bkmkend AAAAAAAAGB}
\par
{
{\f2 #include <Point3D.h>}}\par
Klassendiagramm f\'FCr CPoint3D:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_c_point3_d.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'D6ffentliche Methoden\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CPoint3D} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CPoint3D} (double {\b X}, double {\b Y}, double {\b Z})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~CPoint3D} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b getX} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b getY} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b getZ} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setX} (double {\b X})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setY} (double {\b Y})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setZ} (double {\b Z})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b set} (double {\b X}, double {\b Y}, double {\b Z})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b distanceTo} ({\b CPoint3D} point)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b distanceTo} ({\b CLine3D} line)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Gesch\'FCtzte Attribute\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b x}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b y}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b z}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Ausf\'FChrliche Beschreibung\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definiert in Zeile {\b 8} der Datei {\b Point3D.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Beschreibung der Konstruktoren und Destruktoren\par
\pard\plain 
{\xe \v CPoint3D\:CPoint3D}
{\xe \v CPoint3D\:CPoint3D}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CPoint3D::CPoint3D (void )}}
\par
{\bkmkstart AAAAAAAAGC}
{\bkmkend AAAAAAAAGC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definiert in Zeile {\b 7} der Datei {\b Point3D.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00008 \{\par
00009     x = 0;\par
00010     y = 0;\par
00011     z = 0;\par
00012 \}\par
}
{
\ql
Benutzt {\b x}, {\b y} und {\b z}.}\par
}
{\xe \v CPoint3D\:CPoint3D}
{\xe \v CPoint3D\:CPoint3D}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CPoint3D::CPoint3D (double  {\i X}, double  {\i Y}, double  {\i Z})}}
\par
{\bkmkstart AAAAAAAAGD}
{\bkmkend AAAAAAAAGD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definiert in Zeile {\b 14} der Datei {\b Point3D.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00015 \{\par
00016     x = X;\par
00017     y = Y;\par
00018     z = Z;\par
00019 \}\par
}
{
\ql
Benutzt {\b x}, {\b X}, {\b y}, {\b Y}, {\b z} und {\b Z}.}\par
}
{\xe \v ~CPoint3D\:CPoint3D}
{\xe \v CPoint3D\:~CPoint3D}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CPoint3D::~CPoint3D (void )}}
\par
{\bkmkstart AAAAAAAAGE}
{\bkmkend AAAAAAAAGE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definiert in Zeile {\b 21} der Datei {\b Point3D.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00022 \{\par
00023 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Dokumentation der Elementfunktionen\par
\pard\plain 
{\xe \v distanceTo\:CPoint3D}
{\xe \v CPoint3D\:distanceTo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double CPoint3D::distanceTo ({\b CLine3D}  {\i line})}}
\par
{\bkmkstart AAAAAAAAGF}
{\bkmkend AAAAAAAAGF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definiert in Zeile {\b 67} der Datei {\b Point3D.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00068 \{\par
00069     {\cf18 double} bx, by, bz, rv_sq, dist, vp1, vp2, vp3;          {\cf20 // Variablen Anlegen}\par
00070 \par
00071     {\cf20 /*}\par
00072 {\cf20     Vermessen wird der Punkt selbst}\par
00073 {\cf20 }\par
00074 {\cf20     bx, by, bz      == Vektordifferenz}\par
00075 {\cf20     rv_sq           == Betrag des Linienvektors}\par
00076 {\cf20     dist            == Distanz von Punkt zu Linie}\par
00077 {\cf20     vp1, vp2, vp3   == Vektorprodukte}\par
00078 {\cf20     */}\par
00079 \par
00080     {\cf18 int} rvx = line.p1.x - line.p2.x;        {\cf20 // Parameter X des Linienvektor berechnen}\par
00081     {\cf18 int} rvy = line.p1.y - line.p2.y;        {\cf20 // Parameter Y des Linienvektor berechnen}\par
00082     {\cf18 int} rvz = line.p1.z - line.p2.z;        {\cf20 // Parameter Z des Linienvektor berechnen}\par
00083 \par
00084     rv_sq = sqrt((({\cf18 double})rvx * ({\cf18 double})rvx) + (({\cf18 double})rvy * ({\cf18 double})rvy) + (({\cf18 double})rvz * ({\cf18 double})rvz));      {\cf20 // Betrag des Linienvektor berechnen}\par
00085 \par
00086     bx = x - (double)line.p1.x;             {\cf20 // X(Punkt) - X(Aufpunkt) }\par
00087     by = y - (double)line.p1.y;             {\cf20 // Y(Punkt) - Y(Aufpunkt)}\par
00088     bz = z - (double)line.p1.z;             {\cf20 // Z(Punkt) - Z(Aufpunkt)}\par
00089 \par
00090     vp1 = by * rvz - bz * rvy;              {\cf20 // Parameter X Vektorprodukt}\par
00091     vp2 = bz * rvx - bx * rvz;              {\cf20 // Parameter Y Vektorprodukt}\par
00092     vp3 = bx * rvy - by * rvx;              {\cf20 // Parameter Z Vektorprodukt}\par
00093 \par
00094     dist = sqrt(vp1 * vp1 + vp2 * vp2 + vp3 * vp3) / rv_sq; {\cf20 // Betrag des Vektors berechnen}\par
00095 \par
00096     {\cf19 return} dist;\par
00097 \}\par
}
{
\ql
Benutzt {\b CLine3D::p1}, {\b CLine3D::p2}, {\b x}, {\b y} und {\b z}.}\par
}
{\xe \v distanceTo\:CPoint3D}
{\xe \v CPoint3D\:distanceTo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double CPoint3D::distanceTo ({\b CPoint3D}  {\i point})}}
\par
{\bkmkstart AAAAAAAAGG}
{\bkmkend AAAAAAAAGG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definiert in Zeile {\b 62} der Datei {\b Point3D.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00063 \{\par
00064     {\cf19 return} sqrt(pow(({\cf18 double})(x - ({\cf18 double})point.getX()), 2) + pow(({\cf18 double})(y - ({\cf18 double})point.getY()), 2) + pow(({\cf18 double})(z - ({\cf18 double})point.getZ()), 2));  {\cf20 // Pythagoras 3D}\par
00065 \}\par
}
{
\ql
Benutzt {\b getX()}, {\b getY()}, {\b getZ()}, {\b x}, {\b y} und {\b z}.}\par
}
{\xe \v getX\:CPoint3D}
{\xe \v CPoint3D\:getX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double CPoint3D::getX (void )}}
\par
{\bkmkstart AAAAAAAAGH}
{\bkmkend AAAAAAAAGH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definiert in Zeile {\b 25} der Datei {\b Point3D.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00026 \{\par
00027     {\cf19 return} x;\par
00028 \}\par
}
{
\ql
Benutzt {\b x}.}\par
{
\ql
Wird benutzt von {\b CInputParameter::detectJump()}, {\b distanceTo()} und {\b CRobCodeGenerator::generateRobCode()}.}\par
}
{\xe \v getY\:CPoint3D}
{\xe \v CPoint3D\:getY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double CPoint3D::getY (void )}}
\par
{\bkmkstart AAAAAAAAGI}
{\bkmkend AAAAAAAAGI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definiert in Zeile {\b 30} der Datei {\b Point3D.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00031 \{\par
00032     {\cf19 return} y;\par
00033 \}\par
}
{
\ql
Benutzt {\b y}.}\par
{
\ql
Wird benutzt von {\b CInputParameter::detectJump()}, {\b distanceTo()} und {\b CRobCodeGenerator::generateRobCode()}.}\par
}
{\xe \v getZ\:CPoint3D}
{\xe \v CPoint3D\:getZ}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double CPoint3D::getZ (void )}}
\par
{\bkmkstart AAAAAAAAGJ}
{\bkmkend AAAAAAAAGJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definiert in Zeile {\b 35} der Datei {\b Point3D.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00036 \{\par
00037     {\cf19 return} z;\par
00038 \}\par
}
{
\ql
Benutzt {\b z}.}\par
{
\ql
Wird benutzt von {\b CInputParameter::detectJump()}, {\b distanceTo()} und {\b CRobCodeGenerator::generateRobCode()}.}\par
}
{\xe \v set\:CPoint3D}
{\xe \v CPoint3D\:set}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CPoint3D::set (double  {\i X}, double  {\i Y}, double  {\i Z})}}
\par
{\bkmkstart AAAAAAAAGK}
{\bkmkend AAAAAAAAGK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definiert in Zeile {\b 55} der Datei {\b Point3D.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00056 \{\par
00057     x = X;\par
00058     y = Y;\par
00059     z = Z;\par
00060 \}\par
}
{
\ql
Benutzt {\b x}, {\b X}, {\b y}, {\b Y}, {\b z} und {\b Z}.}\par
{
\ql
Wird benutzt von {\b CMeanFilter::calculateMean()}, {\b CPathBuilder::createPath()}, {\b CRobCodeGenerator::generateRobCode()}, {\b CRobCodeGenerator::postProcessing()} und {\b CInputPoint3D::setPoint()}.}\par
}
{\xe \v setX\:CPoint3D}
{\xe \v CPoint3D\:setX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CPoint3D::setX (double  {\i X})}}
\par
{\bkmkstart AAAAAAAAGL}
{\bkmkend AAAAAAAAGL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definiert in Zeile {\b 40} der Datei {\b Point3D.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00041 \{\par
00042     x = X;\par
00043 \}\par
}
{
\ql
Benutzt {\b x} und {\b X}.}\par
{
\ql
Wird benutzt von {\b CSegmentApproximator::douglasPeuckerRecursive()}.}\par
}
{\xe \v setY\:CPoint3D}
{\xe \v CPoint3D\:setY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CPoint3D::setY (double  {\i Y})}}
\par
{\bkmkstart AAAAAAAAGM}
{\bkmkend AAAAAAAAGM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definiert in Zeile {\b 45} der Datei {\b Point3D.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00046 \{\par
00047     y = Y;\par
00048 \}\par
}
{
\ql
Benutzt {\b y} und {\b Y}.}\par
{
\ql
Wird benutzt von {\b CSegmentApproximator::douglasPeuckerRecursive()}.}\par
}
{\xe \v setZ\:CPoint3D}
{\xe \v CPoint3D\:setZ}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CPoint3D::setZ (double  {\i Z})}}
\par
{\bkmkstart AAAAAAAAGN}
{\bkmkend AAAAAAAAGN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definiert in Zeile {\b 50} der Datei {\b Point3D.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00051 \{\par
00052     z = Z;\par
00053 \}\par
}
{
\ql
Benutzt {\b z} und {\b Z}.}\par
{
\ql
Wird benutzt von {\b CSegmentApproximator::douglasPeuckerRecursive()}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Dokumentation der Datenelemente\par
\pard\plain 
{\xe \v x\:CPoint3D}
{\xe \v CPoint3D\:x}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double CPoint3D::x{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAGO}
{\bkmkend AAAAAAAAGO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definiert in Zeile {\b 28} der Datei {\b Point3D.h}.}\par
{
\ql
Wird benutzt von {\b CInputPoint3D::CInputPoint3D()}, {\b COutputPoint3D::COutputPoint3D()}, {\b CPoint3D()}, {\b CPoint3D()}, {\b distanceTo()}, {\b distanceTo()}, {\b getX()}, {\b set()} und {\b setX()}.}\par
}
{\xe \v y\:CPoint3D}
{\xe \v CPoint3D\:y}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double CPoint3D::y{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAGP}
{\bkmkend AAAAAAAAGP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definiert in Zeile {\b 28} der Datei {\b Point3D.h}.}\par
{
\ql
Wird benutzt von {\b CInputPoint3D::CInputPoint3D()}, {\b COutputPoint3D::COutputPoint3D()}, {\b CPoint3D()}, {\b CPoint3D()}, {\b distanceTo()}, {\b distanceTo()}, {\b getY()}, {\b set()} und {\b setY()}.}\par
}
{\xe \v z\:CPoint3D}
{\xe \v CPoint3D\:z}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double CPoint3D::z{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAGQ}
{\bkmkend AAAAAAAAGQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definiert in Zeile {\b 28} der Datei {\b Point3D.h}.}\par
{
\ql
Wird benutzt von {\b CInputPoint3D::CInputPoint3D()}, {\b COutputPoint3D::COutputPoint3D()}, {\b CPoint3D()}, {\b CPoint3D()}, {\b distanceTo()}, {\b distanceTo()}, {\b getZ()}, {\b set()} und {\b setZ()}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
Die Dokumentation f\'FCr diese Klasse wurde erzeugt aufgrund der Dateien:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
header/{\b Point3D.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
src/{\b Point3D.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CRobCodeGenerator Klassenreferenz\par \pard\plain 
{\tc\tcl2 \v CRobCodeGenerator}
{\xe \v CRobCodeGenerator}
{\bkmkstart AAAAAAAAGR}
{\bkmkend AAAAAAAAGR}
\par
{
{\f2 #include <RobCodeGenerator.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'D6ffentliche Methoden\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CRobCodeGenerator} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CRobCodeGenerator} (double speedIn, bool speedManualIn, bool orientationManualIn, tuple< double, double, double > angles)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~CRobCodeGenerator} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b generateRobCode} (vector< {\b CInputPoint3D} > &path, string filename)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b postProcessing} (vector< {\b CInputPoint3D} > &path)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b calculateSpeed} ({\b CInputPoint3D} &p, size_t {\b i}, double timePrev)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b calculateAngles} ({\b COutputPoint3D} &p, {\b CInputPoint3D} &pIn)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Attribute\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
vector< {\b COutputPoint3D} > {\b processedPath}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b speed}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b speedManual}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b orientationManual}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b A}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b B}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b C}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Ausf\'FChrliche Beschreibung\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definiert in Zeile {\b 12} der Datei {\b RobCodeGenerator.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Beschreibung der Konstruktoren und Destruktoren\par
\pard\plain 
{\xe \v CRobCodeGenerator\:CRobCodeGenerator}
{\xe \v CRobCodeGenerator\:CRobCodeGenerator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CRobCodeGenerator::CRobCodeGenerator (void )}}
\par
{\bkmkstart AAAAAAAAGS}
{\bkmkend AAAAAAAAGS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definiert in Zeile {\b 5} der Datei {\b RobCodeGenerator.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00006 \{\par
00007     speed = 0;\par
00008     speedManual = 0;\par
00009     orientationManual = 0;\par
00010     A = 0;\par
00011     B = 0;\par
00012     C = 0;\par
00013 \}\par
}
{
\ql
Benutzt {\b A}, {\b B}, {\b C}, {\b orientationManual}, {\b speed} und {\b speedManual}.}\par
}
{\xe \v CRobCodeGenerator\:CRobCodeGenerator}
{\xe \v CRobCodeGenerator\:CRobCodeGenerator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CRobCodeGenerator::CRobCodeGenerator (double  {\i speedIn}, bool  {\i speedManualIn}, bool  {\i orientationManualIn}, tuple< double, double, double >  {\i angles})}}
\par
{\bkmkstart AAAAAAAAGT}
{\bkmkend AAAAAAAAGT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definiert in Zeile {\b 15} der Datei {\b RobCodeGenerator.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00016 \{\par
00017     speed = Speed;\par
00018     speedManual = SpeedManual;\par
00019     orientationManual = OrientationManual;\par
00020     A = get<0>(angles);\par
00021     B = get<1>(angles);\par
00022     C = get<2>(angles);\par
00023 \}\par
}
{
\ql
Benutzt {\b A}, {\b B}, {\b C}, {\b orientationManual}, {\b speed} und {\b speedManual}.}\par
}
{\xe \v ~CRobCodeGenerator\:CRobCodeGenerator}
{\xe \v CRobCodeGenerator\:~CRobCodeGenerator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CRobCodeGenerator::~CRobCodeGenerator (void )}}
\par
{\bkmkstart AAAAAAAAGU}
{\bkmkend AAAAAAAAGU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definiert in Zeile {\b 25} der Datei {\b RobCodeGenerator.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00026 \{\par
00027 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Dokumentation der Elementfunktionen\par
\pard\plain 
{\xe \v calculateAngles\:CRobCodeGenerator}
{\xe \v CRobCodeGenerator\:calculateAngles}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CRobCodeGenerator::calculateAngles ({\b COutputPoint3D} &  {\i p}, {\b CInputPoint3D} &  {\i pIn})}}
\par
{\bkmkstart AAAAAAAAGV}
{\bkmkend AAAAAAAAGV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definiert in Zeile {\b 125} der Datei {\b RobCodeGenerator.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00126 \{\par
00127     {\cf18 double} a, b, c;\par
00128 \par
00129     {\cf20 // Funktion in Eulermatrix aufrufen die a/b/c neu berechnet}\par
00130 \par
00131     p.setA(a);\par
00132     p.setB(b);\par
00133     p.setC(c);\par
00134 \}\par
}
{
\ql
Benutzt {\b COutputPoint3D::setA()}, {\b COutputPoint3D::setB()} und {\b COutputPoint3D::setC()}.}\par
{
\ql
Wird benutzt von {\b postProcessing()}.}\par
}
{\xe \v calculateSpeed\:CRobCodeGenerator}
{\xe \v CRobCodeGenerator\:calculateSpeed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double CRobCodeGenerator::calculateSpeed ({\b CInputPoint3D} &  {\i p}, size_t  {\i i}, double  {\i timePrev})}}
\par
{\bkmkstart AAAAAAAAGW}
{\bkmkend AAAAAAAAGW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definiert in Zeile {\b 109} der Datei {\b RobCodeGenerator.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00110 \{\par
00111     {\cf18 double} distance = 0;\par
00112     {\cf18 double} time = 0;\par
00113 \par
00114     distance = processedPath[s - 1].distanceTo(p); {\cf20 //Strecke zwischen p und dem Punkt zuvor}\par
00115     time = p.getTime() - timePrev; {\cf20 //Zeit zwischen p-1 und p}\par
00116 \par
00117     speed = distance / time; {\cf20 // Berechnug Geschwindigkeit zwischen zwei Punkten}\par
00118 \par
00119     {\cf19 if} (speed > MAX_SPEED) {\cf20 //Begrenzung auf maximale Geschwindigkeit, falls Trackerdaten h\'F6heren Wert aufweisen}\par
00120         speed = MAX_SPEED;\par
00121 \par
00122     {\cf19 return} speed; {\cf20 //Zuweisung der Geschwindigkeit}\par
00123 \}\par
}
{
\ql
Benutzt {\b CInputPoint3D::getTime()}, {\b MAX_SPEED}, {\b processedPath} und {\b speed}.}\par
{
\ql
Wird benutzt von {\b postProcessing()}.}\par
}
{\xe \v generateRobCode\:CRobCodeGenerator}
{\xe \v CRobCodeGenerator\:generateRobCode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CRobCodeGenerator::generateRobCode (vector< {\b CInputPoint3D} > &  {\i path}, string  {\i filename})}}
\par
{\bkmkstart AAAAAAAAGX}
{\bkmkend AAAAAAAAGX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definiert in Zeile {\b 29} der Datei {\b RobCodeGenerator.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00030 \{\par
00031     postProcessing(points);\par
00032 \par
00033     errno_t err;\par
00034     \par
00035     FILE* fid;\par
00036 \par
00037     {\cf19 if} ((err = fopen_s(&fid, filename.c_str(), {\cf22 "w"})) != 0)\par
00038     \{ \par
00039         {\cf18 string} msg = {\cf22 "Open file: "};\par
00040         msg += filename;\par
00041         msg += {\cf22 " failed!"};\par
00042 \par
00043         {\cf19 throw} exception(msg.c_str());\par
00044     \}\par
00045 \par
00046     COutputPoint3D currentPoint;\par
00047 \par
00048     filename.erase(filename.end()-4,filename.end());\par
00049     fprintf(fid, {\cf22 "DEF %s \\n"}, filename.c_str());\par
00050 \par
00051     fputs({\cf22 "PTP $POS_ACT\\n"}, fid);\par
00052 \par
00053     {\cf19 if} (speedManual)\par
00054     \{\par
00055         fprintf(fid, {\cf22 "&VEL.CP %f"}, speed);\par
00056     \}\par
00057 \par
00058     {\cf19 for} ({\cf18 size_t} s = 0; s < points.size(); s++)\par
00059     \{\par
00060         currentPoint.set(points[s].getX(),points[s].getY(),points[s].getZ());\par
00061         \par
00062         {\cf20 //currentPoint = Transformation * currentPoint; //Here wee need a transformationmatrix containing public parameters scaleX,offsetX...}\par
00063         {\cf19 if}(!speedManual)\par
00064             fprintf(fid, {\cf22 "&VEL.CP %f"}, currentPoint.getSpeed());\par
00065         fprintf(fid, {\cf22 "LIN \{X %f, Y %f, Z %f, A %f, B %f, C %f\}\\n"}, currentPoint.getX(), currentPoint.getY(), currentPoint.getZ(), \par
00066             currentPoint.getA(), currentPoint.getB(), currentPoint.getC());\par
00067     \}\par
00068 \par
00069     fputs({\cf22 "END"}, fid);\par
00070 \}\par
}
{
\ql
Benutzt {\b COutputPoint3D::getA()}, {\b COutputPoint3D::getB()}, {\b COutputPoint3D::getC()}, {\b COutputPoint3D::getSpeed()}, {\b CPoint3D::getX()}, {\b CPoint3D::getY()}, {\b CPoint3D::getZ()}, {\b postProcessing()}, {\b CPoint3D::set()}, {\b speed} und {\b speedManual}.}\par
{
\ql
Wird benutzt von {\b main()}.}\par
}
{\xe \v postProcessing\:CRobCodeGenerator}
{\xe \v CRobCodeGenerator\:postProcessing}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CRobCodeGenerator::postProcessing (vector< {\b CInputPoint3D} > &  {\i path})}}
\par
{\bkmkstart AAAAAAAAGY}
{\bkmkend AAAAAAAAGY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definiert in Zeile {\b 72} der Datei {\b RobCodeGenerator.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00073 \{\par
00074     COutputPoint3D p;\par
00075     CInputPoint3D  pIn;\par
00076     {\cf18 double} timePrev = 0;\par
00077 \par
00078     {\cf19 for} ({\cf18 size_t} s = 0; s < path.size(); s++)\par
00079     \{\par
00080         p.set(path[s].getX(), path[s].getY(), path[s].getZ());\par
00081         {\cf19 if} (speedManual)\par
00082         \{\par
00083             {\cf19 if} (speed > MAX_SPEED) {\cf20 //Wenn maximale Geschwindigkeit \'FCberschritten wird, Geschwindigkeit begrenzen}\par
00084                 speed = MAX_SPEED;\par
00085         \}\par
00086         {\cf19 else}\par
00087         \{\par
00088             {\cf19 if} (s == 0)\par
00089                 p.setSpeed(1); {\cf20 //Der erste Punkt(0) wird mit Standardgeschwindigkeit 1m/s angefahren.}\par
00090 \par
00091             {\cf19 else}\par
00092                 p.setSpeed(calculateSpeed(path[s], s, timePrev)); {\cf20 //Die Geschwindigkeit zwischen den weiteren Punkten wird berechnet.}\par
00093         \}\par
00094 \par
00095         {\cf19 if} (!orientationManual)\par
00096         \{\par
00097             p.setA(A);\par
00098             p.setB(B);\par
00099             p.setC(C);\par
00100         \}\par
00101         {\cf19 else}\par
00102             calculateAngles(p, pIn);\par
00103         timePrev = path[s].getTime();\par
00104         processedPath.push_back(p);\par
00105     \}\par
00106 \par
00107 \}\par
}
{
\ql
Benutzt {\b A}, {\b B}, {\b C}, {\b calculateAngles()}, {\b calculateSpeed()}, {\b MAX_SPEED}, {\b orientationManual}, {\b processedPath}, {\b CPoint3D::set()}, {\b COutputPoint3D::setA()}, {\b COutputPoint3D::setB()}, {\b COutputPoint3D::setC()}, {\b COutputPoint3D::setSpeed()}, {\b speed} und {\b speedManual}.}\par
{
\ql
Wird benutzt von {\b generateRobCode()}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Dokumentation der Datenelemente\par
\pard\plain 
{\xe \v A\:CRobCodeGenerator}
{\xe \v CRobCodeGenerator\:A}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double CRobCodeGenerator::A{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAGZ}
{\bkmkend AAAAAAAAGZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definiert in Zeile {\b 29} der Datei {\b RobCodeGenerator.h}.}\par
{
\ql
Wird benutzt von {\b CRobCodeGenerator()}, {\b CRobCodeGenerator()} und {\b postProcessing()}.}\par
}
{\xe \v B\:CRobCodeGenerator}
{\xe \v CRobCodeGenerator\:B}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double CRobCodeGenerator::B{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAHA}
{\bkmkend AAAAAAAAHA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definiert in Zeile {\b 30} der Datei {\b RobCodeGenerator.h}.}\par
{
\ql
Wird benutzt von {\b CRobCodeGenerator()}, {\b CRobCodeGenerator()} und {\b postProcessing()}.}\par
}
{\xe \v C\:CRobCodeGenerator}
{\xe \v CRobCodeGenerator\:C}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double CRobCodeGenerator::C{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAHB}
{\bkmkend AAAAAAAAHB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definiert in Zeile {\b 31} der Datei {\b RobCodeGenerator.h}.}\par
{
\ql
Wird benutzt von {\b CRobCodeGenerator()}, {\b CRobCodeGenerator()} und {\b postProcessing()}.}\par
}
{\xe \v orientationManual\:CRobCodeGenerator}
{\xe \v CRobCodeGenerator\:orientationManual}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool CRobCodeGenerator::orientationManual{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAHC}
{\bkmkend AAAAAAAAHC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definiert in Zeile {\b 28} der Datei {\b RobCodeGenerator.h}.}\par
{
\ql
Wird benutzt von {\b CRobCodeGenerator()}, {\b CRobCodeGenerator()} und {\b postProcessing()}.}\par
}
{\xe \v processedPath\:CRobCodeGenerator}
{\xe \v CRobCodeGenerator\:processedPath}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
vector<{\b COutputPoint3D}> CRobCodeGenerator::processedPath{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAHD}
{\bkmkend AAAAAAAAHD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definiert in Zeile {\b 25} der Datei {\b RobCodeGenerator.h}.}\par
{
\ql
Wird benutzt von {\b calculateSpeed()} und {\b postProcessing()}.}\par
}
{\xe \v speed\:CRobCodeGenerator}
{\xe \v CRobCodeGenerator\:speed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double CRobCodeGenerator::speed{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAHE}
{\bkmkend AAAAAAAAHE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definiert in Zeile {\b 26} der Datei {\b RobCodeGenerator.h}.}\par
{
\ql
Wird benutzt von {\b calculateSpeed()}, {\b CRobCodeGenerator()}, {\b CRobCodeGenerator()}, {\b generateRobCode()} und {\b postProcessing()}.}\par
}
{\xe \v speedManual\:CRobCodeGenerator}
{\xe \v CRobCodeGenerator\:speedManual}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool CRobCodeGenerator::speedManual{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAHF}
{\bkmkend AAAAAAAAHF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definiert in Zeile {\b 27} der Datei {\b RobCodeGenerator.h}.}\par
{
\ql
Wird benutzt von {\b CRobCodeGenerator()}, {\b CRobCodeGenerator()}, {\b generateRobCode()} und {\b postProcessing()}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
Die Dokumentation f\'FCr diese Klasse wurde erzeugt aufgrund der Dateien:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
header/{\b RobCodeGenerator.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
src/{\b RobCodeGenerator.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CSegmentApproximator Klassenreferenz\par \pard\plain 
{\tc\tcl2 \v CSegmentApproximator}
{\xe \v CSegmentApproximator}
{\bkmkstart AAAAAAAAHG}
{\bkmkend AAAAAAAAHG}
\par
{
{\f2 #include <SegmentApproximator.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
\'D6ffentliche Methoden\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CSegmentApproximator} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~CSegmentApproximator} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b approx} (const vector< list< {\b CInputPoint3D} > > &Segments)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setmaxDistance} (double maxDistanceSource)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b getmaxDistance} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
vector< list< {\b CInputPoint3D} > > & {\b getSegmentsApproxVector} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Methoden\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b douglasPeuckerRecursive} (list< {\b CInputPoint3D} > &segment, std::list< {\b CInputPoint3D} >::iterator startItr, std::list< {\b CInputPoint3D} >::iterator endItr, double {\b maxDistance})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b calcDist} (int xS, int yS, int zS, int xE, int yE, int zE, int x, int y, int z)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Attribute\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
vector< list< {\b CInputPoint3D} > > {\b segmentsApprox}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b maxDistance}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Ausf\'FChrliche Beschreibung\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definiert in Zeile {\b 11} der Datei {\b SegmentApproximator.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Beschreibung der Konstruktoren und Destruktoren\par
\pard\plain 
{\xe \v CSegmentApproximator\:CSegmentApproximator}
{\xe \v CSegmentApproximator\:CSegmentApproximator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CSegmentApproximator::CSegmentApproximator (void )}}
\par
{\bkmkstart AAAAAAAAHH}
{\bkmkend AAAAAAAAHH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definiert in Zeile {\b 5} der Datei {\b SegmentApproximator.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00006 \{\par
00007 \}\par
}
}
{\xe \v ~CSegmentApproximator\:CSegmentApproximator}
{\xe \v CSegmentApproximator\:~CSegmentApproximator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CSegmentApproximator::~CSegmentApproximator (void )}}
\par
{\bkmkstart AAAAAAAAHI}
{\bkmkend AAAAAAAAHI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definiert in Zeile {\b 9} der Datei {\b SegmentApproximator.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00010 \{\par
00011 \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Dokumentation der Elementfunktionen\par
\pard\plain 
{\xe \v approx\:CSegmentApproximator}
{\xe \v CSegmentApproximator\:approx}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CSegmentApproximator::approx (const vector< list< {\b CInputPoint3D} > > &  {\i Segments})}}
\par
{\bkmkstart AAAAAAAAHJ}
{\bkmkend AAAAAAAAHJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definiert in Zeile {\b 13} der Datei {\b SegmentApproximator.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00014 \{\par
00015     CInputPoint3D p;\par
00016 \par
00017     segmentsApprox = segments;\par
00018 \par
00019     {\cf19 for} ({\cf18 size_t} s = 0; s < segments.size(); s++)\par
00020     \{\par
00021         douglasPeuckerRecursive(segmentsApprox[s], segmentsApprox[s].begin(), --(segmentsApprox[s].end()), maxDistance);\par
00022     \}\par
00023 \par
00024 \}\par
}
{
\ql
Benutzt {\b douglasPeuckerRecursive()}, {\b maxDistance} und {\b segmentsApprox}.}\par
{
\ql
Wird benutzt von {\b main()}.}\par
}
{\xe \v calcDist\:CSegmentApproximator}
{\xe \v CSegmentApproximator\:calcDist}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double CSegmentApproximator::calcDist (int  {\i xS}, int  {\i yS}, int  {\i zS}, int  {\i xE}, int  {\i yE}, int  {\i zE}, int  {\i x}, int  {\i y}, int  {\i z}){\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAHK}
{\bkmkend AAAAAAAAHK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definiert in Zeile {\b 81} der Datei {\b SegmentApproximator.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00082 \{\par
00083     {\cf20 /*}\par
00084 {\cf20     xS, yS, zS      == Startpunkt}\par
00085 {\cf20     xE, yE, zE      == Endpunkt}\par
00086 {\cf20     x, y, z         == Vermessungspunkt}\par
00087 {\cf20     */}\par
00088 \par
00089     {\cf20 //Crossproduct}\par
00090     {\cf18 double} bx, by, bz, rv_sq, dist, vp1, vp2, vp3;\par
00091 \par
00092     {\cf20 /*}\par
00093 {\cf20     bx, by, bz      == Vektordifferenz}\par
00094 {\cf20     rv_sq           == Betrag des Linienvektors}\par
00095 {\cf20     dist            == Distanz von Punkt zu Linie}\par
00096 {\cf20     vp1, vp2, vp3   == Vektorprodukte}\par
00097 {\cf20     */}\par
00098 \par
00099     {\cf18 int} rvx = xS - xE;      {\cf20 // Parameter X des Linienvektor berechnen}\par
00100     {\cf18 int} rvy = yS - yE;      {\cf20 // Parameter Y des Linienvektor berechnen}\par
00101     {\cf18 int} rvz = zS - zE;      {\cf20 // Parameter Z des Linienvektor berechnen}\par
00102 \par
00103     rv_sq = sqrt((rvx * rvx) + (rvy * rvy) + (rvz * rvz));      {\cf20 // Betrag des Linienvektor berechnen}\par
00104 \par
00105     bx = x - xS;            {\cf20 // X(Punkt) - X(Aufpunkt)}\par
00106     by = y - yS;            {\cf20 // Y(Punkt) - Y(Aufpunkt)}\par
00107     bz = z - zS;            {\cf20 // Z(Punkt) - Z(Aufpunkt)}\par
00108 \par
00109     vp1 = by * rvz - bz * rvy;      {\cf20 // Parameter X Vektorprodukt}\par
00110     vp2 = bz * rvx - bx * rvz;      {\cf20 // Parameter Y Vektorprodukt}\par
00111     vp3 = bx * rvy - by * rvx;      {\cf20 // Parameter Z Vektorprodukt}\par
00112 \par
00113     dist = sqrt(vp1 * vp1 + vp2 * vp2 + vp3 * vp3) / rv_sq; {\cf20 // Betrag des Vektors berechnen}\par
00114 \par
00115     {\cf19 return} dist;\par
00116 \par
00117 \}\par
}
}
{\xe \v douglasPeuckerRecursive\:CSegmentApproximator}
{\xe \v CSegmentApproximator\:douglasPeuckerRecursive}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CSegmentApproximator::douglasPeuckerRecursive (list< {\b CInputPoint3D} > &  {\i segment}, std::list< {\b CInputPoint3D} >::iterator  {\i startItr}, std::list< {\b CInputPoint3D} >::iterator  {\i endItr}, double  {\i maxDistance}){\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAHL}
{\bkmkend AAAAAAAAHL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definiert in Zeile {\b 41} der Datei {\b SegmentApproximator.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00042 \{\par
00043     {\cf19 if} (segment.size() < 3) {\cf19 return};\par
00044     {\cf19 if} (distance(startItr, endItr) == 2) {\cf19 return};\par
00045     CInputPoint3D pStart; CInputPoint3D pEnd;\par
00046     pStart.setX(startItr->getX()); pStart.setY(startItr->getY()); pStart.setZ(startItr->getZ());\par
00047 \par
00048     {\cf20 //pEnd.x=segment.back().x; pEnd.y = segment.back().y;}\par
00049     pEnd.setX(endItr->getX()); pEnd.setY(endItr->getY()); pEnd.setZ(endItr->getZ());\par
00050 \par
00051     {\cf18 double} dist = 0.0, maxDist = 0.0;\par
00052     std::list<CInputPoint3D>::iterator maxItr, itr;\par
00053 \par
00054     {\cf19 for} (itr = startItr; itr != endItr; itr++)\par
00055     \{\par
00056         CLine3D line = CLine3D(pStart, pEnd);\par
00057         {\cf20 // calc distance}\par
00058         dist = itr->distanceTo(line);\par
00059         {\cf20 //dist=calcDist(pStart.getX(), pStart.getY(), pEnd.getX(), pEnd.getY(), itr->getX(), itr->getY());}\par
00060         {\cf19 if} (dist > maxDist) \{\par
00061             maxDist = dist;\par
00062             maxItr = itr;\par
00063         \}\par
00064     \}\par
00065 \par
00066     {\cf19 if} (maxDist <= maxDistance) \{\par
00067 \par
00068         segment.erase((++startItr), endItr);\par
00069         {\cf20 //for(itr = (++startItr); itr != --(endItr);)}\par
00070         {\cf20 //\{}\par
00071         {\cf20 //  // erase elements:}\par
00072         {\cf20 //  itr = segment.erase(itr);}\par
00073         {\cf20 //\}}\par
00074         {\cf19 return};\par
00075     \}\par
00076 \par
00077     douglasPeuckerRecursive(segment, startItr, maxItr, maxDistance);\par
00078     douglasPeuckerRecursive(segment, maxItr, endItr, maxDistance);\par
00079 \}\par
}
{
\ql
Benutzt {\b douglasPeuckerRecursive()}, {\b maxDistance}, {\b CPoint3D::setX()}, {\b CPoint3D::setY()} und {\b CPoint3D::setZ()}.}\par
{
\ql
Wird benutzt von {\b approx()} und {\b douglasPeuckerRecursive()}.}\par
}
{\xe \v getmaxDistance\:CSegmentApproximator}
{\xe \v CSegmentApproximator\:getmaxDistance}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double CSegmentApproximator::getmaxDistance ()}}
\par
{\bkmkstart AAAAAAAAHM}
{\bkmkend AAAAAAAAHM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definiert in Zeile {\b 31} der Datei {\b SegmentApproximator.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00032 \{\par
00033     {\cf19 return} maxDistance;\par
00034 \}\par
}
{
\ql
Benutzt {\b maxDistance}.}\par
}
{\xe \v getSegmentsApproxVector\:CSegmentApproximator}
{\xe \v CSegmentApproximator\:getSegmentsApproxVector}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
vector< list< {\b CInputPoint3D} > > & CSegmentApproximator::getSegmentsApproxVector ()}}
\par
{\bkmkstart AAAAAAAAHN}
{\bkmkend AAAAAAAAHN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definiert in Zeile {\b 36} der Datei {\b SegmentApproximator.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00037 \{\par
00038     {\cf19 return} segmentsApprox;\par
00039 \}\par
}
{
\ql
Benutzt {\b segmentsApprox}.}\par
{
\ql
Wird benutzt von {\b main()}.}\par
}
{\xe \v setmaxDistance\:CSegmentApproximator}
{\xe \v CSegmentApproximator\:setmaxDistance}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CSegmentApproximator::setmaxDistance (double  {\i maxDistanceSource})}}
\par
{\bkmkstart AAAAAAAAHO}
{\bkmkend AAAAAAAAHO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definiert in Zeile {\b 26} der Datei {\b SegmentApproximator.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00027 \{\par
00028     maxDistance = maxDistanceSource;\par
00029 \}\par
}
{
\ql
Benutzt {\b maxDistance}.}\par
{
\ql
Wird benutzt von {\b main()}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Dokumentation der Datenelemente\par
\pard\plain 
{\xe \v maxDistance\:CSegmentApproximator}
{\xe \v CSegmentApproximator\:maxDistance}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double CSegmentApproximator::maxDistance{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAHP}
{\bkmkend AAAAAAAAHP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definiert in Zeile {\b 26} der Datei {\b SegmentApproximator.h}.}\par
{
\ql
Wird benutzt von {\b approx()}, {\b douglasPeuckerRecursive()}, {\b getmaxDistance()} und {\b setmaxDistance()}.}\par
}
{\xe \v segmentsApprox\:CSegmentApproximator}
{\xe \v CSegmentApproximator\:segmentsApprox}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
vector<list<{\b CInputPoint3D}> > CSegmentApproximator::segmentsApprox{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAHQ}
{\bkmkend AAAAAAAAHQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definiert in Zeile {\b 24} der Datei {\b SegmentApproximator.h}.}\par
{
\ql
Wird benutzt von {\b approx()} und {\b getSegmentsApproxVector()}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
Die Dokumentation f\'FCr diese Klasse wurde erzeugt aufgrund der Dateien:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
header/{\b SegmentApproximator.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
src/{\b SegmentApproximator.cpp}\par
}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Datei-Dokumentation{\tc \v Datei-Dokumentation}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
header/EulerMatrix.h-Dateireferenz\par \pard\plain 
{\tc\tcl2 \v header/EulerMatrix.h}
{\xe \v header/EulerMatrix.h}
{\bkmkstart AAAAAAAAAW}
{\bkmkend AAAAAAAAAW}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
: Header File handling Euler Matrix }}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Klassen\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CEulerMatrix}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
: Handling und Berechnung Euler Matrix }}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Ausf\'FChrliche Beschreibung\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
: Header File handling Euler Matrix \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definiert in Datei {\b EulerMatrix.h}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
EulerMatrix.h\par \pard\plain 
{\tc\tcl2 \v header/EulerMatrix.h}
{\xe \v header/EulerMatrix.h}
{\bkmkstart AAAAAAAAAA}
{\bkmkend AAAAAAAAAA}
gehe zur Dokumentation dieser Datei{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00007 {\cf17 using namespace }std;\par
00008 \par
00009 {\cf21 #pragma once}\par
00010 \par
00015 {\cf17 class }CEulerMatrix\par
00016 \{\par
00017 {\cf17 public}:\par
00023     CEulerMatrix({\cf18 void});\par
00030     CEulerMatrix({\cf18 float} inputMatrix[3][3]);\par
00034     ~CEulerMatrix();\par
00035 \par
00040     {\cf18 void} setMatrix({\cf18 float} inputMatrix[3][3]);\par
00045     CEulerMatrix getMatrix();\par
00046 \par
00054     CEulerMatrix calculatAngel({\cf18 double} A, {\cf18 double} B, {\cf18 double} C);\par
00055 \par
00056 {\cf17 private}:\par
00060     {\cf18 float} eulerMatrix[3][3];\par
00061 \};\par
00062 \par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
header/GUI.h-Dateireferenz\par \pard\plain 
{\tc\tcl2 \v header/GUI.h}
{\xe \v header/GUI.h}
{\bkmkstart AAAAAAAAAX}
{\bkmkend AAAAAAAAAX}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Klassen\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CGUI}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
GUI.h\par \pard\plain 
{\tc\tcl2 \v header/GUI.h}
{\xe \v header/GUI.h}
{\bkmkstart AAAAAAAAAB}
{\bkmkend AAAAAAAAAB}
gehe zur Dokumentation dieser Datei{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #pragma once}\par
00002 \par
00003 {\cf17 class }CGUI\par
00004 \{\par
00005 \par
00006 {\cf17 public}:\par
00007     CGUI();\par
00008     ~CGUI();\par
00009 \};\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
header/InputParameter.h-Dateireferenz\par \pard\plain 
{\tc\tcl2 \v header/InputParameter.h}
{\xe \v header/InputParameter.h}
{\bkmkstart AAAAAAAAAY}
{\bkmkend AAAAAAAAAY}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
: Header File Daten Einlesen }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "EulerMatrix.h"}\par
{\f2 #include "Point3D.h"}\par
{\f2 #include <string>}\par
{\f2 #include <vector>}\par
{\f2 #include <list>}\par
{\f2 #include <iostream>}\par
{\f2 #include <fstream>}\par
{\f2 #include <sstream>}\par
{\f2 #include <tuple>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Klassen\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CInputParameter}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
: Handling Eingabedaten }}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Ausf\'FChrliche Beschreibung\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
: Header File Daten Einlesen \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{
Definiert in Datei {\b InputParameter.h}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
InputParameter.h\par \pard\plain 
{\tc\tcl2 \v header/InputParameter.h}
{\xe \v header/InputParameter.h}
{\bkmkstart AAAAAAAAAC}
{\bkmkend AAAAAAAAAC}
gehe zur Dokumentation dieser Datei{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00007 {\cf21 #include "EulerMatrix.h"}\par
00008 {\cf21 #include "Point3D.h"}\par
00009 {\cf21 #include <string>}\par
00010 {\cf21 #include <vector>}\par
00011 {\cf21 #include <list>}\par
00012 {\cf21 #include <iostream>}\par
00013 {\cf21 #include <fstream>}\par
00014 {\cf21 #include <sstream>} \par
00015 {\cf21 #include <tuple>}\par
00016 \par
00017 {\cf17 using namespace }std;\par
00018 \par
00019 {\cf21 #pragma once}\par
00020 \par
00025 {\cf17 class }CInputParameter\par
00026 \{\par
00027 {\cf17 public}:\par
00033     CInputParameter({\cf18 void});\par
00047     CInputParameter({\cf18 double} initSpeed, {\cf18 bool} initSeepManual, {\cf18 bool} initOrientationManual, {\cf18 double} initA, {\cf18 double} initB, {\cf18 double} initC);\par
00052     ~CInputParameter({\cf18 void});\par
00053 \par
00062     {\cf18 void} setOrientation({\cf18 bool} initOrientationManual, {\cf18 double} initA, {\cf18 double} initB, {\cf18 double} initC);\par
00069     {\cf18 void} setSpeed({\cf18 double} initSpeed, {\cf18 bool} initSpeedManual);\par
00070 \par
00075     {\cf18 double} getSpeed({\cf18 void});\par
00080     {\cf18 bool} getSpeedManual({\cf18 void});\par
00085     {\cf18 bool} getOrientationManual({\cf18 void});\par
00091     tuple <double, double, double> getAngles({\cf18 void});\par
00092 \par
00098     {\cf18 void} openFile(std::string path);\par
00107     {\cf18 bool} detectJump(CInputPoint3D p, {\cf18 double} x_prev, {\cf18 double} y_prev, {\cf18 double} z_prev);\par
00113     vector<list<CInputPoint3D>>& getPath();\par
00114 \par
00115 {\cf17 private}:\par
00119     vector<list<CInputPoint3D>> initialPath;\par
00123     {\cf18 double} speed;\par
00127     {\cf18 bool} speedManual;\par
00131     {\cf18 bool} orientationManual;\par
00135     {\cf18 double} A;\par
00139     {\cf18 double} B;\par
00143     {\cf18 double} C;\par
00147     {\cf18 double} difference = 20;\par
00148 \};\par
00149 \par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
header/Line3D.h-Dateireferenz\par \pard\plain 
{\tc\tcl2 \v header/Line3D.h}
{\xe \v header/Line3D.h}
{\bkmkstart AAAAAAAAAZ}
{\bkmkend AAAAAAAAAZ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "Point3D.h"}\par
{\f2 #include <math.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Klassen\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CLine3D}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Line3D.h\par \pard\plain 
{\tc\tcl2 \v header/Line3D.h}
{\xe \v header/Line3D.h}
{\bkmkstart AAAAAAAAAD}
{\bkmkend AAAAAAAAAD}
gehe zur Dokumentation dieser Datei{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "Point3D.h"}\par
00002 {\cf21 #include <math.h>}\par
00003 \par
00004 {\cf17 using namespace }std;\par
00005 \par
00006 {\cf21 #pragma once}\par
00007 {\cf17 class }CLine3D\par
00008 \{\par
00009 {\cf17 public}:\par
00010     CLine3D({\cf18 void});\par
00011     CLine3D(CPoint3D P1, CPoint3D P2);\par
00012     ~CLine3D({\cf18 void});\par
00013 \par
00014     CPoint3D p1;\par
00015     CPoint3D p2;\par
00016 \};\par
00017 \par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
header/MeanFilter.h-Dateireferenz\par \pard\plain 
{\tc\tcl2 \v header/MeanFilter.h}
{\xe \v header/MeanFilter.h}
{\bkmkstart AAAAAAAABA}
{\bkmkend AAAAAAAABA}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <vector>}\par
{\f2 #include <list>}\par
{\f2 #include "Point3D.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Klassen\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CMeanFilter}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MeanFilter.h\par \pard\plain 
{\tc\tcl2 \v header/MeanFilter.h}
{\xe \v header/MeanFilter.h}
{\bkmkstart AAAAAAAAAE}
{\bkmkend AAAAAAAAAE}
gehe zur Dokumentation dieser Datei{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include <vector>}\par
00002 {\cf21 #include <list>}\par
00003 {\cf21 #include "Point3D.h"}\par
00004 \par
00005 {\cf21 #pragma once}\par
00006 \par
00007 {\cf17 using namespace }std;\par
00008 \par
00009 \par
00010 {\cf17 class }CMeanFilter\par
00011 \{\par
00012 {\cf17 public}:\par
00013     CMeanFilter();\par
00014     CMeanFilter({\cf18 int} Window, {\cf18 long} lenth);\par
00015     ~CMeanFilter();\par
00016 \par
00017     {\cf18 void} setWindowSize({\cf18 int} Window);\par
00018 \par
00019     {\cf18 int} getWindowSize();\par
00020 \par
00021     vector<list<CInputPoint3D>>& getPath();\par
00022 \par
00023     list<CInputPoint3D> calculateMean(list<CInputPoint3D>& segment);\par
00024     {\cf18 void} mean(vector<list<CInputPoint3D>>& sourcePath);\par
00025 \par
00026 {\cf17 private}:\par
00027     {\cf18 int} windowSize;\par
00028     {\cf18 int} position;\par
00029     {\cf18 double} sum;\par
00030 \par
00031     vector<list<CInputPoint3D>> meanPath;\par
00032 \};\par
00033 \par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
header/PathBuilder.h-Dateireferenz\par \pard\plain 
{\tc\tcl2 \v header/PathBuilder.h}
{\xe \v header/PathBuilder.h}
{\bkmkstart AAAAAAAABB}
{\bkmkend AAAAAAAABB}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <vector>}\par
{\f2 #include <list>}\par
{\f2 #include <iostream>}\par
{\f2 #include "Point3D.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Klassen\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CPathBuilder}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
PathBuilder.h\par \pard\plain 
{\tc\tcl2 \v header/PathBuilder.h}
{\xe \v header/PathBuilder.h}
{\bkmkstart AAAAAAAAAF}
{\bkmkend AAAAAAAAAF}
gehe zur Dokumentation dieser Datei{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include <vector>}\par
00002 {\cf21 #include <list>}\par
00003 {\cf21 #include <iostream>}\par
00004 {\cf21 #include "Point3D.h"}\par
00005 \par
00006 {\cf17 using namespace }std;\par
00007 \par
00008 {\cf21 #pragma once}\par
00009 {\cf17 class }CPathBuilder\par
00010 \{\par
00011 {\cf17 public}:\par
00012     CPathBuilder({\cf18 void});\par
00013     ~CPathBuilder({\cf18 void});\par
00014 \par
00015     vector<CInputPoint3D>& getPath();\par
00016 \par
00017     {\cf18 void} createPath(vector<list<CInputPoint3D>>& segments, {\cf18 string} filename);\par
00018 \par
00019 {\cf17 private}:\par
00020     vector<CInputPoint3D> path;\par
00021 \};\par
00022 \par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
header/PathPostProcessing.h-Dateireferenz\par \pard\plain 
{\tc\tcl2 \v header/PathPostProcessing.h}
{\xe \v header/PathPostProcessing.h}
{\bkmkstart AAAAAAAABC}
{\bkmkend AAAAAAAABC}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <vector>}\par
{\f2 #include <list>}\par
{\f2 #include <iostream>}\par
{\f2 #include <tuple>}\par
{\f2 #include "Point3D.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Klassen\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CPathPostProcessing}}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Makrodefinitionen\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MAX_SPEED}\~ 2.0\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Makro-Dokumentation\par
\pard\plain 
{\xe \v MAX_SPEED\:PathPostProcessing.h}
{\xe \v PathPostProcessing.h\:MAX_SPEED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MAX_SPEED\~ 2.0}}
\par
{\bkmkstart AAAAAAAABD}
{\bkmkend AAAAAAAABD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definiert in Zeile {\b 11} der Datei {\b PathPostProcessing.h}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
PathPostProcessing.h\par \pard\plain 
{\tc\tcl2 \v header/PathPostProcessing.h}
{\xe \v header/PathPostProcessing.h}
{\bkmkstart AAAAAAAAAG}
{\bkmkend AAAAAAAAAG}
gehe zur Dokumentation dieser Datei{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include <vector>}\par
00002 {\cf21 #include <list>}\par
00003 {\cf21 #include <iostream>}\par
00004 {\cf21 #include <tuple>}\par
00005 {\cf21 #include "Point3D.h"}\par
00006 \par
00007 {\cf17 using namespace }std;\par
00008 \par
00009 {\cf21 #pragma once}\par
00010 \par
00011 {\cf21 #define MAX_SPEED 2.0}\par
00012 \par
00013 {\cf17 class }CPathPostProcessing\par
00014 \{\par
00015 {\cf17 public}:\par
00016     CPathPostProcessing({\cf18 void});\par
00017     CPathPostProcessing({\cf18 double} speedIn, {\cf18 bool} speedManualIn, {\cf18 bool} orientationManualIn, {\cf18 double} AIn, {\cf18 double} BIn, {\cf18 double} CIn);\par
00018     ~CPathPostProcessing({\cf18 void});\par
00019 \par
00020     vector<CPoint3D>& getProcessedPath({\cf18 void});\par
00021 \par
00022     {\cf18 void} postProcessing(vector<CPoint3D>& path);\par
00023     {\cf18 void} calculateSpeed(COutputPoint3D& p, {\cf18 size_t} i);\par
00024     {\cf18 void} calculateAngles(COutputPoint3D& p);\par
00025 \par
00026     {\cf18 void} setData({\cf18 double} speed, {\cf18 bool} speedManual, {\cf18 bool} orientationManual, tuple<double , double , double> angles);\par
00027 \par
00028 {\cf17 private}:\par
00029     vector<COutputPoint3D> processedPath;\par
00030     {\cf18 double} speed;\par
00031     {\cf18 bool} speedManual;\par
00032     {\cf18 bool} orientationManual;\par
00033     {\cf18 double} A;\par
00034     {\cf18 double} B;\par
00035     {\cf18 double} C;\par
00036 \};\par
00037 \par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
header/Point3D.h-Dateireferenz\par \pard\plain 
{\tc\tcl2 \v header/Point3D.h}
{\xe \v header/Point3D.h}
{\bkmkstart AAAAAAAABE}
{\bkmkend AAAAAAAABE}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "EulerMatrix.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Klassen\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CPoint3D}\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CInputPoint3D}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b COutputPoint3D}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Point3D.h\par \pard\plain 
{\tc\tcl2 \v header/Point3D.h}
{\xe \v header/Point3D.h}
{\bkmkstart AAAAAAAAAH}
{\bkmkend AAAAAAAAAH}
gehe zur Dokumentation dieser Datei{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "EulerMatrix.h"}\par
00002 \par
00003 {\cf17 class }CLine3D;\par
00004 \par
00005 {\cf17 using namespace }std;\par
00006 \par
00007 {\cf21 #pragma once}\par
00008 {\cf17 class }CPoint3D\par
00009 \{\par
00010 {\cf17 public}:\par
00011     CPoint3D({\cf18 void});\par
00012     CPoint3D({\cf18 double} X, {\cf18 double} Y, {\cf18 double} Z);\par
00013     ~CPoint3D({\cf18 void});\par
00014 \par
00015     {\cf18 double} getX();\par
00016     {\cf18 double} getY();\par
00017     {\cf18 double} getZ();\par
00018 \par
00019     {\cf18 void} setX({\cf18 double} X);\par
00020     {\cf18 void} setY({\cf18 double} Y);\par
00021     {\cf18 void} setZ({\cf18 double} Z);\par
00022 \par
00023     {\cf18 void} set({\cf18 double} X, {\cf18 double} Y, {\cf18 double} Z);\par
00024     {\cf18 double} distanceTo(CPoint3D point);\par
00025     {\cf18 double} distanceTo(CLine3D line);\par
00026 \par
00027 {\cf17 protected}:\par
00028     {\cf18 double} x, y, z;\par
00029 \};\par
00030 \par
00031 {\cf17 class }CInputPoint3D : {\cf17 public} CPoint3D\par
00032 \{   \par
00033 {\cf17 public}:\par
00034     CInputPoint3D({\cf18 void});\par
00035     CInputPoint3D({\cf18 double} X, {\cf18 double} Y, {\cf18 double} Z, {\cf18 double} Timestamp, CEulerMatrix Matrix);\par
00036     ~CInputPoint3D({\cf18 void});\par
00037     \par
00038     {\cf18 double} getTime();\par
00039     CEulerMatrix getEulerMatrix();\par
00040 \par
00041     {\cf18 void} setTime({\cf18 double} time);  \par
00042     {\cf18 void} setEulerMatrix(CEulerMatrix orientation);\par
00043     {\cf18 void} setPoint({\cf18 double} time, {\cf18 double} X, {\cf18 double} Y, {\cf18 double} Z, CEulerMatrix orientation);\par
00044 \par
00045 {\cf17 private}:\par
00046     {\cf18 double} timestamp;\par
00047     CEulerMatrix orientationMatrix;\par
00048 \};\par
00049 \par
00050 {\cf17 class }COutputPoint3D : {\cf17 public} CPoint3D\par
00051 \{\par
00052 {\cf17 public}:\par
00053     COutputPoint3D({\cf18 void});\par
00054     COutputPoint3D({\cf18 double} Speed, {\cf18 double} X, {\cf18 double} Y, {\cf18 double} Z, {\cf18 double} A, {\cf18 double} B, {\cf18 double} C);\par
00055     ~COutputPoint3D({\cf18 void});\par
00056 \par
00057     {\cf18 double} getSpeed();\par
00058     {\cf18 double} getA();\par
00059     {\cf18 double} getB();\par
00060     {\cf18 double} getC();\par
00061 \par
00062     {\cf20 //void setPoint(double speed, double X, double Y, double Z, CEulerMatrix orientation);}\par
00063     {\cf18 void} setSpeed({\cf18 double} speed);\par
00064     {\cf18 void} setA({\cf18 double} A);\par
00065     {\cf18 void} setB({\cf18 double} B);\par
00066     {\cf18 void} setC({\cf18 double} C);\par
00067 {\cf17 private}:\par
00068     {\cf18 double} a, b, c;\par
00069     {\cf18 double} speed;\par
00070 \};\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
header/RobCodeGenerator.h-Dateireferenz\par \pard\plain 
{\tc\tcl2 \v header/RobCodeGenerator.h}
{\xe \v header/RobCodeGenerator.h}
{\bkmkstart AAAAAAAABF}
{\bkmkend AAAAAAAABF}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <vector>}\par
{\f2 #include <iostream>}\par
{\f2 #include "Point3D.h"}\par
{\f2 #include <tuple>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Klassen\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CRobCodeGenerator}}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Makrodefinitionen\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MAX_SPEED}\~ 2.0\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Makro-Dokumentation\par
\pard\plain 
{\xe \v MAX_SPEED\:RobCodeGenerator.h}
{\xe \v RobCodeGenerator.h\:MAX_SPEED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MAX_SPEED\~ 2.0}}
\par
{\bkmkstart AAAAAAAABG}
{\bkmkend AAAAAAAABG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definiert in Zeile {\b 10} der Datei {\b RobCodeGenerator.h}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
RobCodeGenerator.h\par \pard\plain 
{\tc\tcl2 \v header/RobCodeGenerator.h}
{\xe \v header/RobCodeGenerator.h}
{\bkmkstart AAAAAAAAAI}
{\bkmkend AAAAAAAAAI}
gehe zur Dokumentation dieser Datei{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include <vector>}\par
00002 {\cf21 #include <iostream>}\par
00003 {\cf21 #include "Point3D.h"}\par
00004 {\cf21 #include <tuple>}\par
00005 \par
00006 {\cf17 using namespace }std;\par
00007 \par
00008 {\cf21 #pragma once}\par
00009 \par
00010 {\cf21 #define MAX_SPEED 2.0}\par
00011 \par
00012 {\cf17 class }CRobCodeGenerator\par
00013 \{\par
00014 {\cf17 public}:\par
00015     CRobCodeGenerator({\cf18 void});\par
00016     CRobCodeGenerator({\cf18 double} speedIn, {\cf18 bool} speedManualIn, {\cf18 bool} orientationManualIn, tuple<double, double, double> angles);\par
00017     ~CRobCodeGenerator({\cf18 void});\par
00018 \par
00019     {\cf18 void} generateRobCode(vector<CInputPoint3D>& path, {\cf18 string} filename);\par
00020     {\cf18 void} postProcessing(vector<CInputPoint3D>& path);\par
00021     {\cf18 double} calculateSpeed(CInputPoint3D& p, {\cf18 size_t} i, {\cf18 double} timePrev);\par
00022     {\cf18 void} calculateAngles(COutputPoint3D& p, CInputPoint3D& pIn);\par
00023 \par
00024 {\cf17 private}:\par
00025     vector<COutputPoint3D> processedPath;\par
00026     {\cf18 double} speed;\par
00027     {\cf18 bool} speedManual;\par
00028     {\cf18 bool} orientationManual;\par
00029     {\cf18 double} A;\par
00030     {\cf18 double} B;\par
00031     {\cf18 double} C;\par
00032 \par
00033 \};\par
00034 \par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
header/SegmentApproximator.h-Dateireferenz\par \pard\plain 
{\tc\tcl2 \v header/SegmentApproximator.h}
{\xe \v header/SegmentApproximator.h}
{\bkmkstart AAAAAAAABH}
{\bkmkend AAAAAAAABH}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <valarray>}\par
{\f2 #include <vector>}\par
{\f2 #include <list>}\par
{\f2 #include <iostream>}\par
{\f2 #include <math.h>}\par
{\f2 #include "Point3D.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Klassen\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CSegmentApproximator}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SegmentApproximator.h\par \pard\plain 
{\tc\tcl2 \v header/SegmentApproximator.h}
{\xe \v header/SegmentApproximator.h}
{\bkmkstart AAAAAAAAAJ}
{\bkmkend AAAAAAAAAJ}
gehe zur Dokumentation dieser Datei{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include <valarray>}\par
00002 {\cf21 #include <vector>}\par
00003 {\cf21 #include <list>}\par
00004 {\cf21 #include <iostream>}\par
00005 {\cf21 #include <math.h>}\par
00006 {\cf21 #include "Point3D.h"}\par
00007 \par
00008 {\cf17 using namespace }std;\par
00009 \par
00010 {\cf21 #pragma once}\par
00011 {\cf17 class }CSegmentApproximator\par
00012 \{\par
00013 {\cf17 public}:\par
00014     CSegmentApproximator({\cf18 void});\par
00015     ~CSegmentApproximator({\cf18 void});\par
00016 \par
00017     {\cf18 void} approx({\cf17 const} vector<list<CInputPoint3D>>& Segments);\par
00018     {\cf18 void} setmaxDistance({\cf18 double} maxDistanceSource);\par
00019     {\cf18 double} getmaxDistance();\par
00020 \par
00021     vector<list<CInputPoint3D>>& getSegmentsApproxVector();\par
00022 \par
00023 {\cf17 private}:\par
00024     vector<list<CInputPoint3D>> segmentsApprox;\par
00025 \par
00026     {\cf18 double} maxDistance;\par
00027     {\cf18 void} douglasPeuckerRecursive(list<CInputPoint3D>& segment, std::list<CInputPoint3D>::iterator startItr, std::list<CInputPoint3D>::iterator endItr, {\cf18 double} maxDistance);\par
00028     {\cf18 double} calcDist({\cf18 int} xS, {\cf18 int} yS, {\cf18 int} zS, {\cf18 int} xE, {\cf18 int} yE, {\cf18 int} zE, {\cf18 int} x, {\cf18 int} y, {\cf18 int} z);\par
00029 \par
00030 \};\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
plotPath.m-Dateireferenz\par \pard\plain 
{\tc\tcl2 \v plotPath.m}
{\xe \v plotPath.m}
{\bkmkstart AAAAAAAABI}
{\bkmkend AAAAAAAABI}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Funktionen\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b plot3} ({\b Y}, {\b X}, {\b Z})\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variablen\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
clear {\b all}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b clc}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b data} = dlmread('08_path.csv')\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b X} = {\b data}(:,1)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Y} = {\b data}(:,2)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Z} = {\b data}(:,3) * 50\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
for {\b i}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
hold {\b on}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
axis {\b equal}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Dokumentation der Funktionen\par
\pard\plain 
{\xe \v plot3\:plotPath.m}
{\xe \v plotPath.m\:plot3}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
plot3 ({\b Y} , {\b X} , {\b Z} )}}
\par
{\bkmkstart AAAAAAAABJ}
{\bkmkend AAAAAAAABJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variablen-Dokumentation\par
\pard\plain 
{\xe \v all\:plotPath.m}
{\xe \v plotPath.m\:all}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
close all}}
\par
{\bkmkstart AAAAAAAABK}
{\bkmkend AAAAAAAABK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definiert in Zeile {\b 1} der Datei {\b plotPath.m}.}\par
}
{\xe \v clc\:plotPath.m}
{\xe \v plotPath.m\:clc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
clc}}
\par
{\bkmkstart AAAAAAAABL}
{\bkmkend AAAAAAAABL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definiert in Zeile {\b 3} der Datei {\b plotPath.m}.}\par
}
{\xe \v data\:plotPath.m}
{\xe \v plotPath.m\:data}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
data = dlmread('08_path.csv')}}
\par
{\bkmkstart AAAAAAAABM}
{\bkmkend AAAAAAAABM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definiert in Zeile {\b 5} der Datei {\b plotPath.m}.}\par
}
{\xe \v equal\:plotPath.m}
{\xe \v plotPath.m\:equal}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
axis equal}}
\par
{\bkmkstart AAAAAAAABN}
{\bkmkend AAAAAAAABN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definiert in Zeile {\b 16} der Datei {\b plotPath.m}.}\par
}
{\xe \v i\:plotPath.m}
{\xe \v plotPath.m\:i}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
for i}}
\par
{\bkmkstart AAAAAAAABO}
{\bkmkend AAAAAAAABO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initialisierung:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid =1:length(X)-1\par
plot3(Y(i:i+1),X(i:i+1),Z(i:i+1))\par
}
{
Definiert in Zeile {\b 12} der Datei {\b plotPath.m}.}\par
{
\ql
Wird benutzt von {\b CMeanFilter::calculateMean()}, {\b CEulerMatrix::CEulerMatrix()}, {\b CEulerMatrix::CEulerMatrix()} und {\b CEulerMatrix::setMatrix()}.}\par
}
{\xe \v on\:plotPath.m}
{\xe \v plotPath.m\:on}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
hold on}}
\par
{\bkmkstart AAAAAAAABP}
{\bkmkend AAAAAAAABP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definiert in Zeile {\b 14} der Datei {\b plotPath.m}.}\par
}
{\xe \v X\:plotPath.m}
{\xe \v plotPath.m\:X}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
X = {\b data}(:,1)}}
\par
{\bkmkstart AAAAAAAABQ}
{\bkmkend AAAAAAAABQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definiert in Zeile {\b 7} der Datei {\b plotPath.m}.}\par
{
\ql
Wird benutzt von {\b CInputPoint3D::CInputPoint3D()}, {\b COutputPoint3D::COutputPoint3D()}, {\b CPoint3D::CPoint3D()}, {\b CPoint3D::set()}, {\b CInputPoint3D::setPoint()} und {\b CPoint3D::setX()}.}\par
}
{\xe \v Y\:plotPath.m}
{\xe \v plotPath.m\:Y}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Y = {\b data}(:,2)}}
\par
{\bkmkstart AAAAAAAABR}
{\bkmkend AAAAAAAABR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definiert in Zeile {\b 8} der Datei {\b plotPath.m}.}\par
{
\ql
Wird benutzt von {\b CInputPoint3D::CInputPoint3D()}, {\b COutputPoint3D::COutputPoint3D()}, {\b CPoint3D::CPoint3D()}, {\b CPoint3D::set()}, {\b CInputPoint3D::setPoint()} und {\b CPoint3D::setY()}.}\par
}
{\xe \v Z\:plotPath.m}
{\xe \v plotPath.m\:Z}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Z = {\b data}(:,3) * 50}}
\par
{\bkmkstart AAAAAAAABS}
{\bkmkend AAAAAAAABS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definiert in Zeile {\b 9} der Datei {\b plotPath.m}.}\par
{
\ql
Wird benutzt von {\b CInputPoint3D::CInputPoint3D()}, {\b COutputPoint3D::COutputPoint3D()}, {\b CPoint3D::CPoint3D()}, {\b CPoint3D::set()}, {\b CInputPoint3D::setPoint()} und {\b CPoint3D::setZ()}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
plotPath.m\par \pard\plain 
{\bkmkstart AAAAAAAAAK}
{\bkmkend AAAAAAAAAK}
gehe zur Dokumentation dieser Datei{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 clear all;\par
00002 close all;\par
00003 clc;\par
00004 \par
00005 data = dlmread({\cf22 '08_path.csv'});\par
00006 \par
00007 X = data(:,1);\par
00008 Y = data(:,2);\par
00009 Z = data(:,3) * 50;\par
00010 \par
00011 \par
00012 {\cf19 for} i=1:length(X)-1\par
00013 plot3(Y(i:i+1),X(i:i+1),Z(i:i+1));\par
00014 hold on;\par
00015 %plot3(Y,X,Z);\par
00016 axis equal;\par
00017 pause(0.3)\par
00018 end\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/EulerMatrix.cpp-Dateireferenz\par \pard\plain 
{\tc\tcl2 \v src/EulerMatrix.cpp}
{\xe \v src/EulerMatrix.cpp}
{\bkmkstart AAAAAAAABT}
{\bkmkend AAAAAAAABT}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "EulerMatrix.h"}\par
{\f2 #include <math.h>}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
EulerMatrix.cpp\par \pard\plain 
{\tc\tcl2 \v src/EulerMatrix.cpp}
{\xe \v src/EulerMatrix.cpp}
{\bkmkstart AAAAAAAAAL}
{\bkmkend AAAAAAAAAL}
gehe zur Dokumentation dieser Datei{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "EulerMatrix.h"}\par
00002 {\cf21 #include <math.h>}\par
00003 \par
00004 CEulerMatrix::CEulerMatrix({\cf18 void})\par
00005 \{\par
00006     {\cf19 for} ({\cf18 int} i = 0; i < 3; i++)\par
00007     \{\par
00008         {\cf19 for} ({\cf18 int} m = 0; m < 3; m++)\par
00009         \{\par
00010             eulerMatrix[i][m] = 0;                  {\cf20 // eulerMatrix mit 0 initialisieren}\par
00011         \}\par
00012     \}\par
00013 \}\par
00014 \par
00015 CEulerMatrix::CEulerMatrix({\cf18 float} inputMatrix[3][3])\par
00016 \{\par
00017     {\cf19 for} ({\cf18 int} i = 0; i < 3; i++)\par
00018     \{\par
00019         {\cf19 for} ({\cf18 int} m = 0; m < 3; m++)\par
00020         \{\par
00021             eulerMatrix[i][m] = inputMatrix[i][m];  {\cf20 // eulerMatrix mit Startwerten initialisieren}\par
00022         \}\par
00023     \}\par
00024 \}\par
00025 \par
00026 CEulerMatrix::~CEulerMatrix()\par
00027 \{\par
00028 \}\par
00029 \par
00030 \par
00031 {\cf18 void} CEulerMatrix::setMatrix({\cf18 float} inputMatrix[3][3])\par
00032 \{\par
00033     {\cf19 for}({\cf18 int} i = 0; i < 3; i++)\par
00034     \{ \par
00035         {\cf19 for} ({\cf18 int} m = 0; m < 3; m++)\par
00036         \{\par
00037             eulerMatrix[i][m] = inputMatrix[i][m];  {\cf20 // eulerMatrix mit \'DCbergabewerten \'FCberschreiben}\par
00038         \}\par
00039     \}\par
00040 \}\par
00041 \par
00042 CEulerMatrix CEulerMatrix::getMatrix()\par
00043 \{\par
00044     {\cf19 return} eulerMatrix;\par
00045 \}\par
00046 \par
00047 CEulerMatrix CEulerMatrix::calculatAngel({\cf18 double} A, {\cf18 double} B, {\cf18 double} C)\par
00048 \{\par
00049     {\cf18 float} Matrix[3][3];\par
00050 \par
00051     Matrix[0][0] = cos(A) * cos(C) - sin(A) * cos(B) * sin(C);\par
00052     Matrix[0][1] = -cos(A) * sin(C) - sin(A) * cos(B) * cos(C);\par
00053     Matrix[0][2] = sin(A) * sin(B);\par
00054 \par
00055     Matrix[1][0] = sin(A) * cos(C) + cos(A) * cos(B) * sin(C);\par
00056     Matrix[1][1] = -sin(A) * sin(C) + cos(A) * cos(B) * cos(C);\par
00057     Matrix[1][2] = -cos(A) * sin(B);\par
00058 \par
00059     Matrix[2][0] = sin(B) * sin(C);\par
00060     Matrix[2][1] = sin(B) * cos(C);\par
00061     Matrix[2][2] = cos(B);\par
00062 \par
00063     CEulerMatrix buffer(Matrix);\par
00064     {\cf19 return} buffer;\par
00065 \}\par
00066 \par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/GUI.cpp-Dateireferenz\par \pard\plain 
{\tc\tcl2 \v src/GUI.cpp}
{\xe \v src/GUI.cpp}
{\bkmkstart AAAAAAAABU}
{\bkmkend AAAAAAAABU}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "GUI.h"}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
GUI.cpp\par \pard\plain 
{\tc\tcl2 \v src/GUI.cpp}
{\xe \v src/GUI.cpp}
{\bkmkstart AAAAAAAAAM}
{\bkmkend AAAAAAAAAM}
gehe zur Dokumentation dieser Datei{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "GUI.h"}\par
00002 \par
00003 CGUI::CGUI()\par
00004 \{\}\par
00005 \par
00006 CGUI::~CGUI()\par
00007 \{\}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/InputParameter.cpp-Dateireferenz\par \pard\plain 
{\tc\tcl2 \v src/InputParameter.cpp}
{\xe \v src/InputParameter.cpp}
{\bkmkstart AAAAAAAABV}
{\bkmkend AAAAAAAABV}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "InputParameter.h"}\par
{\f2 #include "Point3D.h"}\par
{\f2 #include "EulerMatrix.h"}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
InputParameter.cpp\par \pard\plain 
{\tc\tcl2 \v src/InputParameter.cpp}
{\xe \v src/InputParameter.cpp}
{\bkmkstart AAAAAAAAAN}
{\bkmkend AAAAAAAAAN}
gehe zur Dokumentation dieser Datei{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00007 {\cf21 #include "InputParameter.h"}\par
00008 {\cf21 #include "Point3D.h"}\par
00009 {\cf21 #include "EulerMatrix.h"}\par
00010 \par
00014 CInputParameter::CInputParameter({\cf18 double} initSpeed, {\cf18 bool} initSpeedManual, {\cf18 bool} initOrientationManual, {\cf18 double} initA, {\cf18 double} initB, {\cf18 double} initC)\par
00015 \{\par
00016     speed = initSpeed;\par
00017     speedManual = initSpeedManual;\par
00018     orientationManual = initOrientationManual;\par
00019     A = initA;\par
00020     B = initB;\par
00021     C = initC;\par
00022 \par
00023 \}\par
00027 CInputParameter::CInputParameter({\cf18 void})\par
00028 \{\par
00029     speed = 0;\par
00030     A = 0;\par
00031     B = 0;\par
00032     C = 0;\par
00033     speedManual = {\cf17 false},\par
00034     orientationManual = {\cf17 false};\par
00035 \par
00036 \}\par
00040 CInputParameter::~CInputParameter({\cf18 void})\par
00041 \{\par
00042 \par
00043 \}\par
00044 \par
00045 {\cf18 void} CInputParameter::setOrientation({\cf18 bool} initOrientationManual, {\cf18 double} initA, {\cf18 double} initB, {\cf18 double} initC)\par
00046 \{\par
00047     orientationManual = initOrientationManual;\par
00048     A = initA;\par
00049     B = initB;\par
00050     C = initC;\par
00051 \}\par
00052 \par
00053 {\cf18 void} CInputParameter::setSpeed({\cf18 double} initSpeed, {\cf18 bool} initSpeedManual)\par
00054 \{\par
00055     speed = initSpeed;\par
00056     speedManual = initSpeedManual;\par
00057 \}\par
00058 \par
00059 vector<list<CInputPoint3D>>& CInputParameter::getPath()\par
00060 \{\par
00061     {\cf19 return} initialPath;\par
00062 \}\par
00063 \par
00064 {\cf18 double} CInputParameter::getSpeed({\cf18 void})\par
00065 \{\par
00066     {\cf19 return} speed;\par
00067 \}\par
00068 \par
00069 {\cf18 bool} CInputParameter::getSpeedManual({\cf18 void})\par
00070 \{\par
00071     {\cf19 return} speedManual;\par
00072 \}\par
00073 \par
00074 {\cf18 bool} CInputParameter::getOrientationManual({\cf18 void})\par
00075 \{\par
00076     {\cf19 return} orientationManual;\par
00077 \}\par
00078 \par
00079 tuple <double, double, double> CInputParameter::getAngles({\cf18 void})\par
00080 \{\par
00081     {\cf19 return} make_tuple(A, B, C);\par
00082 \}\par
00083 \par
00084 {\cf18 void} CInputParameter::openFile({\cf18 string} path)\par
00085 \{\par
00086     ifstream fin(path);\par
00087     {\cf18 char} delimiter = {\cf23 ' '};\par
00088     CInputPoint3D tmpPoint;\par
00089     CEulerMatrix tmpEuler;\par
00090     {\cf18 double} x, y, z;\par
00091     {\cf18 double} x_prev = 0, y_prev = 0, z_prev = 0;\par
00092     {\cf18 double} timestamp;\par
00093     {\cf18 int} segmentCount = -1;\par
00094     {\cf18 float} dummyMatrix[3][3];\par
00095 \par
00096 \par
00097     {\cf19 if} (!fin.is_open())\par
00098     \{\par
00099         cerr << {\cf22 "Datei konnte nicht ge\'F6ffnet werden"} << endl;\par
00100     \}\par
00101     {\cf18 string} line;\par
00102 \par
00103     {\cf19 while}(getline(fin, line))\par
00104     \{\par
00105         std::istringstream sStream (line);\par
00106         sStream >> timestamp >> x >> y >> z >> dummyMatrix[0][0] >> dummyMatrix[0][1] >> dummyMatrix[0][2]\par
00107             >> dummyMatrix[1][0] >> dummyMatrix[1][1] >> dummyMatrix[1][2] >> dummyMatrix[2][0] >> dummyMatrix[2][1] >> dummyMatrix[2][2];\par
00108 \par
00109         tmpEuler.setMatrix(dummyMatrix);\par
00110         tmpPoint.setPoint(timestamp, x, y, z, tmpEuler.getMatrix());\par
00111 \par
00112         {\cf19 if} (detectJump(tmpPoint, x_prev, y_prev, z_prev))\par
00113         \{\par
00114             segmentCount++;\par
00115             initialPath.push_back(list<CInputPoint3D>());\par
00116         \}\par
00117 \par
00118         initialPath[segmentCount].push_back(tmpPoint);\par
00119 \par
00120         x_prev = x;\par
00121         y_prev = y;\par
00122         z_prev = z;\par
00123     \}\par
00124     fin.close();\par
00125 \}\par
00126 \par
00127 {\cf18 bool} CInputParameter::detectJump(CInputPoint3D p, {\cf18 double} x_prev, {\cf18 double}  y_prev, {\cf18 double} z_prev)\par
00128 \{\par
00129     {\cf19 if}(abs(p.getX() - x_prev) > difference)\par
00130         {\cf19 return} {\cf17 true};\par
00131     {\cf19 else} {\cf19 if}(abs(p.getY() - y_prev) > difference)\par
00132         {\cf19 return} {\cf17 true};\par
00133     {\cf19 else} {\cf19 if}(abs(p.getZ() - z_prev) > difference)\par
00134         {\cf19 return} {\cf17 true};\par
00135     {\cf19 else}\par
00136         {\cf19 return} {\cf17 false};\par
00137 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/Line3D.cpp-Dateireferenz\par \pard\plain 
{\tc\tcl2 \v src/Line3D.cpp}
{\xe \v src/Line3D.cpp}
{\bkmkstart AAAAAAAABW}
{\bkmkend AAAAAAAABW}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "Line3D.h"}\par
{\f2 #include "Point3D.h"}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Line3D.cpp\par \pard\plain 
{\tc\tcl2 \v src/Line3D.cpp}
{\xe \v src/Line3D.cpp}
{\bkmkstart AAAAAAAAAO}
{\bkmkend AAAAAAAAAO}
gehe zur Dokumentation dieser Datei{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "Line3D.h"}\par
00002 {\cf21 #include "Point3D.h"}\par
00003 \par
00004 CLine3D::CLine3D({\cf18 void})\par
00005 \{\par
00006 \}\par
00007 \par
00008 CLine3D::CLine3D(CPoint3D P1, CPoint3D P2)\par
00009 \{\par
00010     p1 = P1;\par
00011     p2 = P2;\par
00012 \}\par
00013 \par
00014 CLine3D::~CLine3D({\cf18 void})\par
00015 \{\par
00016 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/MeanFilter.cpp-Dateireferenz\par \pard\plain 
{\tc\tcl2 \v src/MeanFilter.cpp}
{\xe \v src/MeanFilter.cpp}
{\bkmkstart AAAAAAAABX}
{\bkmkend AAAAAAAABX}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "MeanFilter.h"}\par
{\f2 #include <math.h>}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MeanFilter.cpp\par \pard\plain 
{\tc\tcl2 \v src/MeanFilter.cpp}
{\xe \v src/MeanFilter.cpp}
{\bkmkstart AAAAAAAAAP}
{\bkmkend AAAAAAAAAP}
gehe zur Dokumentation dieser Datei{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "MeanFilter.h"}\par
00002 {\cf21 #include <math.h>}\par
00003 \par
00004 CMeanFilter::CMeanFilter()\par
00005 \{\par
00006     setWindowSize(0);\par
00007 \}\par
00008 \par
00009 CMeanFilter::CMeanFilter({\cf18 int} Window, {\cf18 long} lenth)\par
00010 \{\par
00011     setWindowSize(Window);\par
00012 \}\par
00013 \par
00014 CMeanFilter::~CMeanFilter()\par
00015 \{\par
00016 \}\par
00017 \par
00018 {\cf18 void} CMeanFilter::setWindowSize({\cf18 int} Window)\par
00019 \{\par
00020     windowSize = Window;\par
00021 \}\par
00022 \par
00023 {\cf18 int} CMeanFilter::getWindowSize()\par
00024 \{\par
00025     {\cf19 return} windowSize;\par
00026 \}\par
00027 \par
00028 vector<list<CInputPoint3D>>& CMeanFilter::getPath()\par
00029 \{\par
00030     {\cf19 return} meanPath;\par
00031 \}\par
00032 \par
00033 {\cf18 void} CMeanFilter::mean(vector<list<CInputPoint3D>>& sourcePath)\par
00034 \{\par
00035     list<CInputPoint3D> dummyList;\par
00036     {\cf19 for} ({\cf18 size_t} s = 0; s < sourcePath.size(); s++)\par
00037     \{\par
00038         dummyList = calculateMean(sourcePath[s]);\par
00039         meanPath.push_back(dummyList);\par
00040     \}\par
00041 \}\par
00042 \par
00043 list<CInputPoint3D> CMeanFilter::calculateMean(list<CInputPoint3D>& segment)\par
00044 \{\par
00045     {\cf18 double} sumX = 0, sumY = 0, sumZ = 0;        {\cf20 // oder long??}\par
00046     {\cf18 double} div = 0;\par
00047     {\cf18 int} m = 0;\par
00048     {\cf18 int} OffsetPos = 0;\par
00049     {\cf18 int} OffsetNeg = 0;\par
00050 \par
00051     CInputPoint3D p;\par
00052 \par
00053     {\cf18 size_t} inputSize = segment.size();\par
00054 \par
00055     list<CInputPoint3D>::iterator it = segment.begin();\par
00056     list<CInputPoint3D> newSegment;\par
00057 \par
00058     {\cf19 for} ({\cf18 size_t} i = 0; i < inputSize - windowSize; ++i)\par
00059     \{\par
00060         sumX = 0, sumY = 0, sumZ = 0;\par
00061         div = 0;\par
00062         p.setTime(it->getTime());\par
00063         p.setEulerMatrix(it->getEulerMatrix());\par
00064         {\cf19 for} ({\cf18 size_t} j = i; j < i + windowSize; ++j)\par
00065         \{\par
00066 \par
00067             sumX += it->getX();\par
00068             sumY += it->getY();\par
00069             sumZ += it->getZ();\par
00070             div++;\par
00071             it++;\par
00072         \}\par
00073         {\cf19 for} ({\cf18 size_t} index = windowSize; index > 0; index--)\par
00074         \{\par
00075             it--;\par
00076         \}\par
00077         p.set(sumX / div, sumY / div, sumZ / div);\par
00078         {\cf19 if}(it != segment.end())\par
00079             it++;\par
00080         newSegment.push_back(p);\par
00081 \par
00082         \par
00083     \}\par
00084     {\cf19 return} newSegment;\par
00085 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/PathBuilder.cpp-Dateireferenz\par \pard\plain 
{\tc\tcl2 \v src/PathBuilder.cpp}
{\xe \v src/PathBuilder.cpp}
{\bkmkstart AAAAAAAABY}
{\bkmkend AAAAAAAABY}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "PathBuilder.h"}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
PathBuilder.cpp\par \pard\plain 
{\tc\tcl2 \v src/PathBuilder.cpp}
{\xe \v src/PathBuilder.cpp}
{\bkmkstart AAAAAAAAAQ}
{\bkmkend AAAAAAAAAQ}
gehe zur Dokumentation dieser Datei{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "PathBuilder.h"}\par
00002 \par
00003 CPathBuilder::CPathBuilder({\cf18 void})\par
00004 \{\par
00005 \}\par
00006 \par
00007 \par
00008 CPathBuilder::~CPathBuilder({\cf18 void})\par
00009 \{\par
00010 \}\par
00011 \par
00012 vector<CInputPoint3D>& CPathBuilder::getPath()\par
00013 \{\par
00014     {\cf19 return} path;\par
00015 \}\par
00016 \par
00017 {\cf18 void} CPathBuilder::createPath(vector<list<CInputPoint3D>>& segments, {\cf18 string} filename)\par
00018 \{\par
00019 \par
00020     FILE* fid = fopen(filename.c_str(), {\cf22 "w"});\par
00021 \par
00022     {\cf19 if} (fid == NULL)\par
00023     \{ \par
00024         cerr << {\cf22 "ERROR - Can NOT write to output file!\\n"};\par
00025         {\cf19 return};\par
00026     \}\par
00027 \par
00028     {\cf18 double} zOffset = 1.0;\par
00029 \par
00030     CInputPoint3D point; {\cf20 //startpoint}\par
00031     path.push_back(point);\par
00032 \par
00033     fprintf(fid, {\cf22 "%f %f %f\\n"}, ({\cf18 double})0, ({\cf18 double})0, ({\cf18 double})0 + zOffset);\par
00034 \par
00035     {\cf19 for} ({\cf18 size_t} s = 0; s < segments.size(); s++) {\cf20 //for all segments}\par
00036     \{\par
00037         list<CInputPoint3D>::iterator itr = segments[s].begin();\par
00038 \par
00039         point.set(({\cf18 double})itr->getX(), ({\cf18 double})itr->getY(), ({\cf18 double})itr->getZ()); {\cf20 //point over start of segment}\par
00040         path.push_back(point);\par
00041 \par
00042         fprintf(fid, {\cf22 "%f %f %f\\n"}, ({\cf18 double})itr->getX(), ({\cf18 double})itr->getY(), ({\cf18 double})itr->getZ());\par
00043         \par
00044 \par
00045         {\cf19 for} (; itr != segments[s].end(); itr++) {\cf20 //for all points in the segment}\par
00046         \{\par
00047             fprintf(fid, {\cf22 "%f %f %f\\n"}, ({\cf18 double})itr->getX(), ({\cf18 double})itr->getY(), ({\cf18 double})itr->getZ());\par
00048 \par
00049             point.set(({\cf18 double})itr->getX(), ({\cf18 double})itr->getY(), ({\cf18 double})itr->getZ());\par
00050             path.push_back(point);\par
00051 \par
00052         \}\par
00053 \par
00054         itr--;\par
00055         fprintf(fid, {\cf22 "%f %f %f\\n"}, ({\cf18 double})itr->getX(), ({\cf18 double})itr->getY(), ({\cf18 double})itr->getZ());\par
00056 \par
00057         point.set(({\cf18 double})itr->getX(), ({\cf18 double})itr->getY(), ({\cf18 double})0 + zOffset); {\cf20 //point over end of segment}\par
00058         path.push_back(point);\par
00059     \}\par
00060 \par
00061     fprintf(fid, {\cf22 "%f %f %f\\n"}, ({\cf18 double})0, ({\cf18 double})0, ({\cf18 double})0);\par
00062 \par
00063     point.set(0, 0, 0); {\cf20 //endpoint (== startpoint)}\par
00064     path.push_back(point);\par
00065 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/PathPostProcessing.cpp-Dateireferenz\par \pard\plain 
{\tc\tcl2 \v src/PathPostProcessing.cpp}
{\xe \v src/PathPostProcessing.cpp}
{\bkmkstart AAAAAAAABZ}
{\bkmkend AAAAAAAABZ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "PathPostProcessing.h"}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
PathPostProcessing.cpp\par \pard\plain 
{\tc\tcl2 \v src/PathPostProcessing.cpp}
{\xe \v src/PathPostProcessing.cpp}
{\bkmkstart AAAAAAAAAR}
{\bkmkend AAAAAAAAAR}
gehe zur Dokumentation dieser Datei{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "PathPostProcessing.h"}\par
00002 \par
00003 \par
00004 CPathPostProcessing::CPathPostProcessing({\cf18 void})\par
00005 \{\par
00006 \}\par
00007 \par
00008 CPathPostProcessing::CPathPostProcessing({\cf18 double} speedIn, {\cf18 bool} speedManualIn, {\cf18 bool} orientationManualIn, {\cf18 double} AIn, {\cf18 double} BIn, {\cf18 double} CIn)\par
00009 \{\par
00010     speed = speedIn;\par
00011     speedManual = speedManualIn;\par
00012     orientationManual = orientationManualIn;\par
00013     A = AIn;\par
00014     B = BIn;\par
00015     C = CIn;\par
00016 \}\par
00017 \par
00018 CPathPostProcessing::~CPathPostProcessing({\cf18 void})\par
00019 \{\par
00020 \}\par
00021 \par
00022 {\cf18 void} CPathPostProcessing::setData({\cf18 double} speedIn, {\cf18 bool} speedManualIn, {\cf18 bool} orientationManualIn, tuple <double, double, double> angles)\par
00023 \{\par
00024     speed = speedIn;\par
00025     speedManual = speedManualIn;\par
00026     orientationManual = orientationManualIn;\par
00027     A = get<0>(angles);\par
00028     B = get<1>(angles);\par
00029     C = get<2>(angles);\par
00030 \}\par
00031 \par
00032 vector<CPoint3D>& CPathPostProcessing::getProcessedPath({\cf18 void})\par
00033 \{\par
00034     {\cf19 return} processedPath;\par
00035 \}\par
00036 \par
00037 {\cf18 void} CPathPostProcessing::postProcessing(vector<CPoint3D>& path)\par
00038 \{\par
00039     CPoint3D p;\par
00040 \par
00041     {\cf19 for} ({\cf18 size_t} s = 0; s < path.size(); s++)\par
00042     \{\par
00043         p.setPoint(path[s].getTime(), path[s].getX(), path[s].getY(), path[s].getZ(), path[s].getEulerMatrix());\par
00044         {\cf19 if} (speedManual)\par
00045         \{\par
00046             {\cf19 if} (speed > MAX_SPEED) {\cf20 //Wenn maximale Geschwindigkeit \'FCberschritten wird, Geschwindigkeit begrenzen}\par
00047             speed = MAX_SPEED;\par
00048 \par
00049             p.setSpeed(speed);\par
00050         \}\par
00051         {\cf19 else}\par
00052         \{\par
00053             {\cf19 if} (s == 0)\par
00054                 p.setSpeed(1); {\cf20 //Der erste Punkt(0) wird mit Standardgeschwindigkeit 1m/s angefahren.}\par
00055 \par
00056             {\cf19 else}\par
00057                 calculateSpeed(p, s); {\cf20 //Die Geschwindigkeit zwischen den weiteren Punkten wird berechnet.}\par
00058         \}\par
00059             \par
00060         {\cf19 if} (orientationManual)\par
00061         \{\par
00062             p.setA(A);\par
00063             p.setB(B);\par
00064             p.setC(C);\par
00065         \}\par
00066         {\cf19 else}\par
00067             calculateAngles(p);\par
00068 \par
00069         processedPath.push_back(p);\par
00070     \}\par
00071 \par
00072 \}\par
00073 \par
00074 {\cf18 void} CPathPostProcessing::calculateSpeed(CPoint3D& p, {\cf18 size_t} s)\par
00075 \{\par
00076     {\cf18 double} distance = 0;\par
00077     {\cf18 double} time = 0;\par
00078 \par
00079     distance = processedPath[s-1].distanceTo(p); {\cf20 //Strecke zwischen p und dem Punkt zuvor}\par
00080     time = p.getTime() - processedPath[s-1].getTime(); {\cf20 //Zeit zwischen p-1 und p}\par
00081 \par
00082     speed = distance/time; {\cf20 // Berechnug Geschwindigkeit zwischen zwei Punkten}\par
00083 \par
00084     {\cf19 if} (speed > MAX_SPEED) {\cf20 //Begrenzung auf maximale Geschwindigkeit, falls Trackerdaten h\'F6heren Wert aufweisen}\par
00085     speed = MAX_SPEED;\par
00086 \par
00087     p.setSpeed(speed); {\cf20 //Zuweisung der Geschwindigkeit}\par
00088 \}\par
00089 \par
00090 {\cf18 void} CPathPostProcessing::calculateAngles(CPoint3D& p)\par
00091 \{\par
00092     {\cf18 double} a, b, c;\par
00093 \par
00094     {\cf20 // Funktion in Eulermatrix aufrufen die a/b/c neu berechnet}\par
00095 \par
00096     p.setA(a);\par
00097     p.setB(b);\par
00098     p.setC(c);\par
00099 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/Point3D.cpp-Dateireferenz\par \pard\plain 
{\tc\tcl2 \v src/Point3D.cpp}
{\xe \v src/Point3D.cpp}
{\bkmkstart AAAAAAAACA}
{\bkmkend AAAAAAAACA}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "Point3D.h"}\par
{\f2 #include "Line3D.h"}\par
{\f2 #include <math.h>}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Point3D.cpp\par \pard\plain 
{\tc\tcl2 \v src/Point3D.cpp}
{\xe \v src/Point3D.cpp}
{\bkmkstart AAAAAAAAAS}
{\bkmkend AAAAAAAAAS}
gehe zur Dokumentation dieser Datei{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "Point3D.h"}\par
00002 {\cf21 #include "Line3D.h"}\par
00003 {\cf21 #include <math.h>}\par
00004 \par
00005 \par
00006 {\cf20 /* initialisieren des Punktes */}\par
00007 CPoint3D::CPoint3D({\cf18 void})\par
00008 \{\par
00009     x = 0;\par
00010     y = 0;\par
00011     z = 0;\par
00012 \}\par
00013 \par
00014 CPoint3D::CPoint3D({\cf18 double} X, {\cf18 double} Y, {\cf18 double} Z)\par
00015 \{\par
00016     x = X;\par
00017     y = Y;\par
00018     z = Z;\par
00019 \}\par
00020 \par
00021 CPoint3D::~CPoint3D({\cf18 void})\par
00022 \{\par
00023 \}\par
00024 \par
00025 {\cf18 double} CPoint3D::getX({\cf18 void})\par
00026 \{\par
00027     {\cf19 return} x;\par
00028 \}\par
00029 \par
00030 {\cf18 double} CPoint3D::getY({\cf18 void})\par
00031 \{\par
00032     {\cf19 return} y;\par
00033 \}\par
00034 \par
00035 {\cf18 double} CPoint3D::getZ({\cf18 void})\par
00036 \{\par
00037     {\cf19 return} z;\par
00038 \}\par
00039 \par
00040 {\cf18 void} CPoint3D::setX({\cf18 double} X)\par
00041 \{\par
00042     x = X;\par
00043 \}\par
00044 \par
00045 {\cf18 void} CPoint3D::setY({\cf18 double} Y)\par
00046 \{\par
00047     y = Y;\par
00048 \}\par
00049 \par
00050 {\cf18 void} CPoint3D::setZ({\cf18 double} Z)\par
00051 \{\par
00052     z = Z;\par
00053 \}\par
00054 \par
00055 {\cf18 void} CPoint3D::set({\cf18 double} X, {\cf18 double} Y, {\cf18 double} Z)\par
00056 \{\par
00057     x = X;\par
00058     y = Y;\par
00059     z = Z;\par
00060 \}\par
00061 \par
00062 {\cf18 double} CPoint3D::distanceTo(CPoint3D point)\par
00063 \{\par
00064     {\cf19 return} sqrt(pow(({\cf18 double})(x - ({\cf18 double})point.getX()), 2) + pow(({\cf18 double})(y - ({\cf18 double})point.getY()), 2) + pow(({\cf18 double})(z - ({\cf18 double})point.getZ()), 2));  {\cf20 // Pythagoras 3D}\par
00065 \}\par
00066 \par
00067 {\cf18 double} CPoint3D::distanceTo(CLine3D line)\par
00068 \{\par
00069     {\cf18 double} bx, by, bz, rv_sq, dist, vp1, vp2, vp3;          {\cf20 // Variablen Anlegen}\par
00070 \par
00071     {\cf20 /*}\par
00072 {\cf20     Vermessen wird der Punkt selbst}\par
00073 {\cf20 }\par
00074 {\cf20     bx, by, bz      == Vektordifferenz}\par
00075 {\cf20     rv_sq           == Betrag des Linienvektors}\par
00076 {\cf20     dist            == Distanz von Punkt zu Linie}\par
00077 {\cf20     vp1, vp2, vp3   == Vektorprodukte}\par
00078 {\cf20     */}\par
00079 \par
00080     {\cf18 int} rvx = line.p1.x - line.p2.x;        {\cf20 // Parameter X des Linienvektor berechnen}\par
00081     {\cf18 int} rvy = line.p1.y - line.p2.y;        {\cf20 // Parameter Y des Linienvektor berechnen}\par
00082     {\cf18 int} rvz = line.p1.z - line.p2.z;        {\cf20 // Parameter Z des Linienvektor berechnen}\par
00083 \par
00084     rv_sq = sqrt((({\cf18 double})rvx * ({\cf18 double})rvx) + (({\cf18 double})rvy * ({\cf18 double})rvy) + (({\cf18 double})rvz * ({\cf18 double})rvz));      {\cf20 // Betrag des Linienvektor berechnen}\par
00085 \par
00086     bx = x - (double)line.p1.x;             {\cf20 // X(Punkt) - X(Aufpunkt) }\par
00087     by = y - (double)line.p1.y;             {\cf20 // Y(Punkt) - Y(Aufpunkt)}\par
00088     bz = z - (double)line.p1.z;             {\cf20 // Z(Punkt) - Z(Aufpunkt)}\par
00089 \par
00090     vp1 = by * rvz - bz * rvy;              {\cf20 // Parameter X Vektorprodukt}\par
00091     vp2 = bz * rvx - bx * rvz;              {\cf20 // Parameter Y Vektorprodukt}\par
00092     vp3 = bx * rvy - by * rvx;              {\cf20 // Parameter Z Vektorprodukt}\par
00093 \par
00094     dist = sqrt(vp1 * vp1 + vp2 * vp2 + vp3 * vp3) / rv_sq; {\cf20 // Betrag des Vektors berechnen}\par
00095 \par
00096     {\cf19 return} dist;\par
00097 \}\par
00098 \par
00099 {\cf20 // InputPoint3D}\par
00100 \par
00101 CInputPoint3D::CInputPoint3D({\cf18 void}) : CPoint3D()\par
00102 \{\par
00103     timestamp = 0;\par
00104 \}\par
00105 \par
00106 CInputPoint3D::CInputPoint3D({\cf18 double} X, {\cf18 double} Y, {\cf18 double} Z, {\cf18 double} Timestamp, CEulerMatrix Matrix)\par
00107 \{\par
00108     x = X;\par
00109     y = Y;\par
00110     z = Z;\par
00111     timestamp = Timestamp;\par
00112     orientationMatrix = Matrix;\par
00113 \par
00114 \}\par
00115 \par
00116 CInputPoint3D::~CInputPoint3D({\cf18 void})\par
00117 \{\par
00118 \}\par
00119 \par
00120 {\cf18 void} CInputPoint3D::setEulerMatrix(CEulerMatrix orientation)\par
00121 \{\par
00122     orientationMatrix = orientation;\par
00123 \}\par
00124 \par
00125 \par
00126 {\cf18 void} CInputPoint3D::setPoint({\cf18 double} time, {\cf18 double} X, {\cf18 double} Y, {\cf18 double} Z, CEulerMatrix orientation)\par
00127 \{\par
00128     setTime(time);\par
00129     set(X, Y, Z);\par
00130     setEulerMatrix(orientation);\par
00131 \}\par
00132 \par
00133 {\cf18 void} CInputPoint3D::setTime({\cf18 double} time)\par
00134 \{\par
00135     timestamp = time;\par
00136 \}\par
00137 \par
00138 CEulerMatrix CInputPoint3D::getEulerMatrix()\par
00139 \{\par
00140     {\cf19 return} orientationMatrix;\par
00141 \}\par
00142 \par
00143 {\cf18 double} CInputPoint3D::getTime()\par
00144 \{\par
00145     {\cf19 return} timestamp;\par
00146 \}\par
00147 \par
00148 {\cf20 // OutputPoint3D}\par
00149 \par
00150 COutputPoint3D::COutputPoint3D({\cf18 void}) : CPoint3D()\par
00151 \{\par
00152     speed = 0;\par
00153     a = 0;\par
00154     b = 0;\par
00155     c = 0;\par
00156 \}\par
00157 \par
00158 COutputPoint3D::COutputPoint3D({\cf18 double} Speed, {\cf18 double} X, {\cf18 double} Y, {\cf18 double} Z, {\cf18 double} A, {\cf18 double} B, {\cf18 double} C)\par
00159 \{\par
00160     speed = Speed;\par
00161     a = A;\par
00162     b = B;\par
00163     c = C;\par
00164     x = X;\par
00165     y = Y;\par
00166     z = Z;\par
00167 \}\par
00168 \par
00169 COutputPoint3D::~COutputPoint3D({\cf18 void})\par
00170 \{\par
00171 \par
00172 \}\par
00173 \par
00174 {\cf18 double} COutputPoint3D::getA({\cf18 void})\par
00175 \{\par
00176     {\cf19 return} a;\par
00177 \}\par
00178 \par
00179 {\cf18 double} COutputPoint3D::getB({\cf18 void})\par
00180 \{\par
00181     {\cf19 return} b;\par
00182 \}\par
00183 \par
00184 {\cf18 double} COutputPoint3D::getC({\cf18 void})\par
00185 \{\par
00186     {\cf19 return} c;\par
00187 \}\par
00188 \par
00189 {\cf18 double} COutputPoint3D::getSpeed({\cf18 void})\par
00190 \{\par
00191     {\cf19 return} speed;\par
00192 \}\par
00193 \par
00194 {\cf18 void} COutputPoint3D::setA({\cf18 double} A)\par
00195 \{\par
00196     a = A;\par
00197 \}\par
00198 \par
00199 {\cf18 void} COutputPoint3D::setB({\cf18 double} B)\par
00200 \{\par
00201     b = B;\par
00202 \}\par
00203 \par
00204 {\cf18 void} COutputPoint3D::setC({\cf18 double} C)\par
00205 \{\par
00206     c = C;\par
00207 \}\par
00208 \par
00209 {\cf18 void} COutputPoint3D::setSpeed({\cf18 double} Speed)\par
00210 \{\par
00211     speed = Speed;\par
00212 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/RobCodeGenerator.cpp-Dateireferenz\par \pard\plain 
{\tc\tcl2 \v src/RobCodeGenerator.cpp}
{\xe \v src/RobCodeGenerator.cpp}
{\bkmkstart AAAAAAAACB}
{\bkmkend AAAAAAAACB}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "RobCodeGenerator.h"}\par
{\f2 #include "Point3D.h"}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
RobCodeGenerator.cpp\par \pard\plain 
{\tc\tcl2 \v src/RobCodeGenerator.cpp}
{\xe \v src/RobCodeGenerator.cpp}
{\bkmkstart AAAAAAAAAT}
{\bkmkend AAAAAAAAAT}
gehe zur Dokumentation dieser Datei{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "RobCodeGenerator.h"}\par
00002 {\cf21 #include "Point3D.h"}\par
00003 \par
00004 \par
00005 CRobCodeGenerator::CRobCodeGenerator({\cf18 void})\par
00006 \{\par
00007     speed = 0;\par
00008     speedManual = 0;\par
00009     orientationManual = 0;\par
00010     A = 0;\par
00011     B = 0;\par
00012     C = 0;\par
00013 \}\par
00014 \par
00015 CRobCodeGenerator::CRobCodeGenerator({\cf18 double} Speed, {\cf18 bool} SpeedManual, {\cf18 bool} OrientationManual, tuple<double, double, double> angles)\par
00016 \{\par
00017     speed = Speed;\par
00018     speedManual = SpeedManual;\par
00019     orientationManual = OrientationManual;\par
00020     A = get<0>(angles);\par
00021     B = get<1>(angles);\par
00022     C = get<2>(angles);\par
00023 \}\par
00024 \par
00025 CRobCodeGenerator::~CRobCodeGenerator({\cf18 void})\par
00026 \{\par
00027 \}\par
00028 \par
00029 {\cf18 void} CRobCodeGenerator::generateRobCode(vector<CInputPoint3D>& points, {\cf18 string} filename)\par
00030 \{\par
00031     postProcessing(points);\par
00032 \par
00033     errno_t err;\par
00034     \par
00035     FILE* fid;\par
00036 \par
00037     {\cf19 if} ((err = fopen_s(&fid, filename.c_str(), {\cf22 "w"})) != 0)\par
00038     \{ \par
00039         {\cf18 string} msg = {\cf22 "Open file: "};\par
00040         msg += filename;\par
00041         msg += {\cf22 " failed!"};\par
00042 \par
00043         {\cf19 throw} exception(msg.c_str());\par
00044     \}\par
00045 \par
00046     COutputPoint3D currentPoint;\par
00047 \par
00048     filename.erase(filename.end()-4,filename.end());\par
00049     fprintf(fid, {\cf22 "DEF %s \\n"}, filename.c_str());\par
00050 \par
00051     fputs({\cf22 "PTP $POS_ACT\\n"}, fid);\par
00052 \par
00053     {\cf19 if} (speedManual)\par
00054     \{\par
00055         fprintf(fid, {\cf22 "&VEL.CP %f"}, speed);\par
00056     \}\par
00057 \par
00058     {\cf19 for} ({\cf18 size_t} s = 0; s < points.size(); s++)\par
00059     \{\par
00060         currentPoint.set(points[s].getX(),points[s].getY(),points[s].getZ());\par
00061         \par
00062         {\cf20 //currentPoint = Transformation * currentPoint; //Here wee need a transformationmatrix containing public parameters scaleX,offsetX...}\par
00063         {\cf19 if}(!speedManual)\par
00064             fprintf(fid, {\cf22 "&VEL.CP %f"}, currentPoint.getSpeed());\par
00065         fprintf(fid, {\cf22 "LIN \{X %f, Y %f, Z %f, A %f, B %f, C %f\}\\n"}, currentPoint.getX(), currentPoint.getY(), currentPoint.getZ(), \par
00066             currentPoint.getA(), currentPoint.getB(), currentPoint.getC());\par
00067     \}\par
00068 \par
00069     fputs({\cf22 "END"}, fid);\par
00070 \}\par
00071 \par
00072 {\cf18 void} CRobCodeGenerator::postProcessing(vector<CInputPoint3D>& path)\par
00073 \{\par
00074     COutputPoint3D p;\par
00075     CInputPoint3D  pIn;\par
00076     {\cf18 double} timePrev = 0;\par
00077 \par
00078     {\cf19 for} ({\cf18 size_t} s = 0; s < path.size(); s++)\par
00079     \{\par
00080         p.set(path[s].getX(), path[s].getY(), path[s].getZ());\par
00081         {\cf19 if} (speedManual)\par
00082         \{\par
00083             {\cf19 if} (speed > MAX_SPEED) {\cf20 //Wenn maximale Geschwindigkeit \'FCberschritten wird, Geschwindigkeit begrenzen}\par
00084                 speed = MAX_SPEED;\par
00085         \}\par
00086         {\cf19 else}\par
00087         \{\par
00088             {\cf19 if} (s == 0)\par
00089                 p.setSpeed(1); {\cf20 //Der erste Punkt(0) wird mit Standardgeschwindigkeit 1m/s angefahren.}\par
00090 \par
00091             {\cf19 else}\par
00092                 p.setSpeed(calculateSpeed(path[s], s, timePrev)); {\cf20 //Die Geschwindigkeit zwischen den weiteren Punkten wird berechnet.}\par
00093         \}\par
00094 \par
00095         {\cf19 if} (!orientationManual)\par
00096         \{\par
00097             p.setA(A);\par
00098             p.setB(B);\par
00099             p.setC(C);\par
00100         \}\par
00101         {\cf19 else}\par
00102             calculateAngles(p, pIn);\par
00103         timePrev = path[s].getTime();\par
00104         processedPath.push_back(p);\par
00105     \}\par
00106 \par
00107 \}\par
00108 \par
00109 {\cf18 double} CRobCodeGenerator::calculateSpeed(CInputPoint3D& p, {\cf18 size_t} s, {\cf18 double} timePrev)\par
00110 \{\par
00111     {\cf18 double} distance = 0;\par
00112     {\cf18 double} time = 0;\par
00113 \par
00114     distance = processedPath[s - 1].distanceTo(p); {\cf20 //Strecke zwischen p und dem Punkt zuvor}\par
00115     time = p.getTime() - timePrev; {\cf20 //Zeit zwischen p-1 und p}\par
00116 \par
00117     speed = distance / time; {\cf20 // Berechnug Geschwindigkeit zwischen zwei Punkten}\par
00118 \par
00119     {\cf19 if} (speed > MAX_SPEED) {\cf20 //Begrenzung auf maximale Geschwindigkeit, falls Trackerdaten h\'F6heren Wert aufweisen}\par
00120         speed = MAX_SPEED;\par
00121 \par
00122     {\cf19 return} speed; {\cf20 //Zuweisung der Geschwindigkeit}\par
00123 \}\par
00124 \par
00125 {\cf18 void} CRobCodeGenerator::calculateAngles(COutputPoint3D& p, CInputPoint3D& pIn)\par
00126 \{\par
00127     {\cf18 double} a, b, c;\par
00128 \par
00129     {\cf20 // Funktion in Eulermatrix aufrufen die a/b/c neu berechnet}\par
00130 \par
00131     p.setA(a);\par
00132     p.setB(b);\par
00133     p.setC(c);\par
00134 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/RobPathEditor.cpp-Dateireferenz\par \pard\plain 
{\tc\tcl2 \v src/RobPathEditor.cpp}
{\xe \v src/RobPathEditor.cpp}
{\bkmkstart AAAAAAAACC}
{\bkmkend AAAAAAAACC}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "SegmentApproximator.h"}\par
{\f2 #include "PathBuilder.h"}\par
{\f2 #include "RobCodeGenerator.h"}\par
{\f2 #include "InputParameter.h"}\par
{\f2 #include "MeanFilter.h"}\par
{\f2 #include "GUI.h"}\par
{\f2 #include <iostream>}\par
{\f2 #include <ctime>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Funktionen\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b main} ()\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Dokumentation der Funktionen\par
\pard\plain 
{\xe \v main\:RobPathEditor.cpp}
{\xe \v RobPathEditor.cpp\:main}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int main ()}}
\par
{\bkmkstart AAAAAAAACD}
{\bkmkend AAAAAAAACD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definiert in Zeile {\b 31} der Datei {\b RobPathEditor.cpp}.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00032 \{\par
00033     clock_t start;\par
00034     start = clock();\par
00035 \par
00036     {\cf19 try}\par
00037     \{\par
00038         {\cf20 //read Data}\par
00039 \par
00040         CInputParameter inputParameter;\par
00041         {\cf18 string} path = {\cf22 "input/path_01.csv"};\par
00042         inputParameter.openFile(path);\par
00043 \par
00044         {\cf20 //moving Average}\par
00045 \par
00046         CMeanFilter meanFilter;\par
00047         meanFilter.setWindowSize(3);\par
00048         meanFilter.mean(inputParameter.getPath());\par
00049 \par
00050         {\cf20 // Douglas-Peuker Algorithm}\par
00051 \par
00052         CSegmentApproximator segmentApproximator;\par
00053         segmentApproximator.setmaxDistance(0.5);\par
00054         segmentApproximator.approx(meanFilter.getPath());\par
00055 \par
00056         {\cf20 // Puts the Segments together to one path}\par
00057 \par
00058         CPathBuilder pathBuilder;\par
00059         pathBuilder.createPath(segmentApproximator.getSegmentsApproxVector(), {\cf22 "output/08_path.csv"});\par
00060 \par
00061         {\cf20 // Calculates Speed, Angle and generates the Output Data}\par
00062 \par
00063         CRobCodeGenerator codeGenerator(inputParameter.getSpeed(), inputParameter.getSpeedManual(),\par
00064             inputParameter.getOrientationManual(), inputParameter.getAngles());\par
00065         codeGenerator.generateRobCode(pathBuilder.getPath(), {\cf22 "output/09_robCode.src"});\par
00066     \par
00067         {\cf18 float} elapsed = (float)(clock() - start) / CLOCKS_PER_SEC;\par
00068     \}\par
00069 \par
00070     {\cf19 catch} (exception& e)\par
00071     \{\par
00072         cerr << e.what() << {\cf22 "\\n"};\par
00073     \}\par
00074 \par
00075     system({\cf22 "pause"});\par
00076 \par
00077    {\cf19 return} 0;\par
00078 \}\par
}
{
\ql
Benutzt {\b CSegmentApproximator::approx()}, {\b CPathBuilder::createPath()}, {\b CRobCodeGenerator::generateRobCode()}, {\b CInputParameter::getAngles()}, {\b CInputParameter::getOrientationManual()}, {\b CInputParameter::getPath()}, {\b CMeanFilter::getPath()}, {\b CPathBuilder::getPath()}, {\b CSegmentApproximator::getSegmentsApproxVector()}, {\b CInputParameter::getSpeed()}, {\b CInputParameter::getSpeedManual()}, {\b CMeanFilter::mean()}, {\b CInputParameter::openFile()}, {\b CSegmentApproximator::setmaxDistance()} und {\b CMeanFilter::setWindowSize()}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
RobPathEditor.cpp\par \pard\plain 
{\tc\tcl2 \v src/RobPathEditor.cpp}
{\xe \v src/RobPathEditor.cpp}
{\bkmkstart AAAAAAAAAU}
{\bkmkend AAAAAAAAAU}
gehe zur Dokumentation dieser Datei{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 \par
00020 {\cf21 #include "SegmentApproximator.h"}\par
00021 {\cf21 #include "PathBuilder.h"}\par
00022 {\cf21 #include "RobCodeGenerator.h"}\par
00023 {\cf21 #include "InputParameter.h"}\par
00024 {\cf21 #include "MeanFilter.h"}\par
00025 {\cf21 #include "GUI.h"}\par
00026 {\cf21 #include <iostream>}\par
00027 {\cf21 #include <ctime>}\par
00028 \par
00029 {\cf17 using namespace }std;\par
00030 \par
00031 {\cf18 int} main()\par
00032 \{\par
00033     clock_t start;\par
00034     start = clock();\par
00035 \par
00036     {\cf19 try}\par
00037     \{\par
00038         {\cf20 //read Data}\par
00039 \par
00040         CInputParameter inputParameter;\par
00041         {\cf18 string} path = {\cf22 "input/path_01.csv"};\par
00042         inputParameter.openFile(path);\par
00043 \par
00044         {\cf20 //moving Average}\par
00045 \par
00046         CMeanFilter meanFilter;\par
00047         meanFilter.setWindowSize(3);\par
00048         meanFilter.mean(inputParameter.getPath());\par
00049 \par
00050         {\cf20 // Douglas-Peuker Algorithm}\par
00051 \par
00052         CSegmentApproximator segmentApproximator;\par
00053         segmentApproximator.setmaxDistance(0.5);\par
00054         segmentApproximator.approx(meanFilter.getPath());\par
00055 \par
00056         {\cf20 // Puts the Segments together to one path}\par
00057 \par
00058         CPathBuilder pathBuilder;\par
00059         pathBuilder.createPath(segmentApproximator.getSegmentsApproxVector(), {\cf22 "output/08_path.csv"});\par
00060 \par
00061         {\cf20 // Calculates Speed, Angle and generates the Output Data}\par
00062 \par
00063         CRobCodeGenerator codeGenerator(inputParameter.getSpeed(), inputParameter.getSpeedManual(),\par
00064             inputParameter.getOrientationManual(), inputParameter.getAngles());\par
00065         codeGenerator.generateRobCode(pathBuilder.getPath(), {\cf22 "output/09_robCode.src"});\par
00066     \par
00067         {\cf18 float} elapsed = (float)(clock() - start) / CLOCKS_PER_SEC;\par
00068     \}\par
00069 \par
00070     {\cf19 catch} (exception& e)\par
00071     \{\par
00072         cerr << e.what() << {\cf22 "\\n"};\par
00073     \}\par
00074 \par
00075     system({\cf22 "pause"});\par
00076 \par
00077    {\cf19 return} 0;\par
00078 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/SegmentApproximator.cpp-Dateireferenz\par \pard\plain 
{\tc\tcl2 \v src/SegmentApproximator.cpp}
{\xe \v src/SegmentApproximator.cpp}
{\bkmkstart AAAAAAAACE}
{\bkmkend AAAAAAAACE}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "SegmentApproximator.h"}\par
{\f2 #include "Point3D.h"}\par
{\f2 #include "Line3D.h"}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SegmentApproximator.cpp\par \pard\plain 
{\tc\tcl2 \v src/SegmentApproximator.cpp}
{\xe \v src/SegmentApproximator.cpp}
{\bkmkstart AAAAAAAAAV}
{\bkmkend AAAAAAAAAV}
gehe zur Dokumentation dieser Datei{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "SegmentApproximator.h"}\par
00002 {\cf21 #include "Point3D.h"}\par
00003 {\cf21 #include "Line3D.h"}\par
00004 \par
00005 CSegmentApproximator::CSegmentApproximator({\cf18 void})\par
00006 \{\par
00007 \}\par
00008 \par
00009 CSegmentApproximator::~CSegmentApproximator({\cf18 void})\par
00010 \{\par
00011 \}\par
00012 \par
00013 {\cf18 void} CSegmentApproximator::approx({\cf17 const} vector<list<CInputPoint3D>>& segments)\par
00014 \{\par
00015     CInputPoint3D p;\par
00016 \par
00017     segmentsApprox = segments;\par
00018 \par
00019     {\cf19 for} ({\cf18 size_t} s = 0; s < segments.size(); s++)\par
00020     \{\par
00021         douglasPeuckerRecursive(segmentsApprox[s], segmentsApprox[s].begin(), --(segmentsApprox[s].end()), maxDistance);\par
00022     \}\par
00023 \par
00024 \}\par
00025 \par
00026 {\cf18 void} CSegmentApproximator::setmaxDistance({\cf18 double} maxDistanceSource)\par
00027 \{\par
00028     maxDistance = maxDistanceSource;\par
00029 \}\par
00030 \par
00031 {\cf18 double} CSegmentApproximator::getmaxDistance()\par
00032 \{\par
00033     {\cf19 return} maxDistance;\par
00034 \}\par
00035 \par
00036 vector<list<CInputPoint3D>>& CSegmentApproximator::getSegmentsApproxVector()\par
00037 \{\par
00038     {\cf19 return} segmentsApprox;\par
00039 \}\par
00040 \par
00041 {\cf18 void} CSegmentApproximator::douglasPeuckerRecursive(list<CInputPoint3D>& segment, std::list<CInputPoint3D>::iterator startItr, std::list<CInputPoint3D>::iterator endItr, {\cf18 double} maxDistance)\par
00042 \{\par
00043     {\cf19 if} (segment.size() < 3) {\cf19 return};\par
00044     {\cf19 if} (distance(startItr, endItr) == 2) {\cf19 return};\par
00045     CInputPoint3D pStart; CInputPoint3D pEnd;\par
00046     pStart.setX(startItr->getX()); pStart.setY(startItr->getY()); pStart.setZ(startItr->getZ());\par
00047 \par
00048     {\cf20 //pEnd.x=segment.back().x; pEnd.y = segment.back().y;}\par
00049     pEnd.setX(endItr->getX()); pEnd.setY(endItr->getY()); pEnd.setZ(endItr->getZ());\par
00050 \par
00051     {\cf18 double} dist = 0.0, maxDist = 0.0;\par
00052     std::list<CInputPoint3D>::iterator maxItr, itr;\par
00053 \par
00054     {\cf19 for} (itr = startItr; itr != endItr; itr++)\par
00055     \{\par
00056         CLine3D line = CLine3D(pStart, pEnd);\par
00057         {\cf20 // calc distance}\par
00058         dist = itr->distanceTo(line);\par
00059         {\cf20 //dist=calcDist(pStart.getX(), pStart.getY(), pEnd.getX(), pEnd.getY(), itr->getX(), itr->getY());}\par
00060         {\cf19 if} (dist > maxDist) \{\par
00061             maxDist = dist;\par
00062             maxItr = itr;\par
00063         \}\par
00064     \}\par
00065 \par
00066     {\cf19 if} (maxDist <= maxDistance) \{\par
00067 \par
00068         segment.erase((++startItr), endItr);\par
00069         {\cf20 //for(itr = (++startItr); itr != --(endItr);)}\par
00070         {\cf20 //\{}\par
00071         {\cf20 //  // erase elements:}\par
00072         {\cf20 //  itr = segment.erase(itr);}\par
00073         {\cf20 //\}}\par
00074         {\cf19 return};\par
00075     \}\par
00076 \par
00077     douglasPeuckerRecursive(segment, startItr, maxItr, maxDistance);\par
00078     douglasPeuckerRecursive(segment, maxItr, endItr, maxDistance);\par
00079 \}\par
00080 \par
00081 {\cf18 double} CSegmentApproximator::calcDist({\cf18 int} xS, {\cf18 int} yS, {\cf18 int} zS, {\cf18 int} xE, {\cf18 int} yE, {\cf18 int} zE, {\cf18 int} x, {\cf18 int} y, {\cf18 int} z)\par
00082 \{\par
00083     {\cf20 /*}\par
00084 {\cf20     xS, yS, zS      == Startpunkt}\par
00085 {\cf20     xE, yE, zE      == Endpunkt}\par
00086 {\cf20     x, y, z         == Vermessungspunkt}\par
00087 {\cf20     */}\par
00088 \par
00089     {\cf20 //Crossproduct}\par
00090     {\cf18 double} bx, by, bz, rv_sq, dist, vp1, vp2, vp3;\par
00091 \par
00092     {\cf20 /*}\par
00093 {\cf20     bx, by, bz      == Vektordifferenz}\par
00094 {\cf20     rv_sq           == Betrag des Linienvektors}\par
00095 {\cf20     dist            == Distanz von Punkt zu Linie}\par
00096 {\cf20     vp1, vp2, vp3   == Vektorprodukte}\par
00097 {\cf20     */}\par
00098 \par
00099     {\cf18 int} rvx = xS - xE;      {\cf20 // Parameter X des Linienvektor berechnen}\par
00100     {\cf18 int} rvy = yS - yE;      {\cf20 // Parameter Y des Linienvektor berechnen}\par
00101     {\cf18 int} rvz = zS - zE;      {\cf20 // Parameter Z des Linienvektor berechnen}\par
00102 \par
00103     rv_sq = sqrt((rvx * rvx) + (rvy * rvy) + (rvz * rvz));      {\cf20 // Betrag des Linienvektor berechnen}\par
00104 \par
00105     bx = x - xS;            {\cf20 // X(Punkt) - X(Aufpunkt)}\par
00106     by = y - yS;            {\cf20 // Y(Punkt) - Y(Aufpunkt)}\par
00107     bz = z - zS;            {\cf20 // Z(Punkt) - Z(Aufpunkt)}\par
00108 \par
00109     vp1 = by * rvz - bz * rvy;      {\cf20 // Parameter X Vektorprodukt}\par
00110     vp2 = bz * rvx - bx * rvz;      {\cf20 // Parameter Y Vektorprodukt}\par
00111     vp3 = bx * rvy - by * rvx;      {\cf20 // Parameter Z Vektorprodukt}\par
00112 \par
00113     dist = sqrt(vp1 * vp1 + vp2 * vp2 + vp3 * vp3) / rv_sq; {\cf20 // Betrag des Vektors berechnen}\par
00114 \par
00115     {\cf19 return} dist;\par
00116 \par
00117 \}\par
}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid Index\par 
\pard\plain 
{\tc \v Index}
{\field\fldedit {\*\fldinst INDEX \\c2 \\*MERGEFORMAT}{\fldrslt INDEX}}
}
